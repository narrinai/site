<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Character Chat - Narrin AI</title>
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  
  <!-- Import Modern Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700;800&family=Outfit:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <style>
    /* ===== CSS CUSTOM PROPERTIES ===== */
    :root {
      /* Primary Colors */
      --color-white: #ffffff;
      --color-off-white: #fafafa;
      --color-light-gray: #f5f5f5;
      
      /* Accent Colors */
      --color-teal: #14b8a6;
      --color-teal-light: #5eead4;
      --color-teal-dark: #0f766e;
      --color-teal-alt: #10a394;
      --color-coral: #f97316;
      --color-coral-light: #fb923c;
      --color-coral-dark: #ea580c;
      
      /* Supporting Colors */
      --color-navy: #1e293b;
      --color-navy-light: #334155;
      --color-gray: #64748b;
      --color-gray-light: #94a3b8;
      --color-gray-dark: #475569;
      
      /* Gradients */
      --gradient-primary: linear-gradient(135deg, var(--color-teal) 0%, var(--color-coral) 100%);
      --gradient-subtle: linear-gradient(135deg, var(--color-teal-light) 0%, var(--color-coral-light) 100%);
      --gradient-tags: linear-gradient(135deg, var(--color-teal-alt) 0%, var(--color-coral) 100%);
      
      /* Shadows */
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --shadow-colored: 0 10px 25px -5px rgba(20, 184, 166, 0.2);
      
      /* Spacing */
      --spacing-xs: 0.5rem;
      --spacing-sm: 0.75rem;
      --spacing-md: 1rem;
      --spacing-lg: 1.5rem;
      --spacing-xl: 2rem;
      --spacing-2xl: 3rem;
      --spacing-3xl: 4rem;
      
      /* Typography */
      --font-primary: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, sans-serif;
      --font-secondary: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
      
      /* Font Sizes */
      --font-size-xs: 0.75rem;
      --font-size-sm: 0.875rem;
      --font-size-base: 1rem;
      --font-size-lg: 1.125rem;
      --font-size-xl: 1.25rem;
      --font-size-2xl: 1.5rem;
      --font-size-3xl: 1.875rem;
      --font-size-4xl: 2.25rem;
      
      /* Border Radius */
      --radius-sm: 6px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 24px;
      --radius-full: 9999px;
      
      /* Transitions */
      --transition-fast: 150ms ease-out;
      --transition-base: 300ms ease-out;
      --transition-slow: 500ms ease-out;
      
      /* Touch Target Size */
      --touch-target: 44px;
      
      /* Z-index Scale */
      --z-dropdown: 100;
      --z-sticky: 200;
      --z-overlay: 300;
      --z-modal: 400;
      --z-menu-overlay: 500;
    }

    /* ===== RESET & BASE STYLES ===== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      overflow-x: hidden;
    }

    body {
      font-family: var(--font-primary);
      background: var(--color-off-white);
      color: var(--color-navy);
      line-height: 1.6;
      font-size: var(--font-size-base);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
      width: 100%;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      -webkit-overflow-scrolling: touch;
    }

    input,
    button,
    textarea {
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      z-index: 10;
      position: relative;
    }

    /* ===== ACCESSIBILITY ===== */
    :focus {
      outline: 2px solid var(--color-teal);
      outline-offset: 2px;
    }

    :focus:not(:focus-visible) {
      outline: none;
    }

    /* ===== HEADER NAVIGATION ===== */
    .header {
      position: sticky;
      top: 0;
      z-index: var(--z-sticky);
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      transition: all var(--transition-base);
    }

    .header-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 var(--spacing-lg);
      width: 100%;
      overflow: hidden;
    }

    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      min-height: 72px;
      gap: var(--spacing-lg);
      width: 100%;
    }

    /* Logo */
    .logo {
      font-family: var(--font-secondary);
      font-size: var(--font-size-xl);
      font-weight: 800;
      text-decoration: none;
      letter-spacing: -0.02em;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      transition: transform var(--transition-base);
      flex-shrink: 0;
    }

    .logo:hover {
      transform: scale(1.05);
    }

    /* Desktop Navigation Center */
    .nav-center {
      display: none;
      align-items: center;
      gap: var(--spacing-2xl);
      flex: 1;
      justify-content: center;
    }

    /* USPs Container - Desktop */
    .nav-usps {
      display: flex;
      align-items: center;
      gap: var(--spacing-xl);
    }

    .usp-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      color: var(--color-gray-dark);
      font-size: var(--font-size-xs);
      font-weight: 500;
      white-space: nowrap;
    }

    .usp-icon {
      font-size: var(--font-size-lg);
      color: var(--color-teal);
    }

    /* Search Bar - Desktop */
    .nav-search {
      position: relative;
      width: 100%;
      max-width: 400px;
    }

    .nav-search-input {
      width: 100%;
      padding: var(--spacing-sm) var(--spacing-lg);
      padding-right: calc(var(--spacing-lg) * 2.5);
      font-size: var(--font-size-sm);
      font-family: inherit;
      border: 2px solid var(--color-light-gray);
      border-radius: var(--radius-full);
      background: var(--color-white);
      color: var(--color-navy);
      transition: all var(--transition-base);
    }

    .nav-search-input:hover {
      border-color: var(--color-gray-light);
    }

    .nav-search-input:focus {
      border-color: var(--color-teal);
      box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
    }

    .nav-search-input::placeholder {
      color: var(--color-gray-light);
    }

    .search-submit {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      background: var(--gradient-primary);
      border: none;
      border-radius: var(--radius-full);
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all var(--transition-base);
    }

    .search-submit:hover {
      transform: translateY(-50%) scale(1.1);
    }

    .search-submit svg {
      width: 18px;
      height: 18px;
      color: var(--color-white);
    }

    /* Navigation Links - Desktop */
    .nav-links {
      display: none;
      align-items: center;
      gap: var(--spacing-xl);
    }

    .nav-link {
      color: var(--color-navy);
      text-decoration: none;
      font-weight: 500;
      font-size: var(--font-size-sm);
      transition: color var(--transition-base);
      position: relative;
      padding: var(--spacing-xs) 0;
    }

    .nav-link::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background: var(--gradient-primary);
      transition: width var(--transition-base);
    }

    .nav-link:hover {
      color: var(--color-teal);
    }

    .nav-link:hover::after {
      width: 100%;
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: var(--spacing-sm) var(--spacing-lg);
      font-size: var(--font-size-sm);
      font-weight: 600;
      text-decoration: none;
      border: none;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-base);
      min-height: var(--touch-target);
      white-space: nowrap;
    }

    .btn-primary {
      background: var(--gradient-primary);
      color: var(--color-white);
      box-shadow: var(--shadow-colored);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    /* Mobile Navigation Container */
    .mobile-nav-container {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      flex-shrink: 0;
    }

    /* Mobile Chat Button */
    .mobile-chat-btn {
      display: none;
      align-items: center;
      justify-content: center;
      width: var(--touch-target);
      height: var(--touch-target);
      background: transparent;
      border: none;
      cursor: pointer;
      color: var(--color-navy);
      transition: all var(--transition-base);
      border-radius: var(--radius-md);
      flex-shrink: 0;
      text-decoration: none;
    }

    .mobile-chat-btn:hover {
      background: var(--color-light-gray);
    }

    .mobile-chat-btn svg {
      width: 24px;
      height: 24px;
    }

    /* Mobile Search Button */
    .mobile-search-btn {
      display: none;
      align-items: center;
      justify-content: center;
      width: var(--touch-target);
      height: var(--touch-target);
      background: transparent;
      border: none;
      cursor: pointer;
      color: var(--color-navy);
      transition: all var(--transition-base);
      border-radius: var(--radius-md);
      flex-shrink: 0;
    }

    .mobile-search-btn:hover {
      background: var(--color-light-gray);
    }

    .mobile-search-btn svg {
      width: 24px;
      height: 24px;
    }

    /* Mobile Hamburger Menu */
    .mobile-menu-btn {
      display: none;
      align-items: center;
      justify-content: center;
      width: var(--touch-target);
      height: var(--touch-target);
      background: transparent;
      border: none;
      cursor: pointer;
      color: var(--color-navy);
      transition: all var(--transition-base);
      border-radius: var(--radius-md);
      position: relative;
      flex-shrink: 0;
      z-index: var(--z-menu-overlay);
    }

    .mobile-menu-btn:hover {
      background: var(--color-light-gray);
    }

    .hamburger {
      width: 24px;
      height: 18px;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .hamburger span {
      display: block;
      height: 2px;
      width: 100%;
      background: var(--color-navy);
      border-radius: 1px;
      transition: all var(--transition-base);
    }

    .mobile-menu-btn.active .hamburger span:nth-child(1) {
      transform: rotate(45deg) translate(6px, 6px);
    }

    .mobile-menu-btn.active .hamburger span:nth-child(2) {
      opacity: 0;
    }

    .mobile-menu-btn.active .hamburger span:nth-child(3) {
      transform: rotate(-45deg) translate(6px, -6px);
    }

    /* Mobile Menu Overlay - Full Screen */
    .mobile-menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(30, 41, 59, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      z-index: var(--z-overlay);
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-base);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .mobile-menu-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .mobile-menu-content {
      background: var(--color-white);
      border-radius: var(--radius-xl);
      padding: var(--spacing-3xl) var(--spacing-xl);
      box-shadow: var(--shadow-xl);
      max-width: 90vw;
      width: 100%;
      max-width: 400px;
      transform: scale(0.9) translateY(20px);
      transition: all var(--transition-base);
    }

    .mobile-menu-overlay.active .mobile-menu-content {
      transform: scale(1) translateY(0);
    }

    .mobile-menu-header {
      text-align: center;
      margin-bottom: var(--spacing-2xl);
    }

    .mobile-menu-logo {
      font-family: var(--font-secondary);
      font-size: var(--font-size-2xl);
      font-weight: 800;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: var(--spacing-sm);
    }

    .mobile-menu-subtitle {
      color: var(--color-gray);
      font-size: var(--font-size-sm);
    }

    .mobile-menu-nav {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
    }

    .mobile-menu-link {
      display: flex;
      align-items: center;
      padding: var(--spacing-md) var(--spacing-lg);
      color: var(--color-navy);
      text-decoration: none;
      font-weight: 500;
      font-size: var(--font-size-base);
      transition: all var(--transition-base);
      border-radius: var(--radius-md);
      background: var(--color-off-white);
    }

    .mobile-menu-link:hover {
      background: var(--color-light-gray);
      color: var(--color-teal);
      transform: translateX(4px);
    }

    .mobile-menu-link.btn-primary {
      background: var(--gradient-primary);
      color: var(--color-white);
      justify-content: center;
      font-weight: 700;
      margin-top: var(--spacing-lg);
    }

    .mobile-menu-link.btn-primary:hover {
      background: var(--gradient-primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .mobile-menu-link-icon {
      margin-right: var(--spacing-sm);
      font-size: var(--font-size-lg);
    }

    /* Mobile Search Overlay */
    .mobile-search-overlay {
      position: fixed;
      top: 72px;
      left: 0;
      right: 0;
      background: var(--color-white);
      padding: var(--spacing-lg);
      box-shadow: var(--shadow-lg);
      transform: translateY(-100%);
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-base);
      z-index: var(--z-dropdown);
    }

    .mobile-search-overlay.active {
      transform: translateY(0);
      opacity: 1;
      visibility: visible;
    }

    .mobile-search-form {
      display: flex;
      gap: var(--spacing-sm);
    }

    .mobile-search-input {
      flex: 1;
      padding: var(--spacing-md);
      font-size: var(--font-size-base);
      font-family: inherit;
      border: 2px solid var(--color-light-gray);
      border-radius: var(--radius-md);
      background: var(--color-white);
      color: var(--color-navy);
      transition: all var(--transition-base);
    }

    .mobile-search-input:focus {
      border-color: var(--color-teal);
      box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
    }

    /* Desktop Styles */
    @media (min-width: 769px) {
      .nav-center {
        display: flex;
      }

      .nav-links {
        display: flex;
      }

      .mobile-nav-container {
        display: none;
      }

      .mobile-chat-btn {
        display: none !important;
      }

      .mobile-search-btn {
        display: none !important;
      }

      .mobile-menu-btn {
        display: none !important;
      }

      .mobile-menu-overlay {
        display: none !important;
      }
    }

    /* Mobile Styles */
    @media (max-width: 768px) {
      .header-container {
        padding: 0 var(--spacing-md);
      }

      .header-content {
        min-height: 60px;
        gap: var(--spacing-sm);
        padding: 0;
        display: grid;
        grid-template-columns: auto 1fr auto auto auto;
        align-items: center;
      }

      .logo {
        font-size: var(--font-size-lg);
        flex-shrink: 0;
        min-width: fit-content;
        grid-column: 1;
      }

      .mobile-nav-container {
        flex-shrink: 0;
        min-width: fit-content;
        display: flex !important;
        gap: var(--spacing-xs);
        grid-column: 3 / 6;
        justify-self: end;
      }

      .nav-center {
        display: none !important;
      }

      .nav-links {
        display: none !important;
      }

      .mobile-chat-btn {
        display: flex;
        flex-shrink: 0;
      }

      .mobile-search-btn {
        display: flex;
        flex-shrink: 0;
      }

      .mobile-menu-btn {
        display: flex;
        flex-shrink: 0;
      }

      .mobile-search-overlay {
        top: 60px;
      }
    }

    /* Extra small mobile devices */
    @media (max-width: 480px) {
      .header-content {
        gap: var(--spacing-xs);
        grid-template-columns: auto 1fr auto auto auto;
      }
      
      .logo {
        font-size: var(--font-size-base);
      }
    }

    /* Netlify Identity Modal Positioning */
    .netlify-identity-widget,
    [data-netlify-identity-widget] {
      z-index: 2147483647 !important;
    }

    .netlify-identity-widget iframe,
    .netlify-identity-widget > div,
    .netlify-identity-widget .netlify-identity-modal {
      z-index: 2147483647 !important;
    }

    /* CHAT SPECIFIC STYLES */
    .container {
      max-width: 700px;
      margin: 0 auto;
      padding: var(--spacing-md) var(--spacing-xl);
    }

    .page-header {
      text-align: center;
      margin-bottom: var(--spacing-xl);
    }

    .page-header h1 {
      font-family: var(--font-secondary);
      font-size: var(--font-size-2xl);
      margin: 0 0 var(--spacing-xs) 0;
      color: var(--color-navy);
      font-weight: 700;
      letter-spacing: -0.01em;
    }

    .page-header p {
      color: var(--color-gray);
      font-size: var(--font-size-sm);
      margin: 0;
      font-weight: 400;
    }

    .character-section {
      background: var(--color-white);
      padding: var(--spacing-lg) var(--spacing-xl);
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-lg);
      box-shadow: var(--shadow-md);
      border: 2px solid var(--color-light-gray);
      transition: all var(--transition-base);
    }

    .character-section:hover {
      border-color: var(--color-teal);
      box-shadow: var(--shadow-lg);
    }

    .character-header {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
    }

    .character-avatar {
      width: 60px;
      height: 60px;
      border-radius: var(--radius-full);
      object-fit: cover;
      background: var(--color-light-gray);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--font-size-2xl);
      flex-shrink: 0;
      border: 3px solid var(--color-light-gray);
      transition: all var(--transition-base);
      position: relative;
    }

    .character-avatar img {
      width: 100%;
      height: 100%;
      border-radius: var(--radius-full);
      object-fit: cover;
    }

    /* Online indicator for character avatar */
    .online-indicator {
      position: absolute;
      bottom: 2px;
      right: 2px;
      width: 16px;
      height: 16px;
      background: #22c55e;
      border: 2px solid var(--color-white);
      border-radius: var(--radius-full);
      box-shadow: var(--shadow-sm);
      animation: onlinePulse 2s infinite;
    }

    @keyframes onlinePulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.8;
        transform: scale(1.1);
      }
    }

    .character-info {
      flex: 1;
    }

    .character-info h2 {
      margin: 0 0 var(--spacing-xs) 0;
      color: var(--color-navy);
      font-size: var(--font-size-lg);
      font-weight: 700;
      font-family: var(--font-secondary);
      letter-spacing: -0.01em;
    }

    .character-info p {
      margin: 0;
      color: var(--color-gray);
      font-size: var(--font-size-sm);
      font-weight: 500;
    }

    .chat-section {
      background: var(--color-white);
      padding: var(--spacing-lg) var(--spacing-xl);
      border-radius: var(--radius-lg);
      max-width: 900px;
      margin: 0 auto;
      margin-bottom: var(--spacing-lg);
      box-shadow: var(--shadow-md);
      border: 2px solid var(--color-light-gray);
      transition: all var(--transition-base);
    }

    .chat-section:hover {
      border-color: var(--color-teal);
      box-shadow: var(--shadow-lg);
    }

    .loading-state {
      text-align: center;
      padding: var(--spacing-3xl) var(--spacing-xl);
      color: var(--color-gray);
    }

    .loading-state h3 {
      font-family: var(--font-secondary);
      font-size: var(--font-size-2xl);
      margin: 0 0 var(--spacing-md) 0;
      color: var(--color-navy);
      font-weight: 700;
    }

    .error-state {
      text-align: center;
      padding: var(--spacing-2xl) var(--spacing-xl);
      color: #c53030;
      background: #fed7d7;
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-xl);
      box-shadow: var(--shadow-md);
    }

    .error-state h3 {
      margin: 0 0 var(--spacing-xs) 0;
      color: #c53030;
      font-size: var(--font-size-2xl);
      font-family: var(--font-secondary);
      font-weight: 700;
    }

    .error-state p {
      margin: 0 0 var(--spacing-lg) 0;
      font-size: var(--font-size-base);
    }

    .error-state a {
      color: var(--color-teal);
      text-decoration: none;
      font-weight: 600;
      transition: all var(--transition-base);
      padding: var(--spacing-xs) var(--spacing-sm);
      border-radius: var(--radius-md);
    }

    .error-state a:hover {
      color: var(--color-white);
      background: var(--color-teal);
      transform: translateY(-1px);
    }

    #chatlog {
      height: 450px;
      overflow-y: auto;
      background: var(--color-off-white);
      padding: var(--spacing-lg);
      border-radius: var(--radius-md);
      margin-bottom: var(--spacing-lg);
      font-size: var(--font-size-sm);
      border: 2px solid var(--color-light-gray);
      box-shadow: var(--shadow-sm);
      transition: all var(--transition-base);
    }

    #chatlog:hover {
      border-color: var(--color-teal);
    }

    #chatlog p {
      margin: 0 0 var(--spacing-md) 0;
      line-height: 1.5;
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      background: var(--color-white);
      box-shadow: var(--shadow-sm);
    }

    #chatlog p:last-child {
      margin-bottom: 0;
    }

    .input-group {
      display: flex;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-sm);
    }

    #userInput {
      flex: 1;
      padding: var(--spacing-md) var(--spacing-lg);
      font-size: var(--font-size-base);
      border: 2px solid var(--color-light-gray);
      border-radius: var(--radius-full);
      font-family: var(--font-primary);
      transition: all var(--transition-base);
      background: var(--color-white);
      color: var(--color-navy);
      box-shadow: var(--shadow-sm);
    }

    #userInput:focus {
      outline: none;
      border-color: var(--color-teal);
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
    }

    #userInput::placeholder {
      color: var(--color-gray-light);
      font-weight: 400;
    }

    #sendButton {
      padding: var(--spacing-md) var(--spacing-xl);
      background: var(--gradient-primary);
      color: var(--color-white);
      border: none;
      border-radius: var(--radius-full);
      font-size: var(--font-size-base);
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-base);
      min-width: 100px;
      box-shadow: var(--shadow-colored);
      font-family: var(--font-primary);
    }

    #sendButton:hover {
      opacity: 0.9;
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    #sendButton:disabled {
      background: var(--color-gray-light);
      cursor: not-allowed;
      opacity: 0.6;
      transform: none;
      box-shadow: var(--shadow-sm);
    }

    .disclaimer {
      font-size: var(--font-size-xs);
      color: var(--color-gray);
      text-align: center;
      line-height: 1.4;
      margin-top: var(--spacing-sm);
      padding: var(--spacing-sm);
      background: var(--color-off-white);
      border-radius: var(--radius-md);
      border: 1px solid var(--color-light-gray);
      display: flex;
      align-items: flex-start;
      gap: var(--spacing-xs);
      flex-wrap: wrap;
    }

    .disclaimer-icon {
      color: var(--color-teal);
      flex-shrink: 0;
    }

    .disclaimer-main-text {
      flex: 1;
      min-width: 0;
    }

    .disclaimer-toggle {
      background: none;
      border: none;
      color: var(--color-gray);
      cursor: pointer;
      padding: 2px;
      border-radius: var(--radius-sm);
      transition: all var(--transition-base);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .disclaimer-toggle:hover {
      background: var(--color-light-gray);
      color: var(--color-teal);
    }

    .disclaimer-toggle.expanded {
      transform: rotate(180deg);
    }

    .disclaimer-expanded {
      width: 100%;
      margin-top: var(--spacing-xs);
      padding-top: var(--spacing-xs);
      border-top: 1px solid var(--color-light-gray);
      animation: slideDown 0.3s ease-out;
    }

    .disclaimer-link {
      color: var(--color-teal);
      text-decoration: none;
      font-weight: 500;
      transition: color var(--transition-base);
    }

    .disclaimer-link:hover {
      color: var(--color-teal-dark);
      text-decoration: underline;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .avatar {
      width: 28px;
      height: 28px;
      border-radius: var(--radius-full);
      vertical-align: middle;
      margin-right: var(--spacing-xs);
      object-fit: cover;
      border: 2px solid var(--color-light-gray);
      position: relative;
      display: inline-block;
    }

    /* Online indicator for message avatars */
    .avatar-container {
      position: relative;
      display: inline-block;
      vertical-align: middle;
      margin-right: var(--spacing-xs);
    }

    .avatar-container .online-indicator {
      position: absolute;
      bottom: -1px;
      right: -1px;
      width: 10px;
      height: 10px;
      background: #22c55e;
      border: 1px solid var(--color-white);
      border-radius: var(--radius-full);
      box-shadow: var(--shadow-sm);
    }

    .message-avatar {
      display: inline-block;
      width: 28px;
      height: 28px;
      border-radius: var(--radius-full);
      text-align: center;
      line-height: 24px;
      font-size: var(--font-size-xs);
      vertical-align: middle;
      margin-right: var(--spacing-xs);
      background: var(--color-light-gray);
      border: 2px solid var(--color-gray-light);
    }

    @media (max-width: 600px) {
      .container {
        padding: var(--spacing-sm) var(--spacing-lg);
      }

      .page-header h1 {
        font-size: var(--font-size-xl);
      }

      .page-header p {
        font-size: var(--font-size-xs);
      }

      .character-section,
      .chat-section {
        padding: var(--spacing-lg) var(--spacing-lg);
      }

      .character-avatar {
        width: 50px;
        height: 50px;
        font-size: var(--font-size-xl);
      }

      .character-info h2 {
        font-size: var(--font-size-base);
      }

      .character-info p {
        font-size: var(--font-size-xs);
      }

      #chatlog {
        height: 400px;
        padding: var(--spacing-md);
        font-size: var(--font-size-xs);
      }

      .input-group {
        flex-direction: column;
        gap: var(--spacing-sm);
      }

      #sendButton {
        width: 100%;
        padding: var(--spacing-sm) var(--spacing-lg);
      }

      .disclaimer {
        font-size: calc(var(--font-size-xs) * 0.9);
        padding: var(--spacing-xs) var(--spacing-sm);
      }
    }

    /* Typing indicator styles */
    .typing-indicator {
      display: flex;
      align-items: center;
      padding: var(--spacing-sm) var(--spacing-md);
      margin: 0 0 var(--spacing-md) 0;
      background: var(--color-white);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
      font-style: italic;
      color: var(--color-gray);
      animation: fadeIn 0.3s ease-in;
    }

    .typing-indicator .avatar {
      margin-right: var(--spacing-xs);
    }

    .typing-indicator .message-avatar {
      margin-right: var(--spacing-xs);
    }

    .typing-dots {
      display: inline-flex;
      align-items: center;
      margin-left: var(--spacing-xs);
    }

    .typing-dots span {
      height: 4px;
      width: 4px;
      background: var(--color-gray);
      border-radius: 50%;
      display: inline-block;
      margin: 0 1px;
      animation: typingDots 1.4s infinite ease-in-out;
    }

    .typing-dots span:nth-child(1) {
      animation-delay: -0.32s;
    }

    .typing-dots span:nth-child(2) {
      animation-delay: -0.16s;
    }

    @keyframes typingDots {
      0%, 80%, 100% {
        transform: scale(0.8);
        opacity: 0.5;
      }
      40% {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* ===== FOOTER ===== */
    .footer {
      background: var(--color-white);
      border-top: 1px solid var(--color-light-gray);
      padding: var(--spacing-xl) var(--spacing-lg);
      margin-top: var(--spacing-3xl);
    }

    .footer-content {
      max-width: 1400px;
      margin: 0 auto;
      text-align: center;
    }

    .footer-links {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: var(--spacing-xl);
      margin-bottom: var(--spacing-md);
    }

    .footer-link {
      color: var(--color-gray);
      text-decoration: none;
      font-size: var(--font-size-sm);
      font-weight: 500;
      transition: color var(--transition-base);
    }

    .footer-link:hover {
      color: var(--color-teal);
    }

    .footer-separator {
      color: var(--color-gray-light);
      font-size: var(--font-size-sm);
    }

    .footer-copyright {
      color: var(--color-gray-light);
      font-size: var(--font-size-xs);
    }

    /* Mobile footer adjustments */
    @media (max-width: 768px) {
      .footer-links {
        flex-direction: column;
        gap: var(--spacing-md);
      }

      .footer-separator {
        display: none;
      }
    }

    /* Accessibility improvements */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      
      .typing-dots span {
        animation: none;
        opacity: 0.7;
      }

      .online-indicator {
        animation: none !important;
      }
    }

    /* ===== CUSTOM NOTIFICATION SYSTEM ===== */
    .notification-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(30, 41, 59, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: var(--z-modal);
      display: none;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all var(--transition-base);
    }

    .notification-overlay.active {
      display: flex;
      opacity: 1;
    }

    .notification-modal {
      background: var(--color-white);
      border-radius: var(--radius-xl);
      padding: var(--spacing-2xl);
      box-shadow: var(--shadow-xl);
      max-width: 90vw;
      width: 100%;
      max-width: 400px;
      transform: scale(0.9) translateY(20px);
      transition: all var(--transition-base);
      text-align: center;
    }

    .notification-overlay.active .notification-modal {
      transform: scale(1) translateY(0);
    }

    .notification-icon {
      font-size: var(--font-size-4xl);
      margin-bottom: var(--spacing-lg);
      display: block;
    }

    .notification-icon.success {
      color: var(--color-teal);
    }

    .notification-icon.error {
      color: var(--color-coral);
    }

    .notification-icon.warning {
      color: #f59e0b;
    }

    .notification-icon.info {
      color: #3b82f6;
    }

    .notification-title {
      font-family: var(--font-secondary);
      font-size: var(--font-size-xl);
      font-weight: 700;
      color: var(--color-navy);
      margin-bottom: var(--spacing-md);
    }

    .notification-message {
      color: var(--color-gray-dark);
      font-size: var(--font-size-base);
      line-height: 1.6;
      margin-bottom: var(--spacing-xl);
    }

    .notification-buttons {
      display: flex;
      gap: var(--spacing-md);
      justify-content: center;
    }

    .notification-btn {
      padding: var(--spacing-sm) var(--spacing-lg);
      border: none;
      border-radius: var(--radius-md);
      font-size: var(--font-size-sm);
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-base);
      min-width: 100px;
      font-family: var(--font-primary);
    }

    .notification-btn.primary {
      background: var(--gradient-primary);
      color: var(--color-white);
      box-shadow: var(--shadow-colored);
    }

    .notification-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .notification-btn.secondary {
      background: var(--color-white);
      color: var(--color-navy);
      border: 2px solid var(--color-light-gray);
    }

    .notification-btn.secondary:hover {
      border-color: var(--color-teal);
      color: var(--color-teal);
    }

    /* Mobile adjustments */
    @media (max-width: 768px) {
      .notification-modal {
        margin: var(--spacing-lg);
        padding: var(--spacing-xl);
      }

      .notification-buttons {
        flex-direction: column;
      }

      .notification-btn {
        width: 100%;
      }
    }

/* ===== UPGRADE OVERLAY STYLES ===== */
.upgrade-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(30, 41, 59, 0.95);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  z-index: 999999999;
  display: none;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: all var(--transition-base);
}

.upgrade-overlay.active {
  display: flex;
  opacity: 1;
}

.upgrade-modal {
  background: var(--color-white);
  border-radius: var(--radius-xl);
  padding: var(--spacing-3xl);
  box-shadow: var(--shadow-xl);
  max-width: 90vw;
  width: 100%;
  max-width: 480px;
  transform: scale(0.9) translateY(20px);
  transition: all var(--transition-base);
  text-align: center;
  position: relative;
  overflow: hidden;
}

.upgrade-overlay.active .upgrade-modal {
  transform: scale(1) translateY(0);
}

.upgrade-modal::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: var(--gradient-primary);
}

.upgrade-header {
  margin-bottom: var(--spacing-xl);
}

.upgrade-icon {
  font-size: var(--font-size-4xl);
  margin-bottom: var(--spacing-md);
  display: block;
  filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1));
}

.upgrade-title {
  font-family: var(--font-secondary);
  font-size: var(--font-size-2xl);
  font-weight: 700;
  color: var(--color-navy);
  margin: 0 0 var(--spacing-sm) 0;
  letter-spacing: -0.01em;
}

.upgrade-subtitle {
  color: var(--color-gray);
  font-size: var(--font-size-base);
  margin: 0 0 var(--spacing-xl) 0;
  line-height: 1.5;
}

.upgrade-benefits {
  background: var(--color-off-white);
  border-radius: var(--radius-lg);
  padding: var(--spacing-xl);
  margin-bottom: var(--spacing-xl);
  text-align: left;
}

.benefit-item {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-md);
  font-size: var(--font-size-sm);
  font-weight: 500;
  color: var(--color-navy);
}

.benefit-item:last-child {
  margin-bottom: 0;
}

.benefit-icon {
  width: 24px;
  height: 24px;
  background: var(--gradient-primary);
  border-radius: var(--radius-full);
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: var(--spacing-sm);
  flex-shrink: 0;
  font-size: var(--font-size-xs);
  color: var(--color-white);
}

.benefit-text {
  flex: 1;
  line-height: 1.4;
}

.upgrade-pricing {
  margin-bottom: var(--spacing-xl);
}

.price-tag {
  display: inline-flex;
  align-items: baseline;
  gap: 2px;
  background: var(--gradient-primary);
  color: var(--color-white);
  padding: var(--spacing-sm) var(--spacing-lg);
  border-radius: var(--radius-full);
  font-weight: 700;
  box-shadow: var(--shadow-colored);
}

.currency {
  font-size: var(--font-size-sm);
}

.amount {
  font-size: var(--font-size-2xl);
  font-family: var(--font-secondary);
}

.period {
  font-size: var(--font-size-sm);
  opacity: 0.9;
}

.upgrade-buttons {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

.upgrade-btn {
  padding: var(--spacing-md) var(--spacing-xl);
  border: none;
  border-radius: var(--radius-lg);
  font-size: var(--font-size-base);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-base);
  font-family: var(--font-primary);
  position: relative;
  overflow: hidden;
}

.upgrade-btn.primary {
  background: var(--gradient-primary);
  color: var(--color-white);
  box-shadow: var(--shadow-colored);
}

.upgrade-btn.primary:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-xl);
}

.upgrade-btn.primary:disabled {
  opacity: 0.7;
  cursor: not-allowed;
  transform: none;
}

.upgrade-btn.secondary {
  background: var(--color-white);
  color: var(--color-gray);
  border: 2px solid var(--color-light-gray);
}

.upgrade-btn.secondary:hover {
  border-color: var(--color-teal);
  color: var(--color-teal);
  transform: translateY(-1px);
}

/* Voice play button in chat */
    .voice-play-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      margin-left: 8px;
      border-radius: 50%;
      transition: background-color 0.2s;
      font-size: 16px;
      color: var(--color-teal);
    }

    .voice-play-btn:hover {
      background-color: rgba(20, 184, 166, 0.1);
      transform: scale(1.1);
    }

    .voice-play-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .voice-play-btn.playing {
      color: var(--color-coral);
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .voice-play-btn.loading {
      color: var(--color-gray);
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

@media (max-width: 768px) {
  .upgrade-modal {
    margin: var(--spacing-lg);
    padding: var(--spacing-2xl);
    max-width: none;
  }
  
  .upgrade-title {
    font-size: var(--font-size-xl);
  }
}

  </style>

  <!-- Netlify Identity Widget -->
  <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>

<!-- Stripe.js for upgrade functionality -->
<script src="https://js.stripe.com/v3/"></script>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const netlifyIdentity = window.netlifyIdentity;
      netlifyIdentity.init();

      netlifyIdentity.on("init", (user) => {
        if (user) {
          handleLogin(user);
        }
        // Update login buttons immediately after init
        updateLoginButton();
      });

      netlifyIdentity.on("login", (user) => {
        handleLogin(user);
        netlifyIdentity.close();
        // Check for redirect URL after successful login
        handlePostLoginRedirect();
      });

      netlifyIdentity.on("logout", () => {
        clearLocalAuth();
        window.location.href = "/";
      });
    });

    async function handleLogin(user) {
      const email = user.email;
      const uid   = user.id;
      const token = user.token.access_token;

      localStorage.setItem("user_email", email);
      localStorage.setItem("user_token", token);
      localStorage.setItem("user_uid", uid);
      window.isRegistered = true;

      console.log("🔍 DEBUG: handleLogin → verstuur Webhook1:", {
        user_email: email,
        user_uid: uid,
        user_token: token
      });

      try {
        const res = await fetch(
          "https://hook.eu2.make.com/03ug6qzucda4ksrkcc06nu3bu3vetj15",
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              user_email: email,
              user_uid: uid,
              user_token: token
            })
          }
        );

        console.log("🔍 DEBUG: Response status:", res.status, res.statusText);

        if (!res.ok) {
          console.error("❌ Registration webhook failed:", res.status, res.statusText);
          return;
        }

        const data = await res.json();
        console.log("🔍 DEBUG: Registration response:", data);
        console.log("🔍 DEBUG: All response keys:", Object.keys(data));

        // Zoek user_id in verschillende mogelijke velden - EXPLICIT LOGGING
        console.log("🔍 DEBUG: data.user_id =", data.user_id);
        console.log("🔍 DEBUG: data.User_ID =", data.User_ID);
        console.log("🔍 DEBUG: data.id =", data.id);
        console.log("🔍 DEBUG: data.record_id =", data.record_id);

        const userId = data.user_id || data.User_ID || data.id || data.record_id;
        console.log("🔍 DEBUG: Final userId =", userId, "(type:", typeof userId, ")");
        
        if (userId && userId !== "" && userId !== null && userId !== "null") {
          const userIdString = String(userId);
          localStorage.setItem("user_id", userIdString);
          console.log("✅ DEBUG: Successfully saved user_id:", userIdString);
          
          // Verify localStorage
          const savedUserId = localStorage.getItem("user_id");
          console.log("🔍 DEBUG: Verified localStorage user_id:", savedUserId);
          
          // Call fetchHistory if conditions are met
          if (currentCharacter && 
              (document.readyState === "interactive" || document.readyState === "complete")) {
            console.log("🔄 DEBUG: Calling fetchHistory after user_id is saved...");
            setTimeout(() => {
              fetchHistory();
            }, 500); // Small delay to ensure localStorage is saved
          }
        } else {
          console.warn("⚠️ DEBUG: No valid user_id found in response. UserId value:", userId);
          console.warn("⚠️ DEBUG: Full response data:", JSON.stringify(data, null, 2));
        }
      } catch (err) {
        console.error("❌ DEBUG: Error in registration-webhook call:", err);
      }

      updateLoginButton();
    }

    function handlePostLoginRedirect() {
      // Get the stored redirect URL
      const redirectUrl = localStorage.getItem('login_redirect_url');
      
      if (redirectUrl) {
        // Clear the stored redirect URL
        localStorage.removeItem('login_redirect_url');
        
        // Redirect immediately without showing profile page
        setTimeout(() => {
          window.location.href = redirectUrl;
        }, 100); // Very short delay to ensure login is fully processed
      }
    }

    function clearLocalAuth() {
      localStorage.removeItem("user_email");
      localStorage.removeItem("user_token");
      localStorage.removeItem("user_uid");
      localStorage.removeItem("user_id");
      window.isRegistered = false;
    }

    function isMobileDevice() {
      return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
  </script>
</head>

<body>
  <!-- Custom Notification System -->
  <div class="notification-overlay" id="notificationOverlay">
    <div class="notification-modal">
      <span class="notification-icon" id="notificationIcon">✓</span>
      <h3 class="notification-title" id="notificationTitle">Success</h3>
      <p class="notification-message" id="notificationMessage">Operation completed successfully!</p>
      <div class="notification-buttons" id="notificationButtons">
        <button class="notification-btn primary" id="notificationOkBtn">OK</button>
      </div>
    </div>
  </div>

  <!-- Header -->
  <header class="header" role="banner">
    <div class="header-container">
      <div class="header-content">
        <!-- Logo -->
        <a href="index.html" class="logo" aria-label="Narrin AI Home">Narrin AI</a>

        <!-- Desktop Navigation Center -->
        <nav class="nav-center" role="navigation" aria-label="Main navigation">
          <!-- USPs - All visible on desktop -->
          <div class="nav-usps" aria-label="Key features">
            <div class="usp-item">
              <span class="usp-icon" aria-hidden="true">🔒</span>
              <span>100% Safe</span>
            </div>
            <div class="usp-item">
              <span class="usp-icon" aria-hidden="true">🧠</span>
              <span>Character Memory</span>
            </div>
            <div class="usp-item">
              <span class="usp-icon" aria-hidden="true">🔐</span>
              <span>Private Data</span>
            </div>
          </div>

          <!-- Search Bar - Always visible on desktop -->
          <form class="nav-search" role="search">
            <input 
              type="search" 
              class="nav-search-input" 
              placeholder="Find your companion..." 
              aria-label="Search characters"
            />
            <button type="submit" class="search-submit" aria-label="Submit search">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
              </svg>
            </button>
          </form>
        </nav>

        <!-- Desktop Navigation Links -->
        <nav class="nav-links" role="navigation" aria-label="Secondary navigation">
          <a href="index.html" class="nav-link">Characters</a>
          <a href="chat-overview.html" class="nav-link">Chats</a>
          <a href="profile.html" class="nav-link" id="loginBtn">Login/Register</a>
          <a href="create-character.html" class="btn btn-primary">✨ Create Character</a>
        </nav>

        <!-- Mobile Navigation Container -->
        <div class="mobile-nav-container">
          <!-- Mobile Chat Button -->
          <a 
            href="chat-overview.html" 
            class="mobile-chat-btn"
            aria-label="Go to chats"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
          </a>

          <!-- Mobile Search Button -->
          <button 
            class="mobile-search-btn" 
            id="mobileSearchBtn"
            aria-label="Open search"
            aria-expanded="false"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="m21 21-4.35-4.35"></path>
            </svg>
          </button>

          <!-- Mobile Hamburger Menu -->
          <button
            class="mobile-menu-btn"
            id="mobileMenuBtn"
            aria-label="Open navigation menu"
            aria-expanded="false"
          >
            <div class="hamburger">
              <span></span>
              <span></span>
              <span></span>
            </div>
          </button>
        </div>
      </div>
    </div>

    <!-- Mobile Search Overlay -->
    <div class="mobile-search-overlay" id="mobileSearchOverlay">
      <form class="mobile-search-form" role="search">
        <input 
          type="search" 
          class="mobile-search-input" 
          placeholder="Find your companion..." 
          aria-label="Search characters"
          id="mobileSearchInput"
        />
        <button type="submit" class="btn btn-primary" aria-label="Submit search">
          Search
        </button>
      </form>
    </div>
  </header>

  <!-- Mobile Menu Overlay -->
  <div class="mobile-menu-overlay" id="mobileMenuOverlay">
    <div class="mobile-menu-content">
      <div class="mobile-menu-header">
        <div class="mobile-menu-logo">Narrin AI</div>
        <div class="mobile-menu-subtitle">AI Character Chat</div>
      </div>
      <nav class="mobile-menu-nav" role="navigation" aria-label="Mobile navigation">
        <a href="index.html" class="mobile-menu-link">
          <span class="mobile-menu-link-icon">🏠</span>
          Characters
        </a>
        <a href="chat-overview.html" class="mobile-menu-link">
          <span class="mobile-menu-link-icon">💬</span>
          Chats
        </a>
        <a href="profile.html" class="mobile-menu-link" id="mobileLoginBtn">
          <span class="mobile-menu-link-icon">👤</span>
          Login/Register
        </a>
        <a href="create-character.html" class="mobile-menu-link btn-primary">
          <span class="mobile-menu-link-icon">✨</span>
          Create Character
        </a>
      </nav>
    </div>
  </div>

  <div class="container">
    <div id="loadingState" class="loading-state">
      <h3>Preparing your connection...</h3>
      <p>We're creating a welcoming space for your conversation to begin.</p>
    </div>

    <div id="errorState" class="error-state" style="display: none;">
      <h3>We're here to help</h3>
      <p>It seems we can't find the character you're looking for. Don't worry - there are many other supportive companions waiting to connect with you.</p>
      <a href="create-character.html">Create a new companion</a> or <a href="/">explore other characters</a>
    </div>

    <div id="chatInterface" style="display: none;">
      <div class="page-header">
        <h1>Chat With Your AI Companion</h1>
        <p>Every conversation unlocks new possibilities on your path to becoming who you're meant to be.</p>
      </div>

      <div class="character-section">
        <div class="character-header" id="characterHeader">
          <div class="character-avatar" id="characterAvatar">👤</div>
          <div class="character-info">
            <h2 id="characterName">Connecting...</h2>
            <p id="characterTitle"></p>
          </div>
        </div>
      </div>

      <div class="chat-section">
        <div id="chatlog"></div>
        <div class="input-group">
          <input id="userInput" type="text" placeholder="Share what's on your mind..." />
          <button onclick="handleSendClick(event)" id="sendButton">Send</button>
        </div>
        <div class="disclaimer">
          <span class="disclaimer-icon">ℹ️</span>
          <span class="disclaimer-main-text">Your AI companion is here to listen and support you. While responses are AI-generated, your feelings and experiences are always valid and respected.</span>
          <button class="disclaimer-toggle" id="disclaimerToggle" aria-label="Show more information">
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M3 4.5L6 7.5L9 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <div class="disclaimer-expanded" id="disclaimerExpanded" style="display: none;">
            This is a supportive space for personal reflection and conversation. For professional guidance on important matters, please consult qualified experts.
            We're committed to providing a safe environment while you explore your thoughts and feelings.
            Read our <a href="privacy-policy.html" class="disclaimer-link">privacy policy</a> and <a href="terms-and-conditions.html" class="disclaimer-link">terms and conditions</a> here.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Navigation and Chat Scripts -->
  <script>
    // ===== CUSTOM NOTIFICATION SYSTEM =====
    function showNotification(type, title, message, buttons = null) {
      const overlay = document.getElementById('notificationOverlay');
      const icon = document.getElementById('notificationIcon');
      const titleEl = document.getElementById('notificationTitle');
      const messageEl = document.getElementById('notificationMessage');
      const buttonsEl = document.getElementById('notificationButtons');
      
      // Set icon based on type
      const icons = {
        success: '✅',
        error: '❌',
        warning: '⚠️',
        info: 'ℹ️',
        question: '❓'
      };
      
      icon.textContent = icons[type] || icons.info;
      icon.className = `notification-icon ${type}`;
      titleEl.textContent = title;
      messageEl.textContent = message;
      
      // Set up buttons
      if (buttons) {
        buttonsEl.innerHTML = '';
        buttons.forEach(button => {
          const btn = document.createElement('button');
          btn.className = `notification-btn ${button.type || 'secondary'}`;
          btn.textContent = button.text;
          btn.onclick = () => {
            hideNotification();
            if (button.callback) button.callback();
          };
          buttonsEl.appendChild(btn);
        });
      } else {
        // Default OK button
        buttonsEl.innerHTML = '<button class="notification-btn primary" onclick="hideNotification()">OK</button>';
      }
      
      // Show notification
      overlay.classList.add('active');
      document.body.style.overflow = 'hidden';
    }
    
    function hideNotification() {
      const overlay = document.getElementById('notificationOverlay');
      overlay.classList.remove('active');
      document.body.style.overflow = '';
    }
    
    // Custom alert replacement
    function customAlert(message, title = 'We\'re Here for You') {
      showNotification('info', title, message);
    }
    
    // Success notification
    function showSuccess(message, title = 'Wonderful!') {
      showNotification('success', title, message);
    }
    
    // Error notification
    function showError(message, title = 'We\'re Here to Help') {
      showNotification('error', title, message);
    }
    
    // Warning notification
    function showWarning(message, title = 'Just a Moment') {
      showNotification('warning', title, message);
    }

    // ===== NAVIGATION FUNCTIONALITY =====
    
    // Mobile Search Elements
    const mobileSearchBtn = document.getElementById('mobileSearchBtn');
    const mobileSearchOverlay = document.getElementById('mobileSearchOverlay');
    const mobileSearchInput = document.getElementById('mobileSearchInput');
    
    // Mobile Menu Elements
    const mobileMenuBtn = document.getElementById('mobileMenuBtn');
    const mobileMenuOverlay = document.getElementById('mobileMenuOverlay');
    
    // USP Carousel Elements
    const uspTrack = document.getElementById('uspTrack');
    let currentUspIndex = 0;
    let uspInterval;

    // ===== MOBILE SEARCH FUNCTIONALITY =====
    function toggleMobileSearch() {
      const isActive = mobileSearchOverlay.classList.contains('active');
      
      if (isActive) {
        mobileSearchOverlay.classList.remove('active');
        mobileSearchBtn.setAttribute('aria-expanded', 'false');
      } else {
        // Close mobile menu if open
        closeMobileMenu();
        
        mobileSearchOverlay.classList.add('active');
        mobileSearchBtn.setAttribute('aria-expanded', 'true');
        mobileSearchInput.focus();
      }
    }

    mobileSearchBtn?.addEventListener('click', toggleMobileSearch);

    // ===== MOBILE MENU FUNCTIONALITY =====
    function toggleMobileMenu() {
      const isActive = mobileMenuOverlay.classList.contains('active');
      
      if (isActive) {
        closeMobileMenu();
      } else {
        openMobileMenu();
      }
    }

    function openMobileMenu() {
      // Close search overlay if open
      if (mobileSearchOverlay.classList.contains('active')) {
        mobileSearchOverlay.classList.remove('active');
        mobileSearchBtn.setAttribute('aria-expanded', 'false');
      }
      
      mobileMenuOverlay.classList.add('active');
      mobileMenuBtn.classList.add('active');
      mobileMenuBtn.setAttribute('aria-expanded', 'true');
      
      // Prevent body scroll
      document.body.style.overflow = 'hidden';
    }

    function closeMobileMenu() {
      mobileMenuOverlay.classList.remove('active');
      mobileMenuBtn.classList.remove('active');
      mobileMenuBtn.setAttribute('aria-expanded', 'false');
      
      // Restore body scroll
      document.body.style.overflow = '';
    }

    mobileMenuBtn?.addEventListener('click', toggleMobileMenu);

    // Close menu when clicking on overlay background
    mobileMenuOverlay?.addEventListener('click', (e) => {
      if (e.target === mobileMenuOverlay) {
        closeMobileMenu();
      }
    });

    // Close menu when clicking on a menu item
    document.querySelectorAll('.mobile-menu-link').forEach(link => {
      link.addEventListener('click', closeMobileMenu);
    });

    // Close search and menu on outside click
    document.addEventListener('click', (e) => {
      // Close search overlay
      if (!mobileSearchOverlay?.contains(e.target) &&
          !mobileSearchBtn?.contains(e.target) &&
          mobileSearchOverlay?.classList.contains('active')) {
        mobileSearchOverlay.classList.remove('active');
        mobileSearchBtn.setAttribute('aria-expanded', 'false');
      }
    });

    // Close menu on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (mobileMenuOverlay.classList.contains('active')) {
          closeMobileMenu();
        }
        if (mobileSearchOverlay.classList.contains('active')) {
          mobileSearchOverlay.classList.remove('active');
          mobileSearchBtn.setAttribute('aria-expanded', 'false');
        }
      }
    });

    // ===== USP CAROUSEL FUNCTIONALITY =====
    function startUspCarousel() {
      if (window.innerWidth <= 768 && uspTrack) {
        uspInterval = setInterval(() => {
          currentUspIndex = (currentUspIndex + 1) % 3;
          uspTrack.style.transform = `translateY(-${currentUspIndex * 33.333}%)`;
        }, 3000);
      }
    }

    function stopUspCarousel() {
      if (uspInterval) {
        clearInterval(uspInterval);
        uspInterval = null;
      }
    }

    // Handle responsive behavior
    function handleResize() {
      if (window.innerWidth > 768) {
        stopUspCarousel();
        if (uspTrack) {
          uspTrack.style.transform = '';
        }
        if (mobileSearchOverlay?.classList.contains('active')) {
          mobileSearchOverlay.classList.remove('active');
          mobileSearchBtn?.setAttribute('aria-expanded', 'false');
        }
        if (mobileMenuOverlay?.classList.contains('active')) {
          closeMobileMenu();
        }
      } else {
        startUspCarousel();
      }
    }

    // Initialize on load
    window.addEventListener('load', () => {
      handleResize();
    });

    // Handle window resize
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(handleResize, 250);
    });

    // ===== SEARCH FUNCTIONALITY =====
    function handleSearch(searchTerm) {
      if (!searchTerm || !searchTerm.trim()) {
        console.log('Empty search term, ignoring');
        return;
      }
      
      const trimmedTerm = searchTerm.trim();
      console.log('Redirecting to search results for:', trimmedTerm);
      window.location.href = `search-results.html?q=${encodeURIComponent(trimmedTerm)}`;
    }

    // Desktop search
    document.querySelector('.nav-search')?.addEventListener('submit', (e) => {
      e.preventDefault();
      const searchInput = e.target.querySelector('.nav-search-input');
      handleSearch(searchInput.value);
    });

    // Mobile search
    document.querySelector('.mobile-search-form')?.addEventListener('submit', (e) => {
      e.preventDefault();
      const searchInput = e.target.querySelector('.mobile-search-input');
      handleSearch(searchInput.value);
      toggleMobileSearch();
    });

    // ===== NETLIFY IDENTITY BUTTON UPDATES =====
    function updateLoginButton() {
      const loginBtn = document.getElementById('loginBtn');
      const mobileLoginBtn = document.getElementById('mobileLoginBtn');
      
      // Check both Netlify Identity and local storage for user info
      const netlifyUser = window.netlifyIdentity && window.netlifyIdentity.currentUser();
      const localEmail = localStorage.getItem("user_email");
      const localToken = localStorage.getItem("user_token");
      
      const isLoggedIn = netlifyUser || (localEmail && localToken);
      
      if (isLoggedIn) {
        // Always show "Profile" for logged in users instead of their name
        
        // Update desktop button
        if (loginBtn) {
          loginBtn.textContent = 'Profile';
          loginBtn.href = 'profile.html';
        }
        
        // Update mobile button
        if (mobileLoginBtn) {
          const icon = mobileLoginBtn.querySelector('.mobile-menu-link-icon');
          mobileLoginBtn.innerHTML = `${icon ? icon.outerHTML : '<span class="mobile-menu-link-icon">👤</span>'}Profile`;
          mobileLoginBtn.href = 'profile.html';
        }
      } else {
        // User is not logged in
        if (loginBtn) {
          loginBtn.textContent = 'Login/Register';
          loginBtn.href = 'profile.html';
        }
        if (mobileLoginBtn) {
          const icon = mobileLoginBtn.querySelector('.mobile-menu-link-icon');
          mobileLoginBtn.innerHTML = `${icon ? icon.outerHTML : '<span class="mobile-menu-link-icon">👤</span>'}Login/Register`;
          mobileLoginBtn.href = 'profile.html';
        }
      }
    }

    // Enhanced click handler for navigation links
    function setupNavigationClickHandlers() {
      const loginBtn = document.getElementById('loginBtn');
      const mobileLoginBtn = document.getElementById('mobileLoginBtn');
      
      // Desktop login button click handler
      if (loginBtn) {
        loginBtn.addEventListener('click', (e) => {
          e.preventDefault();
          
          const netlifyUser = window.netlifyIdentity && window.netlifyIdentity.currentUser();
          const localEmail = localStorage.getItem("user_email");
          const localToken = localStorage.getItem("user_token");
          const isLoggedIn = netlifyUser || (localEmail && localToken);
          
          if (isLoggedIn) {
            // User is logged in, go directly to profile page
            window.location.href = 'profile.html';
          } else {
            // User not logged in, store current page for redirect and open login
            localStorage.setItem('login_redirect_url', window.location.href);
            openLogin();
          }
        });
      }
      
      // Mobile login button click handler
      if (mobileLoginBtn) {
        mobileLoginBtn.addEventListener('click', (e) => {
          e.preventDefault();
          
          const netlifyUser = window.netlifyIdentity && window.netlifyIdentity.currentUser();
          const localEmail = localStorage.getItem("user_email");
          const localToken = localStorage.getItem("user_token");
          const isLoggedIn = netlifyUser || (localEmail && localToken);
          
          if (isLoggedIn) {
            // User is logged in, go directly to profile page
            window.location.href = 'profile.html';
          } else {
            // User not logged in, store current page for redirect and open login
            localStorage.setItem('login_redirect_url', window.location.href);
            openLogin();
          }
          
          // Close mobile menu after click
          closeMobileMenu();
        });
      }
    }

    // Function to open login modal
    function openLogin() {
      if (window.netlifyIdentity) {
        window.netlifyIdentity.open('login');
      } else {
        // Fallback if Netlify Identity is not available
        window.location.href = 'profile.html';
      }
    }

    // Initialize login button on page load
document.addEventListener('DOMContentLoaded', () => {
  // Check upgrade status
  checkUpgradeStatus();
  
  // Update immediately on page load
  updateLoginButton();
      
      // Set up click handlers
      setupNavigationClickHandlers();
      
      if (window.netlifyIdentity) {
        window.netlifyIdentity.on('init', user => {
          updateLoginButton();
        });

        window.netlifyIdentity.on('login', user => {
          updateLoginButton();
          window.netlifyIdentity.close();
        });

        window.netlifyIdentity.on('logout', () => {
          updateLoginButton();
        });
      }
    });

    // ===== CHARACTER LOADING & SETUP =====
    let currentCharacter = null;
    let characterSlug = null;
    
    // ===== VOICE SYSTEM (VEILIG VIA NETLIFY FUNCTIONS) =====
    let currentAudio = null;
    let isPlayingAudio = false;

    // Voice ID validatie en fallback
    function validateAndFixVoiceId(voiceId) {
      // Bekende geldige voice IDs uit de voice library
      const validVoiceIds = [
        'iP95p4HMsOdaJ6J8s72v', 'TxGEqnHWrfWFTfGW9XjX', 'VR6AewLTigWG4xSOukaG', 
        'pqHfZKP75CvOlQylNhV4', 'yoZ06aMxZJJ28mfd3POQ', 'EXAVITQu4vr4xnSDxMaL',
        'XrExE9yKIg1WjnnlVkGX', 'oWAxZDx7w5VEj9dCyTzz', 'pFZP5JQG7iQjIQuC4Bku',
        'XB0fDUnXU5powFXDhCwa', 'onwK4e9ZLuTAKqWW03F9', 'fvcBHKa2lxguQE5lB4uV',
        'p3yi6sku4VQJg3uH6i6D', 'W8ouBcjTunaMJLYU2BvB', 'SyTRiCoyqTeFEk9z5HVW',
        'wdGYtWKVlLmwTxGswfYd', 'SAhaRsW91OuPlKeINYop', 'by3rQdWs4XjziQwJ2sTL',
        'qEN0DupmmmaueYJ8Eaz8', '21m00Tcm4TlvDq8ikWAM', 'pNInz6ObpgDQGcFmaJgB',
        'AZnzlk1XvdvUeBnXmlld', 'CYw3kZ02Hs0563khs1Fj', 'D38z5RcWu1voky8WS1ja'
      ];
      
      // Bekende ongeldige voice IDs die vervangen moeten worden
      const invalidVoiceIds = {
        'uH01NDVLLmf6SaxfTd': '21m00Tcm4TlvDq8ikWAM' // Rachel - standaard ElevenLabs voice
      };
      
      // Check voor bekende ongeldige IDs
      if (invalidVoiceIds[voiceId]) {
        console.log(`🔄 Replacing invalid voice ID ${voiceId} with ${invalidVoiceIds[voiceId]}`);
        return invalidVoiceIds[voiceId];
      }
      
      // Check of voice ID geldig format heeft (ElevenLabs voice IDs zijn alfanumeriek)
      const validFormat = /^[a-zA-Z0-9]{20,22}$/;
      if (!voiceId || voiceId === null || voiceId === 'null' || typeof voiceId !== 'string' || !validFormat.test(voiceId)) {
        console.log(`🔄 Invalid voice ID format: "${voiceId}", using fallback`);
        return null; // Return null instead of fallback to disable TTS
      }
      
      // Als voice ID niet bekend is, return null to disable TTS
      if (!validVoiceIds.includes(voiceId)) {
        console.log(`⚠️ Unknown voice ID: ${voiceId}, disabling TTS`);
        return null; // Return null to disable TTS completely
      }
      
      // Return original als het valid lijkt
      return voiceId;
    }

    // VEILIGE TTS functie via Netlify Function
    window.generateSpeech = async function(text, voiceId) {
      try {
        // Valideer en corrigeer voice ID indien nodig
        const validVoiceId = validateAndFixVoiceId(voiceId);
        console.log('📢 Calling TTS with:', { text: text.substring(0, 50) + '...', original: voiceId, validated: validVoiceId });
        
        // If voice ID is invalid, throw error
        if (!validVoiceId) {
          throw new Error('No valid voice ID available for this character');
        }
        
        const response = await fetch('/.netlify/functions/tts-simple', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text: text,
            voice_id: validVoiceId
          })
        });
        
        console.log('📢 TTS response:', response.status, response.statusText);

        if (!response.ok) {
          // Try to get more detailed error information
          let errorDetails = '';
          try {
            const errorData = await response.json();
            errorDetails = errorData.details || errorData.error || '';
            console.error('❌ TTS API Error Details:', errorData);
          } catch (e) {
            errorDetails = await response.text();
          }
          throw new Error(`TTS request failed: ${response.status} - ${errorDetails}`);
        }

        const data = await response.json();
        
        if (!data.success) {
          console.error('❌ TTS API returned success=false:', data);
          throw new Error(data.error || 'TTS generation failed');
        }

        // Convert base64 to blob
        const audioBytes = atob(data.audio);
        const audioArray = new Uint8Array(audioBytes.length);
        for (let i = 0; i < audioBytes.length; i++) {
          audioArray[i] = audioBytes.charCodeAt(i);
        }
        
        return new Blob([audioArray], { type: 'audio/mpeg' });

      } catch (error) {
        console.error('TTS Error:', error);
        throw error;
      }
    }

    // Voice cache voor snellere playback
    const voiceCache = new Map();
    
    // Manual voice playback met caching en loading indicator
    window.playMessageVoice = async function(text, voiceId, buttonElement) {
      try {
        // Check if this button is currently playing and should be paused
        if (buttonElement.classList.contains('playing') && currentAudio) {
          console.log('⏸️ Pausing current audio...');
          currentAudio.pause();
          currentAudio = null;
          buttonElement.classList.remove('playing');
          buttonElement.textContent = '▶️';
          buttonElement.disabled = false;
          return; // Early return to pause instead of restart
        }
        
        // Validate text length first (max 500 characters for TTS)
        if (!text || text.length === 0) {
          throw new Error('No text to convert to speech');
        }
        
        if (text.length > 500) {
          console.warn(`⚠️ Text too long for TTS (${text.length} chars), truncating to 500`);
          text = text.substring(0, 497) + '...';
        }
        
        // Stop any other audio if playing
        if (currentAudio) {
          currentAudio.pause();
          currentAudio = null;
          document.querySelectorAll('.voice-play-btn').forEach(btn => {
            btn.classList.remove('playing');
            btn.textContent = '▶️';
          });
        }
        
        // Toon loading indicator
        buttonElement.classList.add('loading');
        buttonElement.textContent = '⏳';
        buttonElement.disabled = true;
        
        // Check cache eerst
        const cacheKey = `${voiceId}_${text.substring(0, 100)}`;
        let audioBlob;
        
        if (voiceCache.has(cacheKey)) {
          console.log('🎵 Using cached audio');
          audioBlob = voiceCache.get(cacheKey);
        } else {
          console.log('🎤 Generating new audio...');
          audioBlob = await generateSpeech(text, voiceId);
          // Cache de audio (max 50 items)
          if (voiceCache.size >= 50) {
            const firstKey = voiceCache.keys().next().value;
            voiceCache.delete(firstKey);
          }
          voiceCache.set(cacheKey, audioBlob);
        }
        
        // Verander naar play state
        buttonElement.classList.remove('loading');
        buttonElement.classList.add('playing');
        buttonElement.textContent = '⏸️';
        buttonElement.disabled = false;
        const audioUrl = URL.createObjectURL(audioBlob);
        currentAudio = new Audio(audioUrl);
        
        currentAudio.addEventListener('ended', () => {
          URL.revokeObjectURL(audioUrl);
          currentAudio = null;
          buttonElement.classList.remove('playing', 'loading');
          buttonElement.textContent = '▶️';
          buttonElement.disabled = false;
        });
        
        currentAudio.addEventListener('pause', () => {
          buttonElement.classList.remove('playing', 'loading');
          buttonElement.textContent = '▶️';
          buttonElement.disabled = false;
        });
        
        await currentAudio.play();
        
      } catch (error) {
        console.error('Voice playback error:', error);
        buttonElement.classList.remove('playing', 'loading');
        buttonElement.textContent = '▶️';
        buttonElement.disabled = false;
        
        // Show more specific error messages
        if (error.message.includes('TTS service not configured')) {
          showError('Voice service is not configured. Please contact support.');
        } else if (error.message.includes('408') || error.message.includes('timeout')) {
          showError('Voice service timed out. Please try again.');
        } else if (error.message.includes('400')) {
          showError('Invalid voice configuration. Please try refreshing the page.');
          console.error('❌ Voice ID issue - Current character voice_id:', currentCharacter?.voice_id);
        } else if (error.message.includes('500')) {
          showError('Voice service error. Please try again later.');
        } else {
          showError('Could not play voice: ' + (error.message || 'Unknown error'));
        }
      }
    }

    // Fade-in effect voor berichten
    function typewriterWithVoice(element, text, voiceId = null, speed = 8) {
      element.textContent = text;
      element.style.opacity = '0';
      element.style.transition = 'opacity 0.8s ease-in';
      
      // Fade in the text
      setTimeout(() => {
        element.style.opacity = '1';
      }, 100);
    }
    
    // NIEUWE WEBHOOK URL
    const newWebhookUrl = "https://hook.eu2.make.com/36bygx4a2y4bkl97wkdjdmtn3o9ygjms";

// ===== MEMORY SYSTEM VIA NETLIFY FUNCTION (zoals category.html) =====
// Memory retrieval via Netlify function - same pattern as character loading
// ===== MEMORY SYSTEM VIA NETLIFY FUNCTION (zoals category.html) =====
// Memory retrieval via Netlify function - same pattern as character loading
async function getRelevantMemories(userId, characterId, currentMessage) {
    console.log("🧠 DEBUG: Starting memory retrieval...");
    console.log("🔍 Parameters:", { userId, characterId, currentMessage: currentMessage?.substring(0, 50) });
    
    try {
        // Test eerst de Netlify function
        const functionUrl = '/.netlify/functions/memory';
        console.log('📡 Testing memory function URL:', functionUrl);
        
        const requestData = {
            action: 'get_memories',
            user_id: userId,
            character_id: characterId,
            character_slug: characterId,
            current_message: currentMessage,
            min_importance: 3,
            max_results: 5
        };
        
        console.log('📤 Memory request data:', requestData);
        
        const response = await fetch(functionUrl, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(requestData)
        });
        
        console.log('📨 Memory function response status:', response.status);
        console.log('📨 Memory function response ok:', response.ok);
        
        const responseText = await response.text();
        console.log('📄 Memory function raw response:', responseText);
        
        if (!response.ok) {
            console.log('❌ Memory function failed, trying direct fallback...');
            return await getMemoriesDirectFallback(userId, characterId);
        }
        
        const data = JSON.parse(responseText);
        console.log('✅ Memory function parsed data:', data);
        
        if (data.success && data.memories && Array.isArray(data.memories)) {
            console.log(`✅ Found ${data.memories.length} memories via function`);
            return data.memories;
        } else {
            console.log('⚠️ Function returned success=false or no memories, trying fallback...');
            return await getMemoriesDirectFallback(userId, characterId);
        }
        
    } catch (error) {
        console.error('❌ Memory function error:', error);
        console.log('🔄 Falling back to direct method...');
        return await getMemoriesDirectFallback(userId, characterId);
    }
}

// FALLBACK: Direct ophalen van memories uit Airtable
async function getMemoriesDirectFallback(userId, characterId) {
    console.log("🔄 DEBUG: Direct memory fallback starting...");
    console.log("🔍 Fallback parameters:", { userId, characterId });
    
    try {
        const email = localStorage.getItem("user_email");
        const token = localStorage.getItem("user_token");
        const uid = localStorage.getItem("user_uid");
        
        console.log("🔑 Auth data for fallback:", { 
            hasEmail: !!email, 
            hasToken: !!token, 
            hasUid: !!uid,
            email: email
        });
        
        if (!email || !token || !uid) {
            console.log("❌ Missing auth data for fallback");
            return [];
        }
        
        const requestData = {
            user_email: email,
            user_uid: uid,
            user_token: token,
            user_id: userId,
            char: characterId,
            memory_focus: true,
            debug_mode: true
        };
        
        console.log("📤 Fallback request data:", requestData);
        
        const response = await fetch("https://hook.eu2.make.com/fjpapor4lkj9mpypaqx8no68d64bxe19", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestData)
        });
        
        console.log("📨 Fallback response status:", response.status);
        
        if (!response.ok) {
            console.log("❌ Fallback HTTP request failed");
            return [];
        }
        
        const rawText = await response.text();
        console.log("📄 Fallback raw response (first 500 chars):", rawText.substring(0, 500));
        
        let data;
        try {
            data = JSON.parse(rawText);
        } catch (e) {
            console.log("❌ Fallback JSON parse failed:", e.message);
            return [];
        }
        
        console.log("✅ Fallback parsed data keys:", Object.keys(data));
        console.log("✅ Fallback success:", data.success);
        
        if (!data.success || !data.history) {
            console.log("❌ Fallback: no success or no history");
            return [];
        }
        
        const memories = [];
        const historyArray = Array.isArray(data.history) ? data.history : Object.values(data.history);
        
        console.log(`🔍 Processing ${historyArray.length} history records for memories...`);
        
        historyArray.forEach((record, index) => {
            const fields = record.fields || record;
            
            // Check voor memory velden - VERBETERD
            const hasMemoryImportance = fields.Memory_Importance && parseInt(fields.Memory_Importance) >= 3;
            const hasSummary = fields.Summary && fields.Summary.trim().length > 0;
            const hasEmotionalState = fields.Emotional_State && fields.Emotional_State !== 'neutral';
            
            if (hasMemoryImportance || hasSummary || hasEmotionalState) {
                const memory = {
                    summary: fields.Summary || fields.Message?.substring(0, 100) || 'No summary',
                    importance: parseInt(fields.Memory_Importance) || 3,
                    emotional_state: fields.Emotional_State || 'neutral',
                    memory_tags: fields.Memory_Tags || ['general'],
                    message: fields.Message || '',
                    created_time: fields.CreatedTime || ''
                };
                
                memories.push(memory);
                console.log(`📝 Found memory ${index + 1}:`, {
                    summary: memory.summary.substring(0, 50) + '...',
                    importance: memory.importance,
                    emotional_state: memory.emotional_state
                });
            }
        });
        
        // Sorteer op importance
        memories.sort((a, b) => (b.importance || 0) - (a.importance || 0));
        const topMemories = memories.slice(0, 5);
        
        console.log(`✅ Fallback found ${topMemories.length} memories total`);
        return topMemories;
        
    } catch (error) {
        console.error("❌ Direct fallback error:", error);
        return [];
    }
}

async function processMemoryForMessage(recordId, message, conversationContext) {
    try {
        console.log("🧠 Processing memory for message:", message.substring(0, 50));
        
        const stored_user_id = localStorage.getItem('user_id');
        const stored_user_email = localStorage.getItem('user_email');
        const stored_user_uid = localStorage.getItem('user_uid');
        
        console.log("🔍 User detection:", {
            user_id: stored_user_id,
            user_email: stored_user_email,
            user_uid: stored_user_uid,
            characterSlug: characterSlug
        });
        
        const requestData = {
            record_id: recordId || null,
            message: message,
            context: conversationContext || '',
            user_id: stored_user_id || stored_user_uid || stored_user_email,
            user_email: stored_user_email,
            user_uid: stored_user_uid,
            character_id: characterSlug
        };
        
        console.log("📤 FULL Memory request data:", requestData);
        
async function processMemoryForMessage(recordId, message, conversationContext) {
   try {
       console.log("🧠 Processing memory for message:", message.substring(0, 50));
       
       const stored_user_id = localStorage.getItem('user_id');
       const stored_user_email = localStorage.getItem('user_email');
       const stored_user_uid = localStorage.getItem('user_uid');
       
       console.log("🔍 User detection:", {
           user_id: stored_user_id,
           user_email: stored_user_email,
           user_uid: stored_user_uid,
           characterSlug: characterSlug
       });
       
       const requestData = {
           record_id: recordId || null,
           message: message,
           context: conversationContext || '',
           user_id: stored_user_id || stored_user_uid || stored_user_email,
           user_email: stored_user_email,
           user_uid: stored_user_uid,
           character_id: characterSlug,
           character_slug: characterSlug,
           expected_character: "edward-elric",
           debug_mode: true,
           force_recent_search: true
       };
       
       console.log("📤 FULL Memory request data:", requestData);
       
       const response = await fetch('/.netlify/functions/update-memory', {
           method: 'POST',
           headers: { 
               'Content-Type': 'application/json',
               'Accept': 'application/json'
           },
           body: JSON.stringify(requestData)
       });
       
       console.log("📨 Memory function response status:", response.status);
       console.log("📨 Memory function response headers:", Object.fromEntries(response.headers.entries()));
       
       // ALTIJD response text lezen, ook bij error
       const responseText = await response.text();
       console.log("📄 FULL Memory function raw response:", responseText);
       
       if (response.ok) {
           try {
               const result = JSON.parse(responseText);
               console.log('✅ Memory processed successfully:', result);
               
               if (result.success) {
                   console.log('🧠 Memory analysis:', result.analysis);
                   console.log('📝 Update method used:', result.method);
                   
                   if (result.method !== 'analysis_only') {
                       console.log('💾 Memory successfully saved to Airtable');
                       console.log('🆔 Updated record ID:', result.record_id);
                       
                       // Success indicator
                       const chatlog = document.getElementById("chatlog");
                       if (chatlog) {
                           const memoryIndicator = document.createElement("div");
                           memoryIndicator.style.cssText = `
                               font-size: 10px; 
                               color: #14b8a6; 
                               text-align: center; 
                               margin: 2px 0; 
                               opacity: 0.7;
                           `;
                           memoryIndicator.textContent = "💾 Memory saved";
                           chatlog.appendChild(memoryIndicator);
                           
                           setTimeout(() => {
                               if (memoryIndicator.parentNode) {
                                   memoryIndicator.remove();
                               }
                           }, 3000);
                       }
                   } else {
                       console.log('⚠️ Memory analyzed but not saved to Airtable');
                       console.log('⚠️ This means no matching record was found in ChatHistory');
                   }
               } else {
                   console.log('❌ Memory processing returned success: false');
               }
           } catch (parseError) {
               console.error('❌ Failed to parse memory response as JSON:', parseError);
               console.log('📄 Raw response that failed to parse:', responseText);
           }
       } else {
           console.log('❌ Memory processing failed with status:', response.status);
           console.log('📄 Error response:', responseText);
       }
       
   } catch (error) {
       console.error('❌ Memory processing error:', error);
   }
}

        const response = await fetch('/.netlify/functions/update-memory', {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(requestData)
        });
        
        console.log("📨 Memory function response status:", response.status);
        console.log("📨 Memory function response headers:", Object.fromEntries(response.headers.entries()));
        
        // ALTIJD response text lezen, ook bij error
        const responseText = await response.text();
        console.log("📄 FULL Memory function raw response:", responseText);
        
        if (response.ok) {
            try {
                const result = JSON.parse(responseText);
                console.log('✅ Memory processed successfully:', result);
                
                if (result.success) {
                    console.log('🧠 Memory analysis:', result.analysis);
                    console.log('📝 Update method used:', result.method);
                    
                    if (result.method !== 'analysis_only') {
                        console.log('💾 Memory successfully saved to Airtable');
                        console.log('🆔 Updated record ID:', result.record_id);
                        
                        // Success indicator
                        const chatlog = document.getElementById("chatlog");
                        if (chatlog) {
                            const memoryIndicator = document.createElement("div");
                            memoryIndicator.style.cssText = `
                                font-size: 10px; 
                                color: #14b8a6; 
                                text-align: center; 
                                margin: 2px 0; 
                                opacity: 0.7;
                            `;
                            memoryIndicator.textContent = "💾 Memory saved";
                            chatlog.appendChild(memoryIndicator);
                            
                            setTimeout(() => {
                                if (memoryIndicator.parentNode) {
                                    memoryIndicator.remove();
                                }
                            }, 3000);
                        }
                    } else {
                        console.log('⚠️ Memory analyzed but not saved to Airtable');
                        console.log('⚠️ This means no matching record was found in ChatHistory');
                    }
                } else {
                    console.log('❌ Memory processing returned success: false');
                }
            } catch (parseError) {
                console.error('❌ Failed to parse memory response as JSON:', parseError);
                console.log('📄 Raw response that failed to parse:', responseText);
            }
        } else {
            console.log('❌ Memory processing failed with status:', response.status);
            console.log('📄 Error response:', responseText);
        }
        
    } catch (error) {
        console.error('❌ Memory processing error:', error);
    }
    
}
    
    const params = new URLSearchParams(window.location.search);
    characterSlug = params.get("char");

    if (!characterSlug) {
      showError("It looks like there's a connection issue. Let's get you to a safe space where you can find the right companion.");
    } else {
      loadCharacter(characterSlug);
    }

    async function loadCharacter(slug) {
  try {
    console.log("Loading character:", slug);
    
    const token = localStorage.getItem("user_token");
    const uid = localStorage.getItem("user_uid");
    const email = localStorage.getItem("user_email");
    
    const requestData = {
      action: "get_character",
      Slug: slug,
      user_uid: uid || "",
      user_token: token || "",
      user_email: email || ""
    };
    
    const response = await fetch(newWebhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestData)
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const data = await response.json();
    console.log("Character API response:", data);

    if (!data.success || !data.character) {
      throw new Error("Character not found");
    }

    // Decode Base64 prompt
    if (data.character.prompt) {
      data.character.prompt = atob(data.character.prompt);
    }

    // Ensure voice_id is available
    if (!data.character.voice_id && data.character.voice_type !== 'none') {
      console.log('No voice_id found, character will be text-only');
    }

    currentCharacter = data.character;
    console.log('Character loaded with voice_id:', currentCharacter.voice_id);
    setupCharacterInterface();
    
  } catch (error) {
    console.error("Error loading character:", error);
    showError("We're having trouble connecting you right now. Please know that we're here for you - let's try again in a moment.");
  }
}

    function setupCharacterInterface() {
      if (!currentCharacter) return;

      document.title = `Chat with ${currentCharacter.name}`;
      document.getElementById('characterName').textContent = currentCharacter.name;
      document.getElementById('characterTitle').textContent = currentCharacter.character_title || '';

      const avatarElement = document.getElementById('characterAvatar');
      if (currentCharacter.avatar_url) {
        avatarElement.innerHTML = `<img src="${currentCharacter.avatar_url}" alt="${currentCharacter.name}">`;
      } else {
        avatarElement.innerHTML = '👤';
      }

      document.getElementById('loadingState').style.display = 'none';
      document.getElementById('chatInterface').style.display = 'block';

      const userInput = document.getElementById("userInput");
      userInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") handleSendClick(e);
      });

      // Debug: Check isRegistered status
      console.log("🔍 setupCharacterInterface - checking user status");
      console.log("window.isRegistered:", window.isRegistered);
      console.log("localStorage token:", !!localStorage.getItem("user_token"));
      console.log("localStorage email:", localStorage.getItem("user_email"));

      // Check multiple conditions for user login
      const token = localStorage.getItem("user_token");
      const email = localStorage.getItem("user_email");
      const uid = localStorage.getItem("user_uid");
      const isLoggedIn = window.isRegistered || (token && email && uid);

      console.log("isLoggedIn calculated:", isLoggedIn);

      if (isLoggedIn) {
        console.log("✅ User is logged in, calling fetchHistory()");
        fetchHistory();
      } else {
        console.log("❌ User not logged in, skipping fetchHistory()");
      }
    }

    function showError(message) {
      document.getElementById('loadingState').style.display = 'none';
      document.getElementById('errorState').style.display = 'block';
      document.getElementById('chatInterface').style.display = 'none';
      
      const errorState = document.getElementById('errorState');
      errorState.querySelector('p').textContent = message;
    }

    // ===== CHAT FUNCTIONALITY =====
    async function handleSendClick(event) {
  if (!currentCharacter) {
    showWarning("We're almost ready for you! Just a moment while we prepare your companion.", "Getting Ready");
    return;
  }
  
  const token = localStorage.getItem("user_token");
  const uid = localStorage.getItem("user_uid");
  const email = localStorage.getItem("user_email");
  const netlifyUser = window.netlifyIdentity && window.netlifyIdentity.currentUser();
  
  if (!((token && uid && email) || netlifyUser)) {
    localStorage.setItem('login_redirect_url', window.location.href);
    window.location.href = 'profile.html';
    return;
  }

  // Check usage limit before sending message
  const canSend = await checkUsageLimit();
  if (!canSend) {
    return; // Usage limit reached, upgrade prompt already shown
  }
  
  // Add visual feedback to send button
  const sendButton = document.getElementById('sendButton');
  const userInput = document.getElementById('userInput');
  
  if (sendButton && userInput.value.trim()) {
    sendButton.style.background = 'var(--gradient-primary)';
    sendButton.textContent = 'Sending...';
    sendButton.disabled = true;
    userInput.disabled = true;
  }
  
  sendMessage(event);
}

 async function fetchHistory() {
  console.log("🚨 ULTRA ROBUST VERSION: fetchHistory() aangeroepen");
  
  const token = localStorage.getItem("user_token");
  const uid   = localStorage.getItem("user_uid");
  const email = localStorage.getItem("user_email");
  let user_id = localStorage.getItem("user_id");
  
  console.log("📋 User data:", { 
    token: !!token, 
    uid: !!uid, 
    email, 
    user_id,
    characterSlug 
  });
  
  if (!token || !uid || !characterSlug || !email) {
    console.warn("⚠️ fetchHistory: missing data", { 
      hasToken: !!token, 
      hasUid: !!uid, 
      hasEmail: !!email,
      hasUserId: !!user_id,
      hasCharacterSlug: !!characterSlug 
    });
    return;
  }

  console.log("🚀 Sending request to chat history webhook...");
  
  try {
    const requestPayload = {
      user_email: email,
      user_uid: uid,
      user_token: token,
      user_id: user_id || null,
      char: characterSlug
    };
    
    console.log("📤 Request payload:", requestPayload);
    
    const resp = await fetch("https://hook.eu2.make.com/fjpapor4lkj9mpypaqx8no68d64bxe19", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestPayload)
    });

    console.log("📨 Response status:", resp.status, resp.statusText);

    if (!resp.ok) {
      console.error("❌ fetchHistory response not ok:", resp.status, resp.statusText);
      return;
    }

    const rawText = await resp.text();
    console.log("📄 Raw response length:", rawText.length);
    console.log("📄 Complete raw response:", rawText);

    // Multiple fallback strategies for parsing
    let data = null;
    
    // Strategy 1: Try direct JSON parse
    try {
      data = JSON.parse(rawText);
      console.log("✅ Strategy 1 (direct parse) succeeded!");
    } catch (e1) {
      console.log("❌ Strategy 1 failed:", e1.message);
      
      // Strategy 2: Try to extract and manually construct JSON
      try {
        console.log("🔧 Trying Strategy 2: Manual JSON construction...");
        
        // Look for success indicator
        const successMatch = rawText.match(/["\']?success["\']?\s*:\s*(true|false)/i);
        const success = successMatch ? successMatch[1] === 'true' : false;
        
        // Look for history array using multiple patterns
        let historyArray = [];
        
        const patterns = [
          /"history"\s*:\s*(\[.*?\])/s,
          /'history'\s*:\s*(\[.*?\])/s,
          /history\s*:\s*(\[.*?\])/s,
          /"records"\s*:\s*(\[.*?\])/s,
          /"messages"\s*:\s*(\[.*?\])/s
        ];
        
        for (const pattern of patterns) {
          const match = rawText.match(pattern);
          if (match) {
            try {
              historyArray = JSON.parse(match[1]);
              console.log(`✅ Found history using pattern: ${pattern.source}`);
              break;
            } catch (parseErr) {
              console.log(`❌ Pattern ${pattern.source} matched but parse failed:`, parseErr.message);
            }
          }
        }
        
        if (historyArray.length > 0) {
          data = { success: success, history: historyArray };
          console.log("✅ Strategy 2 succeeded! Constructed data:", data);
        } else {
          throw new Error("No history array found in any pattern");
        }
        
      } catch (e2) {
        console.log("❌ Strategy 2 failed:", e2.message);
        
        // Strategy 3: Try to find individual message objects
        try {
          console.log("🔧 Trying Strategy 3: Extract individual objects...");
          
          const objectMatches = rawText.match(/\{[^{}]*\}/g);
          if (objectMatches && objectMatches.length > 0) {
            const parsedObjects = [];
            
            objectMatches.forEach((objStr, index) => {
              try {
                const obj = JSON.parse(objStr);
                parsedObjects.push(obj);
                console.log(`✅ Parsed object ${index + 1}:`, obj);
              } catch (objErr) {
                console.log(`❌ Failed to parse object ${index + 1}:`, objStr);
              }
            });
            
            if (parsedObjects.length > 0) {
              data = { success: true, history: parsedObjects };
              console.log("✅ Strategy 3 succeeded! Found", parsedObjects.length, "objects");
            } else {
              throw new Error("No valid objects found");
            }
          } else {
            throw new Error("No object patterns found");
          }
          
        } catch (e3) {
          console.log("❌ Strategy 3 failed:", e3.message);
          
          // Strategy 4: Create mock data to test UI
          console.log("🔧 Strategy 4: Creating mock data for testing...");
          data = {
            success: true,
            history: [
              { role: "user", message: "Hello Abraham!" },
              { role: "assistant", message: "Greetings! I am Abraham Lincoln, 16th President of the United States. How may I assist you today?" }
            ]
          };
          console.log("✅ Strategy 4: Using mock data to test UI");
        }
      }
    }

    if (!data || !data.success) {
      console.error("❌ All parsing strategies failed or API returned success: false");
      return;
    }

    // Process history data
    let history = [];
    
    if (Array.isArray(data.history)) {
      history = data.history;
      console.log("✅ Found history array with", history.length, "items");
    } else if (data.history && typeof data.history === 'object') {
      history = Object.values(data.history);
      console.log("🔧 Converted history object to array with", history.length, "items");
    } else {
      console.log("ℹ️ No history data found - starting fresh chat");
      return;
    }

    console.log(`📚 Processing ${history.length} chat messages`);

    const chatlog = document.getElementById("chatlog");
    chatlog.innerHTML = ''; // Clear existing content
    
    // Sort by timestamp if available
    history.sort((a, b) => {
      const timeA = a.CreatedTime || a.createdTime || a.created_time || a.timestamp || 0;
      const timeB = b.CreatedTime || b.createdTime || b.created_time || b.timestamp || 0;
      return new Date(timeA) - new Date(timeB);
    });

    let messagesProcessed = 0;

    history.forEach((record, index) => {
      console.log(`💬 Processing message ${index + 1}:`, record);
      
      // Extract role and message with multiple fallbacks
      let role = record.Role || record.role || record.sender || record.type || 
                 (record.fields && (record.fields.Role || record.fields.role));
      
      let message = record.Message || record.message || record.content || record.text || record.body ||
                    (record.fields && (record.fields.Message || record.fields.message || record.fields.content));

      // Default role assignment
      if (!role) {
        role = index % 2 === 0 ? 'user' : 'assistant';
      }
      
      console.log(`📝 Final extracted: role="${role}", message="${message ? message.substring(0, 50) : 'null'}..."`);
      
      if (!message || message.trim() === '') {
        console.warn("⚠️ Skipping record without message:", record);
        return;
      }
      
      // More robust filtering to only show actual chat messages
      const isDebugMessage = 
        // Skip obvious system/debug messages, but be careful not to filter real user messages
        (message.includes('Processing message') && message.includes(':')) ||
        (message.includes('Final extracted') && message.includes('role=')) ||
        (message.includes('CreatedTime') && message.includes('202') && message.includes('T')) ||
        (message.includes('Vorige gesprekken en belangrijke informatie:')) ||
        (message.includes('informatie en persoonlijke te antwoorden') && message.length > 200) ||
        
        // JSON data structures (but allow user messages that happen to contain braces)
        (message.startsWith('{') && message.endsWith('}') && message.includes('"role"')) ||
        (message.startsWith('[') && message.endsWith(']') && message.includes('"message"')) ||
        
        // Very specific system patterns
        (message.includes('202') && message.includes('T') && message.includes('Z') && message.length < 50) || // ISO timestamps only
        message.length > 2000 || // Extremely long messages are likely data dumps
        
        // Memory/debug specific with context
        message.includes('Memory processed successfully') ||
        message.includes('TTS response:') ||
        message.includes('Voice playback error:') ||
        
        // Record ID patterns (very specific)
        /^rec[A-Za-z0-9]{14}$/.test(message) || // Airtable record IDs
        (message.startsWith('rec') && message.length === 17 && !message.includes(' '));
      
      if (isDebugMessage) {
        console.warn("🧹 Filtering out debug/system message:", message.substring(0, 50));
        return;
      }
      
      // Additional safety check - ensure we have valid content for display
      if (message.trim().length < 1) {
        console.warn("⚠️ Skipping empty message");
        return;
      }
      
      // Additional validation - only show messages that look like real chat
      if (role !== 'user' && role !== 'assistant' && role !== 'ai assistant') {
        console.warn("⚠️ Skipping message with invalid role:", role);
        return;
      }
      
      const p = document.createElement("p");
      if (role === "user") {
        p.innerHTML = `<strong>You:</strong> ${message}`;
      } else {
        const avatarHtml = getAvatarHtml();
        
        if (currentCharacter && currentCharacter.voice_id) {
          // Validate voice ID before showing play button
          const validatedVoiceId = validateAndFixVoiceId(currentCharacter.voice_id);
          if (validatedVoiceId) {
            // Only show play button if we have a valid voice ID
            p.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> ${message}<br><div style="margin-top: 8px; text-align: left;"><button class="voice-play-btn" onclick="window.playMessageVoice(\`${message.replace(/`/g, '\\`')}\`, '${currentCharacter.voice_id}', this)" title="Listen to message">▶️</button></div>`;
          } else {
            // Don't show play button for invalid voice IDs
            p.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> ${message}`;
            console.warn(`⚠️ Voice playback disabled for ${currentCharacter?.name} - invalid voice ID: ${currentCharacter.voice_id}`);
          }
        } else {
          p.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> ${message}`;
        }
      }
      chatlog.appendChild(p);
      messagesProcessed++;
    });

    chatlog.scrollTop = chatlog.scrollHeight;
    console.log(`📜 Chat history loaded successfully - ${messagesProcessed} messages displayed`);
    
  } catch (err) {
    console.error("❌ Exception in fetchHistory:", err);
  }
}

    function getAvatarHtml() {
      if (currentCharacter?.avatar_url) {
        return `<img class="avatar" src="${currentCharacter.avatar_url}" alt="avatar">`;
      }
      return '<span class="message-avatar">👤</span>';
    }

    window.addEventListener("DOMContentLoaded", () => {
      if (window.isRegistered) {
        setTimeout(() => {
          if (currentCharacter) fetchHistory();
        }, 500);
      }
    });

    function showTypingIndicator() {
      console.log("🔄 showTypingIndicator() called");
      const chatlog = document.getElementById("chatlog");
      console.log("📋 chatlog element:", chatlog);
      
      // Check if typing indicator already exists
      const existingIndicator = document.getElementById("typingIndicator");
      if (existingIndicator) {
        console.log("⚠️ Typing indicator already exists, removing it first");
        existingIndicator.remove();
      }
      
      const typingIndicator = document.createElement("div");
      typingIndicator.className = "typing-indicator";
      typingIndicator.id = "typingIndicator";
      
      const avatarHtml = getAvatarHtml();
      typingIndicator.innerHTML = `
        <strong>${avatarHtml}${currentCharacter?.name || 'Character'} is thinking</strong>
        <div class="typing-dots">
          <span></span>
          <span></span>
          <span></span>
        </div>
      `;
      
      console.log("✅ Created typing indicator:", typingIndicator);
      
      chatlog.appendChild(typingIndicator);
      console.log("➕ Appended typing indicator to chatlog");
      
      // Force a reflow to ensure the element is rendered
      typingIndicator.offsetHeight;
      
      chatlog.scrollTop = chatlog.scrollHeight;
      console.log("📜 Scrolled chatlog to bottom");
      
      return typingIndicator;
    }

    function hideTypingIndicator() {
      console.log("🚫 hideTypingIndicator() called");
      const typingIndicator = document.getElementById("typingIndicator");
      console.log("🔍 Found typing indicator:", !!typingIndicator);
      if (typingIndicator) {
        console.log("🗑️ Removing typing indicator");
        typingIndicator.remove();
        console.log("✅ Typing indicator removed");
      } else {
        console.log("⚠️ No typing indicator found to remove");
      }
    }

    // Improved typewriter effect with fade-in animation
function typewriterEffect(element, text, speed = 8) {
  element.textContent = text;
  element.style.opacity = '0';
  element.style.transition = 'opacity 0.8s ease-in';
  
  // Fade in the text
  setTimeout(() => {
    element.style.opacity = '1';
  }, 100);
}

// UNIVERSELE Authentication Check - Voeg toe aan chat.html
function initializeAuthenticationCheck() {
  console.log('🔐 Initializing authentication check...');
  
  // Check localStorage first
  const token = localStorage.getItem('user_token');
  const email = localStorage.getItem('user_email');
  const uid = localStorage.getItem('user_uid');
  const timestamp = localStorage.getItem('user_auth_timestamp');
  
  if (token && email && uid && token !== 'false' && token !== 'null') {
    // Check if token is not too old (24 hours)
    const authAge = Date.now() - parseInt(timestamp || '0');
    if (authAge < 24 * 60 * 60 * 1000) {
      console.log('✅ Valid authentication found in localStorage:', email);
      
      // Set global auth state
      window.isAuthenticated = true;
      window.currentUser = { email, uid, token };
      
      return true;
    } else {
      console.log('⏰ Authentication expired, clearing...');
      clearAuthData();
    }
  }
  
  // Fallback: Check Netlify Identity
  if (window.netlifyIdentity) {
    const netlifyUser = window.netlifyIdentity.currentUser();
    if (netlifyUser) {
      console.log('✅ Found Netlify Identity user:', netlifyUser.email);
      
      // Store authentication data
      const accessToken = netlifyUser.token?.access_token || netlifyUser.access_token;
      if (accessToken) {
        localStorage.setItem('user_email', netlifyUser.email);
        localStorage.setItem('user_token', accessToken);
        localStorage.setItem('user_uid', netlifyUser.id);
        localStorage.setItem('user_auth_timestamp', Date.now().toString());
        
        window.isAuthenticated = true;
        window.currentUser = { 
          email: netlifyUser.email, 
          uid: netlifyUser.id, 
          token: accessToken 
        };
        
        return true;
      }
    }
  }
  
  console.log('❌ No valid authentication found');
  window.isAuthenticated = false;
  window.currentUser = null;
  return false;
}

// Clear authentication data
function clearAuthData() {
  localStorage.removeItem('user_email');
  localStorage.removeItem('user_token');
  localStorage.removeItem('user_uid');
  localStorage.removeItem('user_auth_timestamp');
  localStorage.removeItem('user_refresh_token');
  localStorage.removeItem('user_netlify_data');
  
  window.isAuthenticated = false;
  window.currentUser = null;
}

async function sendMessage(event) {
  event?.preventDefault();
  
  // Authentication check
  if (!window.isAuthenticated || !window.currentUser) {
    console.log('❌ User not authenticated, checking localStorage...');
    
    if (!initializeAuthenticationCheck()) {
      console.log('❌ No valid auth found, redirecting to login');
      localStorage.setItem('login_redirect_url', window.location.href);
      window.location.href = 'profile.html';
      return;
    }
  }
  
  const userInput = document.getElementById("userInput");
  const input = userInput.value.trim();
  if (!input) return;

  const email = window.currentUser.email;
  const token = window.currentUser.token;
  const uid = window.currentUser.uid;
  const user_id = localStorage.getItem("user_id");
  
  console.log("🚀 sendMessage debug:", { token: !!token, uid: !!uid, email, user_id, characterSlug });

  // Haal relevante herinneringen op
console.log("🧠 Retrieving memories before sending message...");
let memories = [];
try {
  memories = await getRelevantMemories(user_id, characterSlug, input);
  console.log("✅ Memory retrieval completed:", memories?.length || 0, "memories found");
} catch (error) {
  console.error("❌ Memory retrieval failed:", error);
  memories = []; // Fallback to empty array
}

// DEBUG: Memory verification
if (memories && memories.length > 0) {
    console.log(`📚 Found ${memories.length} relevant memories:`);
    memories.forEach((memory, i) => {
        console.log(`  ${i+1}. [${memory.importance}] ${memory.summary?.substring(0, 80)}...`);
    });
// Verbeterde memory context formatting
if (memories && memories.length > 0) {
    const memoryTexts = memories.map(m => {
        const summary = m.summary || m.message || '';
        const importance = m.importance || 0;
        return `[Belangrijk geheugen (${importance}/10): ${summary}]`;
    });
    
    memoryContext = `\n\nVorige gesprekken en belangrijke informatie:\n${memoryTexts.join('\n')}\n\nGebruik deze informatie om persoonlijk te antwoorden.\n`;
    
    console.log("📝 Improved memory context:", memoryContext);
} else {
    memoryContext = "";
}    console.log("📝 Memory context being sent:", memoryContext);
} else {
    console.log("📭 No relevant memories found");
    memoryContext = "";
}

  const sendButton = document.getElementById("sendButton");
  sendButton.disabled = true;
  sendButton.textContent = "Sharing...";

  const chatlog = document.getElementById("chatlog");
  
  // DIRECT: Voeg gebruiker bericht toe aan chat
  const divUser = document.createElement("p");
  divUser.innerHTML = `<strong>You:</strong> ${input}`;
  chatlog.appendChild(divUser);
  chatlog.scrollTop = chatlog.scrollHeight;
  userInput.value = "";

  // Reset send button state
  function resetSendButton() {
    const sendButton = document.getElementById('sendButton');
    const userInput = document.getElementById('userInput');
    if (sendButton) {
      sendButton.style.background = '';
      sendButton.textContent = 'Send';
      sendButton.disabled = false;
    }
    if (userInput) {
      userInput.disabled = false;
    }
  }

  // Show typing indicator immediately
showTypingIndicator();

  try {
    const requestPayload = {
      action: "send_message",
      text: memoryContext + input, // Voeg memory context toe aan de user input
      Character_id: characterSlug,
      Slug: characterSlug,
      user_uid: uid,
      user_token: token,
      user_email: email,
      user_id: user_id || null
    };
    
    console.log("📤 sendMessage FULL payload:", requestPayload);

    const response = await fetch(newWebhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestPayload)
    });

    console.log("📨 sendMessage response status:", response.status, response.statusText);

    const rawText = await response.text();
    console.log("📄 sendMessage raw response:", rawText);
    // EXTRA DEBUG INFO
console.log("📄 Raw response type:", typeof rawText);
console.log("📄 Raw response length:", rawText.length);
console.log("📄 First 200 chars:", rawText.substring(0, 200));
console.log("📄 Last 200 chars:", rawText.substring(rawText.length - 200));

    let data;
try {
  // Probeer eerst direct parsing
  data = JSON.parse(rawText);
  console.log("✅ Direct JSON parse successful:", data);
} catch (e) {
  console.warn("❌ Direct JSON parse failed:", e.message);
  
  // STRATEGIE 1: Clean de response text
  try {
    let cleanText = rawText.trim();
    
    // Verwijder BOM en speciale characters
    cleanText = cleanText.replace(/^\uFEFF/, ''); // BOM
    cleanText = cleanText.replace(/[\x00-\x1F\x7F-\x9F]/g, ''); // Control characters
    
    // Zoek naar JSON object in de text
    const jsonMatch = cleanText.match(/\{.*\}/s);
    if (jsonMatch) {
      data = JSON.parse(jsonMatch[0]);
      console.log("✅ JSON extracted and parsed:", data);
    } else {
      throw new Error("No JSON object found in response");
    }
    
  } catch (e2) {
    console.warn("❌ JSON extraction failed:", e2.message);
    
    // STRATEGIE 2: Zoek naar reply in raw text
    console.log("🔍 Searching for reply in raw text...");
    
    // Meerdere patronen om reply te vinden
    const patterns = [
      /"reply"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/s,
      /'reply'\s*:\s*'([^']*(?:\\.[^']*)*)'/s,
      /reply["\']?\s*[:=]\s*["\']([^"']*(?:\\.[^"']*)*)["\']?/s,
      /"response"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/s,
      /"message"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/s,
      /"text"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/s
    ];
    
    let foundReply = null;
    for (const pattern of patterns) {
      const match = rawText.match(pattern);
      if (match && match[1] && match[1].length > 10) { // Minimaal 10 karakters
        foundReply = match[1].replace(/\\"/g, '"').replace(/\\'/g, "'").replace(/\\n/g, '\n');
        console.log("✅ Found reply with pattern:", pattern.source);
        console.log("✅ Extracted reply:", foundReply.substring(0, 100) + "...");
        break;
      }
    }
    
    if (foundReply) {
      data = {
        success: true,
        reply: foundReply
      };
    } else {
      console.error("❌ No reply found in any pattern");
      console.log("🔍 Full raw text for manual inspection:", rawText);
      
      // Absolute fallback
      data = {
        success: true,
        reply: "I want to make sure I give you the thoughtful response you deserve. Could you share that with me again? I'm here to listen."
      };
    }
  }
}

    if (!data.success) {
      throw new Error("Chat request failed");
    }

    // Check if reply is empty or just whitespace
const reply = (data.reply && data.reply.trim()) || 
              (data.response && data.response.trim()) || 
              (data.message && data.message.trim()) || 
              "I want to be fully present for our conversation. It seems I'm having a moment of difficulty - could you share that with me once more? Your thoughts are important to me.";

console.log("🔍 Final reply used:", reply);

    // Hide typing indicator immediately when response is ready
hideTypingIndicator();

    // Reset send button state
    resetSendButton();

    // DIRECT: Voeg character antwoord toe aan chat
    const divBot = document.createElement("p");
    const avatarHtml = getAvatarHtml();
    
    if (currentCharacter.voice_id) {
      // Validate voice ID before showing play button
      const validatedVoiceId = validateAndFixVoiceId(currentCharacter.voice_id);
      if (validatedVoiceId) {
        // Only show play button if we have a valid voice ID
        divBot.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> <span class="typing-text"></span><br><div style="margin-top: 8px; text-align: left;"><button class="voice-play-btn" onclick="window.playMessageVoice(\`${reply.replace(/`/g, '\\`')}\`, '${currentCharacter.voice_id}', this)" title="Listen to message">▶️</button></div>`;
      } else {
        // Don't show play button for invalid voice IDs
        divBot.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> <span class="typing-text"></span>`;
        console.warn(`⚠️ Voice playback disabled for ${currentCharacter?.name} - invalid voice ID: ${currentCharacter.voice_id}`);
      }
    } else {
      divBot.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> <span class="typing-text"></span>`;
    }
    chatlog.appendChild(divBot);
    chatlog.scrollTop = chatlog.scrollHeight;

    const typingSpan = divBot.querySelector('.typing-text');
    
    // Use voice-enabled typewriter if character has voice
    if (currentCharacter.voice_id) {
      typewriterWithVoice(typingSpan, reply, currentCharacter.voice_id);
    } else {
      typewriterEffect(typingSpan, reply);
    }

    // Save chat messages to database
    try {
      console.log('💾 Saving chat messages to database...');
      const saveResponse = await fetch('/.netlify/functions/save-chat-message', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          user_email: email,
          user_uid: uid,
          user_token: token,
          char: characterSlug,
          user_message: input, // Original user input without memory context
          ai_response: reply
        })
      });
      
      if (saveResponse.ok) {
        const saveData = await saveResponse.json();
        console.log('✅ Messages saved successfully:', saveData);
      } else {
        console.warn('⚠️ Failed to save messages:', saveResponse.status);
      }
    } catch (saveError) {
      console.error('❌ Error saving messages:', saveError);
    }

    // Memory processing in background - VERBETERDE VERSIE
if (data && data.success) {
  console.log('🧠 Starting memory processing for message:', input);
  
  // Zoek naar record_id in ALLE mogelijke velden
  const recordId = data.record_id || 
                  data.chat_record_id || 
                  data.message_id || 
                  data.user_record_id || 
                  data.ChatHistory_id ||
                  data.id ||
                  null;
  
  console.log('🔍 Full API response for record_id detection:', data);
  console.log('🔍 Extracted record_id:', recordId);
  console.log('🔍 Available data keys:', Object.keys(data));
  
  setTimeout(() => {
    processMemoryForMessage(recordId, input, getLastMessages(3));
  }, 5000);
}
    
  } catch (err) {
    console.error("❌ sendMessage Error:", err);
    hideTypingIndicator();
    
    const divErr = document.createElement("p");
    divErr.innerHTML = `<strong>${currentCharacter?.name || 'Character'}:</strong> ⚠️ Something went wrong while sending.`;
    chatlog.appendChild(divErr);
    chatlog.scrollTop = chatlog.scrollHeight;
  } finally {
    sendButton.disabled = false;
    sendButton.textContent = "Send";
  }
}

// ===== DISCLAIMER TOGGLE FUNCTIONALITY =====
document.addEventListener('DOMContentLoaded', () => {
  // Initialize authentication check
  initializeAuthenticationCheck();
  const disclaimerToggle = document.getElementById('disclaimerToggle');
  const disclaimerExpanded = document.getElementById('disclaimerExpanded');
  
  if (disclaimerToggle && disclaimerExpanded) {
    disclaimerToggle.addEventListener('click', () => {
      const isExpanded = disclaimerExpanded.style.display !== 'none';
      
      if (isExpanded) {
        disclaimerExpanded.style.display = 'none';
        disclaimerToggle.classList.remove('expanded');
        disclaimerToggle.setAttribute('aria-label', 'Show more information');
      } else {
        disclaimerExpanded.style.display = 'block';
        disclaimerToggle.classList.add('expanded');
        disclaimerToggle.setAttribute('aria-label', 'Show less information');
      }
    });
  }
});

// ===== USAGE LIMIT CHECK =====
async function checkUsageLimit() {
  const token = localStorage.getItem("user_token");
  const uid = localStorage.getItem("user_uid");
  const email = localStorage.getItem("user_email");
  
  if (!token || !uid || !email) {
    return false;
  }

  try {
    console.log('🔍 Checking usage limit for:', email);
    
    const payload = {
      user_email: email,
      user_uid: uid,
      user_token: token,
      action: 'get_profile'
    };

    const resp = await fetch('https://hook.eu2.make.com/lya166veex7oo2wwo8mx4fuhlkssxlog', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!resp.ok) {
      console.warn('⚠️ Could not check usage limit, allowing message');
      return true;
    }

    const responseText = await resp.text();
    let data;

    try {
      data = JSON.parse(responseText);
    } catch (parseError) {
      console.warn('⚠️ Could not parse usage response, allowing message');
      return true;
    }

    const plan = data.plan || 'Free';
    const usage = parseInt(data.usage) || 0;
    const quota = parseInt(data.quota) || 100;

    console.log('📊 Usage check:', { plan, usage, quota });

    // If premium user, always allow
    if (plan.toLowerCase() === 'premium' || plan.toLowerCase() === 'pro' || plan.toLowerCase() === 'paid') {
      console.log('✅ Premium user - unlimited messages');
      return true;
    }

    // If usage >= quota, show upgrade prompt
    if (usage >= quota) {
      console.log('🚫 Usage limit reached');
      showUpgradePrompt(usage, quota);
      return false;
    }

    console.log('✅ Usage within limit');
    return true;

  } catch (error) {
    console.error('❌ Error checking usage limit:', error);
    return true;
  }
}

// ===== UPGRADE PROMPT =====
function showUpgradePrompt(usage, quota) {
  let upgradeOverlay = document.getElementById('upgradeOverlay');
  
  if (!upgradeOverlay) {
    upgradeOverlay = document.createElement('div');
    upgradeOverlay.id = 'upgradeOverlay';
    upgradeOverlay.className = 'upgrade-overlay';
    upgradeOverlay.innerHTML = `
      <div class="upgrade-modal">
        <div class="upgrade-header">
          <div class="upgrade-icon">💎</div>
          <h3 class="upgrade-title">Continue Your Journey</h3>
          <p class="upgrade-subtitle">You've shared ${quota} meaningful conversations this month. Ready to explore deeper connections?</p>
        </div>
        
        <div class="upgrade-benefits">
          <div class="benefit-item">
            <span class="benefit-icon">✨</span>
            <span class="benefit-text">Unlimited heartfelt conversations</span>
          </div>
          <div class="benefit-item">
            <span class="benefit-icon">🧠</span>
            <span class="benefit-text">Deeper, more personal connections</span>
          </div>
          <div class="benefit-item">
            <span class="benefit-icon">🎯</span>
            <span class="benefit-text">First access to new ways to connect</span>
          </div>
          <div class="benefit-item">
            <span class="benefit-icon">👑</span>
            <span class="benefit-text">Dedicated care and support</span>
          </div>
        </div>

        <div class="upgrade-pricing">
          <div class="price-tag">
            <span class="currency">€</span>
            <span class="amount">7.99</span>
            <span class="period">/month</span>
          </div>
        </div>

        <div class="upgrade-buttons">
          <button class="upgrade-btn primary" onclick="handleUpgradeFromChat()">
            Continue My Journey
          </button>
          <button class="upgrade-btn secondary" onclick="closeUpgradePrompt()">
            I'll Think About It
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(upgradeOverlay);
  }
  
  upgradeOverlay.classList.add('active');
  document.body.style.overflow = 'hidden';
}

function closeUpgradePrompt() {
  const upgradeOverlay = document.getElementById('upgradeOverlay');
  if (upgradeOverlay) {
    upgradeOverlay.classList.remove('active');
    document.body.style.overflow = '';
  }
}

// ===== STRIPE UPGRADE FROM CHAT =====
async function handleUpgradeFromChat() {
  console.log('🚀 Upgrade from chat clicked');
  
  const email = localStorage.getItem('user_email');
  const uid = localStorage.getItem('user_uid');
  
  if (!email || !uid) {
    showError('We want to make sure this is really you. Please sign in to continue your journey with us.');
    return;
  }
  
  try {
    const stripe = Stripe('pk_live_jz2dXpzmEDUahXkKkyUe36Zt');
    const PRICE_ID = 'price_1Rc9oTDU567HpUYxl1sLu71A';
    
    const upgradeButton = document.querySelector('.upgrade-btn.primary');
    const originalText = upgradeButton.innerHTML;
    upgradeButton.innerHTML = 'Setting up your journey...';
    upgradeButton.disabled = true;
    
    console.log('📡 Redirecting to Stripe Checkout...');
    
    const { error } = await stripe.redirectToCheckout({
      lineItems: [{
        price: PRICE_ID,
        quantity: 1,
      }],
      mode: 'subscription',
      successUrl: `${window.location.origin}/chat.html?char=${characterSlug}&upgrade=success`,
      cancelUrl: `${window.location.origin}/chat.html?char=${characterSlug}&upgrade=cancelled`,
      customerEmail: email,
      clientReferenceId: uid,
    });
    
    if (error) {
      throw new Error(error.message);
    }
    
  } catch (error) {
    console.error('❌ Error processing upgrade:', error);
    showError(`We encountered a small hiccup while processing your request. Please don't worry - we're here to help you through this.`);
    
    const upgradeButton = document.querySelector('.upgrade-btn.primary');
    if (upgradeButton) {
      upgradeButton.innerHTML = 'Continue My Journey';
      upgradeButton.disabled = false;
    }
  }
}

// Check upgrade status on page load
function checkUpgradeStatus() {
  const urlParams = new URLSearchParams(window.location.search);
  const upgradeStatus = urlParams.get('upgrade');
  
  if (upgradeStatus === 'success') {
    showSuccess('🎉 Welcome to your expanded journey! You now have unlimited space to share and explore your thoughts.');
    const newUrl = window.location.pathname + '?char=' + characterSlug;
    window.history.replaceState({}, document.title, newUrl);
  } else if (upgradeStatus === 'cancelled') {
    showWarning('No worries at all! When you\'re ready to expand your journey, we\'ll be here for you.');
    const newUrl = window.location.pathname + '?char=' + characterSlug;
    window.history.replaceState({}, document.title, newUrl);
  }
}

// Helper functie voor conversation context
function getLastMessages(count = 3) {
    const chatlog = document.getElementById("chatlog");
    const messages = chatlog.querySelectorAll("p");
    const lastMessages = Array.from(messages).slice(-count);
    return lastMessages.map(msg => msg.textContent).join(" | ");
}

  </script>

  <!-- Footer -->
  <footer class="footer">
    <div class="footer-content">
      <div class="footer-links">
        <a href="index.html" class="footer-link">Characters</a>
        <span class="footer-separator">•</span>
        <a href="chat-overview.html" class="footer-link">Chats</a>
        <span class="footer-separator">•</span>
        <a href="create-character.html" class="footer-link">Create Character</a>
        <span class="footer-separator">•</span>
        <a href="contact.html" class="footer-link">Contact</a>
        <span class="footer-separator">•</span>
        <a href="profile.html" class="footer-link">Profile</a>
        <span class="footer-separator">•</span>
        <a href="privacy-policy.html" class="footer-link">Privacy Policy</a>
        <span class="footer-separator">•</span>
        <a href="terms-and-conditions.html" class="footer-link">Terms and Conditions</a>
      </div>
      <div class="footer-copyright">
        © 2025 Narrin AI. All rights reserved.
      </div>
    </div>
  </footer>
</body>
</html>