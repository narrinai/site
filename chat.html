<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>AI Character Chat - Talk to 1000+ Characters | Narrin AI</title>
  <meta name="description" content="Chat with AI-powered characters from history, fiction & pop culture. Experience intelligent conversations with 1000+ unique personalities on Narrin AI.">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://narrin.ai/chat">
  <meta property="og:title" content="AI Character Chat - Talk to 1000+ Characters | Narrin AI">
  <meta property="og:description" content="Chat with AI-powered characters from history, fiction & pop culture. Experience intelligent conversations with 1000+ unique personalities on Narrin AI.">
  <meta property="og:image" content="https://narrin.ai/og-image.jpg">
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://narrin.ai/chat">
  <meta property="twitter:title" content="AI Character Chat - Talk to 1000+ Characters | Narrin AI">
  <meta property="twitter:description" content="Chat with AI-powered characters from history, fiction & pop culture. Experience intelligent conversations with 1000+ unique personalities on Narrin AI.">
  <meta property="twitter:image" content="https://narrin.ai/og-image.jpg">
  
  <!-- Favicon -->
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  
  <!-- Import Modern Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700;800&family=Outfit:wght@300;400;500;600;700;800&display=swap" rel="stylesheet">

  <style>
    /* ===== CSS CUSTOM PROPERTIES ===== */
    :root {
      /* Primary Colors */
      --color-white: #ffffff;
      --color-off-white: #fafafa;
      --color-light-gray: #f5f5f5;
      
      /* Accent Colors */
      --color-teal: #14b8a6;
      --color-teal-light: #5eead4;
      --color-teal-dark: #0f766e;
      --color-teal-alt: #10a394;
      --color-coral: #f97316;
      --color-coral-light: #fb923c;
      --color-coral-dark: #ea580c;
      
      /* Supporting Colors */
      --color-navy: #1e293b;
      --color-navy-light: #334155;
      --color-gray: #64748b;
      --color-gray-light: #94a3b8;
      --color-gray-dark: #475569;
      
      /* Gradients */
      --gradient-primary: linear-gradient(135deg, var(--color-teal) 0%, var(--color-coral) 100%);
      --gradient-subtle: linear-gradient(135deg, var(--color-teal-light) 0%, var(--color-coral-light) 100%);
      --gradient-tags: linear-gradient(135deg, var(--color-teal-alt) 0%, var(--color-coral) 100%);
      
      /* Shadows */
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
      --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
      --shadow-colored: 0 10px 25px -5px rgba(20, 184, 166, 0.2);
      
      /* Spacing */
      --spacing-xs: 0.5rem;
      --spacing-sm: 0.75rem;
      --spacing-md: 1rem;
      --spacing-lg: 1.5rem;
      --spacing-xl: 2rem;
      --spacing-2xl: 3rem;
      --spacing-3xl: 4rem;
      
      /* Typography */
      --font-primary: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, sans-serif;
      --font-secondary: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
      
      /* Font Sizes */
      --font-size-xs: 0.75rem;
      --font-size-sm: 0.875rem;
      --font-size-base: 1rem;
      --font-size-lg: 1.125rem;
      --font-size-xl: 1.25rem;
      --font-size-2xl: 1.5rem;
      --font-size-3xl: 1.875rem;
      --font-size-4xl: 2.25rem;
      
      /* Border Radius */
      --radius-sm: 6px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 24px;
      --radius-full: 9999px;
      
      /* Transitions */
      --transition-fast: 150ms ease-out;
      --transition-base: 300ms ease-out;
      --transition-slow: 500ms ease-out;
      
      /* Touch Target Size */
      --touch-target: 44px;
      
      /* Z-index Scale */
      --z-dropdown: 100;
      --z-sticky: 200;
      --z-overlay: 300;
      --z-modal: 400;
      --z-menu-overlay: 500;
    }

    /* ===== RESET & BASE STYLES ===== */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html {
      overflow-x: hidden;
    }

    body {
      font-family: var(--font-primary);
      background: var(--color-off-white);
      color: var(--color-navy);
      line-height: 1.6;
      font-size: var(--font-size-base);
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      min-height: 100vh;
      overflow-x: hidden;
      position: relative;
      width: 100%;
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      -webkit-overflow-scrolling: touch;
    }

    input,
    button,
    textarea {
      touch-action: manipulation;
      -webkit-tap-highlight-color: transparent;
      z-index: 10;
      position: relative;
    }

    /* ===== ACCESSIBILITY ===== */
    :focus {
      outline: 2px solid var(--color-teal);
      outline-offset: 2px;
    }

    :focus:not(:focus-visible) {
      outline: none;
    }

    /* ===== HEADER NAVIGATION ===== */
    .header {
      position: sticky;
      top: 0;
      z-index: var(--z-sticky);
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      transition: all var(--transition-base);
    }

    .header-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 var(--spacing-lg);
      width: 100%;
      overflow: hidden;
    }

    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      min-height: 72px;
      gap: var(--spacing-lg);
      width: 100%;
    }

    /* Logo */
    .logo {
      font-family: var(--font-secondary);
      font-size: var(--font-size-xl);
      font-weight: 800;
      text-decoration: none;
      letter-spacing: -0.02em;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      transition: transform var(--transition-base);
      flex-shrink: 0;
    }

    .logo:hover {
      transform: scale(1.05);
    }

    /* Desktop Navigation Center */
    .nav-center {
      display: none;
      align-items: center;
      gap: var(--spacing-lg);
      flex: 1;
      justify-content: flex-start;
    }

    /* USPs Container - Desktop */
    .nav-usps {
      display: flex;
      align-items: center;
      gap: var(--spacing-xl);
      height: auto;
      position: relative;
    }

    .usp-item {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      color: var(--color-gray-dark);
      font-size: var(--font-size-xs);
      font-weight: 500;
      white-space: nowrap;
    }

    .usp-icon {
      font-size: var(--font-size-lg);
      color: var(--color-teal);
    }
    /* Mobile USP Carousel adjustments */
    @media (max-width: 768px) {
      .nav-usps {
        height: 32px;
      }
      .usp-item {
        font-size: var(--font-size-xs);
        gap: var(--spacing-xs);
      }
      .usp-icon {
        font-size: var(--font-size-sm);
      }
    }

    /* Search Bar - Desktop */
    .nav-search {
      position: relative;
      width: 100%;
      max-width: 500px;
      margin-left: var(--spacing-xl);
    }

    .nav-search-input {
      width: 100%;
      padding: var(--spacing-sm) var(--spacing-lg);
      padding-right: calc(var(--spacing-lg) * 2.5);
      font-size: var(--font-size-sm);
      font-family: inherit;
      border: 2px solid var(--color-light-gray);
      border-radius: var(--radius-full);
      background: var(--color-white);
      color: var(--color-navy);
      transition: all var(--transition-base);
    }

    .nav-search-input:hover {
      border-color: var(--color-gray-light);
    }

    .nav-search-input:focus {
      border-color: var(--color-teal);
      box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
    }

    .nav-search-input::placeholder {
      color: var(--color-gray-light);
    }

    .search-submit {
      position: absolute;
      right: 6px;
      top: 50%;
      transform: translateY(-50%);
      background: var(--gradient-primary);
      border: none;
      border-radius: var(--radius-full);
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all var(--transition-base);
    }

    .search-submit:hover {
      transform: translateY(-50%) scale(1.1);
    }

    .search-submit svg {
      width: 18px;
      height: 18px;
      color: var(--color-white);
    }

    /* Navigation Links - Desktop */
    .nav-links {
      display: none;
      align-items: center;
      gap: var(--spacing-xl);
    }

    .nav-link {
      color: var(--color-navy);
      text-decoration: none;
      font-weight: 500;
      font-size: var(--font-size-sm);
      transition: color var(--transition-base);
      position: relative;
      padding: var(--spacing-xs) 0;
    }

    .nav-link::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background: var(--gradient-primary);
      transition: width var(--transition-base);
    }

    .nav-link:hover {
      color: var(--color-teal);
    }

    .nav-link:hover::after {
      width: 100%;
    }

    /* Buttons */
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: var(--spacing-sm) var(--spacing-lg);
      font-size: var(--font-size-sm);
      font-weight: 600;
      text-decoration: none;
      border: none;
      border-radius: var(--radius-md);
      cursor: pointer;
      transition: all var(--transition-base);
      min-height: var(--touch-target);
      white-space: nowrap;
    }

    .btn-primary {
      background: var(--gradient-primary);
      color: var(--color-white);
      box-shadow: var(--shadow-colored);
    }

    .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    /* Mobile Navigation Container */
    .mobile-nav-container {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      flex-shrink: 0;
    }

    /* Mobile Chat Button */
    .mobile-chat-btn {
      display: none;
      align-items: center;
      justify-content: center;
      width: var(--touch-target);
      height: var(--touch-target);
      background: transparent;
      border: none;
      cursor: pointer;
      color: var(--color-navy);
      transition: all var(--transition-base);
      border-radius: var(--radius-md);
      flex-shrink: 0;
      text-decoration: none;
    }

    .mobile-chat-btn:hover {
      background: var(--color-light-gray);
    }

    .mobile-chat-btn svg {
      width: 24px;
      height: 24px;
    }

    /* Mobile Search Button */
    .mobile-search-btn {
      display: none;
      align-items: center;
      justify-content: center;
      width: var(--touch-target);
      height: var(--touch-target);
      background: transparent;
      border: none;
      cursor: pointer;
      color: var(--color-navy);
      transition: all var(--transition-base);
      border-radius: var(--radius-md);
      flex-shrink: 0;
    }

    .mobile-search-btn:hover {
      background: var(--color-light-gray);
    }

    .mobile-search-btn svg {
      width: 24px;
      height: 24px;
    }

    /* Mobile Hamburger Menu */
    .mobile-menu-btn {
      display: none;
      align-items: center;
      justify-content: center;
      width: var(--touch-target);
      height: var(--touch-target);
      background: transparent;
      border: none;
      cursor: pointer;
      color: var(--color-navy);
      transition: all var(--transition-base);
      border-radius: var(--radius-md);
      position: relative;
      flex-shrink: 0;
      z-index: var(--z-menu-overlay);
    }

    .mobile-menu-btn:hover {
      background: var(--color-light-gray);
    }

    .hamburger {
      width: 24px;
      height: 18px;
      position: relative;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
    }

    .hamburger span {
      display: block;
      height: 2px;
      width: 100%;
      background: var(--color-navy);
      border-radius: 1px;
      transition: all var(--transition-base);
    }

    .mobile-menu-btn.active .hamburger span:nth-child(1) {
      transform: rotate(45deg) translate(6px, 6px);
    }

    .mobile-menu-btn.active .hamburger span:nth-child(2) {
      opacity: 0;
    }

    .mobile-menu-btn.active .hamburger span:nth-child(3) {
      transform: rotate(-45deg) translate(6px, -6px);
    }

    /* Mobile Menu Overlay - Full Screen */
    .mobile-menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(30, 41, 59, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      z-index: var(--z-overlay);
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-base);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .mobile-menu-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .mobile-menu-content {
      background: var(--color-white);
      border-radius: var(--radius-xl);
      padding: var(--spacing-3xl) var(--spacing-xl);
      box-shadow: var(--shadow-xl);
      max-width: 90vw;
      width: 100%;
      max-width: 400px;
      transform: scale(0.9) translateY(20px);
      transition: all var(--transition-base);
    }

    .mobile-menu-overlay.active .mobile-menu-content {
      transform: scale(1) translateY(0);
    }

    .mobile-menu-header {
      text-align: center;
      margin-bottom: var(--spacing-2xl);
    }

    .mobile-menu-logo {
      font-family: var(--font-secondary);
      font-size: var(--font-size-2xl);
      font-weight: 800;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: var(--spacing-sm);
    }

    .mobile-menu-subtitle {
      color: var(--color-gray);
      font-size: var(--font-size-sm);
    }

    .mobile-menu-nav {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
    }

    .mobile-menu-link {
      display: flex;
      align-items: center;
      padding: var(--spacing-md) var(--spacing-lg);
      color: var(--color-navy);
      text-decoration: none;
      font-weight: 500;
      font-size: var(--font-size-base);
      transition: all var(--transition-base);
      border-radius: var(--radius-md);
      background: var(--color-off-white);
    }

    .mobile-menu-link:hover {
      background: var(--color-light-gray);
      color: var(--color-teal);
      transform: translateX(4px);
    }

    .mobile-menu-link.btn-primary {
      background: var(--gradient-primary);
      color: var(--color-white);
      justify-content: center;
      font-weight: 700;
      margin-top: var(--spacing-lg);
    }

    .mobile-menu-link.btn-primary:hover {
      background: var(--gradient-primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .mobile-menu-link-icon {
      margin-right: var(--spacing-sm);
      font-size: var(--font-size-lg);
    }

    /* Mobile Search Overlay */
    .mobile-search-overlay {
      position: fixed;
      top: 72px;
      left: 0;
      right: 0;
      background: var(--color-white);
      padding: var(--spacing-lg);
      box-shadow: var(--shadow-lg);
      transform: translateY(-100%);
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-base);
      z-index: var(--z-dropdown);
    }

    .mobile-search-overlay.active {
      transform: translateY(0);
      opacity: 1;
      visibility: visible;
    }

    .mobile-search-form {
      display: flex;
      gap: var(--spacing-sm);
    }

    .mobile-search-input {
      flex: 1;
      padding: var(--spacing-md);
      font-size: var(--font-size-base);
      font-family: inherit;
      border: 2px solid var(--color-light-gray);
      border-radius: var(--radius-md);
      background: var(--color-white);
      color: var(--color-navy);
      transition: all var(--transition-base);
    }

    .mobile-search-input:focus {
      border-color: var(--color-teal);
      box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
    }

    /* Desktop Styles */
    @media (min-width: 769px) {
      .nav-center {
        display: flex;
      }

      .nav-links {
        display: flex;
      }

      .mobile-nav-container {
        display: none;
      }

      .mobile-chat-btn {
        display: none !important;
      }

      .mobile-search-btn {
        display: none !important;
      }

      .mobile-menu-btn {
        display: none !important;
      }

      .mobile-menu-overlay {
        display: none !important;
      }
    }

    /* Mobile Styles */
    @media (max-width: 768px) {
      .header-container {
        padding: 0 var(--spacing-md);
      }

      .header-content {
        min-height: 60px;
        gap: var(--spacing-sm);
        padding: 0;
        display: grid;
        grid-template-columns: auto 1fr auto auto auto;
        align-items: center;
      }

      .logo {
        font-size: var(--font-size-lg);
        flex-shrink: 0;
        min-width: fit-content;
        grid-column: 1;
      }

      .mobile-nav-container {
        flex-shrink: 0;
        min-width: fit-content;
        display: flex !important;
        gap: var(--spacing-xs);
        grid-column: 3 / 6;
        justify-self: end;
      }

      .nav-center {
        display: none !important;
      }

      .nav-links {
        display: none !important;
      }

      .mobile-chat-btn {
        display: flex;
        flex-shrink: 0;
      }

      .mobile-search-btn {
        display: flex;
        flex-shrink: 0;
      }

      .mobile-menu-btn {
        display: flex;
        flex-shrink: 0;
      }

      .mobile-search-overlay {
        top: 60px;
      }
    }

    /* Extra small mobile devices */
    @media (max-width: 480px) {
      .header-content {
        gap: var(--spacing-xs);
        grid-template-columns: auto 1fr auto auto auto;
      }
      
      .logo {
        font-size: var(--font-size-base);
      }
    }

    /* Netlify Identity Modal Positioning */
    .netlify-identity-widget,
    [data-netlify-identity-widget] {
      z-index: 2147483647 !important;
    }

    .netlify-identity-widget iframe,
    .netlify-identity-widget > div,
    .netlify-identity-widget .netlify-identity-modal {
      z-index: 2147483647 !important;
    }

    /* CHAT SPECIFIC STYLES */
    .container {
      max-width: 700px;
      margin: 0 auto;
      padding: var(--spacing-md) var(--spacing-xl);
    }

    .page-header {
      text-align: center;
      margin-bottom: var(--spacing-xl);
    }

    .page-header h1 {
      font-family: var(--font-secondary);
      font-size: var(--font-size-2xl);
      margin: 0 0 var(--spacing-xs) 0;
      color: var(--color-navy);
      font-weight: 700;
      letter-spacing: -0.01em;
    }

    .page-header p {
      color: var(--color-gray);
      font-size: var(--font-size-sm);
      margin: 0;
      font-weight: 400;
    }

    .character-section {
      background: var(--color-white);
      padding: var(--spacing-lg) var(--spacing-xl);
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-lg);
      box-shadow: var(--shadow-md);
      border: 2px solid var(--color-light-gray);
      transition: all var(--transition-base);
    }

    .character-section:hover {
      border-color: var(--color-teal);
      box-shadow: var(--shadow-lg);
    }

    .character-header {
      display: flex;
      align-items: center;
      gap: var(--spacing-md);
    }

    .character-avatar {
      width: 60px;
      height: 60px;
      border-radius: var(--radius-full);
      object-fit: cover;
      background: var(--color-light-gray);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: var(--font-size-2xl);
      flex-shrink: 0;
      border: 3px solid var(--color-light-gray);
      transition: all var(--transition-base), opacity 0.3s ease;
      position: relative;
    }

    .character-avatar img {
      width: 100%;
      height: 100%;
      border-radius: var(--radius-full);
      object-fit: cover;
    }
    
    /* Avatar loading state */
    .avatar-loading {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .avatar-loading .spinner {
      width: 30px;
      height: 30px;
      border: 3px solid var(--color-light-gray);
      border-top-color: var(--color-teal);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    /* Online indicator for character avatar */
    .online-indicator {
      position: absolute;
      bottom: 2px;
      right: 2px;
      width: 16px;
      height: 16px;
      background: #22c55e;
      border: 2px solid var(--color-white);
      border-radius: var(--radius-full);
      box-shadow: var(--shadow-sm);
      animation: onlinePulse 2s infinite;
    }

    @keyframes onlinePulse {
      0%, 100% {
        opacity: 1;
        transform: scale(1);
      }
      50% {
        opacity: 0.8;
        transform: scale(1.1);
      }
    }

    .character-info {
      flex: 1;
    }

    .character-info h2 {
      margin: 0 0 var(--spacing-xs) 0;
      color: var(--color-navy);
      font-size: var(--font-size-lg);
      font-weight: 700;
      font-family: var(--font-secondary);
      letter-spacing: -0.01em;
    }

    .character-info p {
      margin: 0;
      color: var(--color-gray);
      font-size: var(--font-size-sm);
      font-weight: 500;
    }

    .chat-section {
      background: var(--color-white);
      padding: var(--spacing-lg) var(--spacing-xl);
      border-radius: var(--radius-lg);
      max-width: 900px;
      margin: 0 auto;
      margin-bottom: var(--spacing-lg);
      box-shadow: var(--shadow-md);
      border: 2px solid var(--color-light-gray);
      transition: all var(--transition-base);
    }

    .chat-section:hover {
      border-color: var(--color-teal);
      box-shadow: var(--shadow-lg);
    }

    .loading-state {
      text-align: center;
      padding: var(--spacing-3xl) var(--spacing-xl);
      color: var(--color-gray);
    }

    .loading-state h3 {
      font-family: var(--font-secondary);
      font-size: var(--font-size-2xl);
      margin: 0 0 var(--spacing-md) 0;
      color: var(--color-navy);
      font-weight: 700;
    }

    .error-state {
      text-align: center;
      padding: var(--spacing-2xl) var(--spacing-xl);
      color: #c53030;
      background: #fed7d7;
      border-radius: var(--radius-lg);
      margin-bottom: var(--spacing-xl);
      box-shadow: var(--shadow-md);
    }

    .error-state h3 {
      margin: 0 0 var(--spacing-xs) 0;
      color: #c53030;
      font-size: var(--font-size-2xl);
      font-family: var(--font-secondary);
      font-weight: 700;
    }

    .error-state p {
      margin: 0 0 var(--spacing-lg) 0;
      font-size: var(--font-size-base);
    }

    .error-state a {
      color: var(--color-teal);
      text-decoration: none;
      font-weight: 600;
      transition: all var(--transition-base);
      padding: var(--spacing-xs) var(--spacing-sm);
      border-radius: var(--radius-md);
    }

    .error-state a:hover {
      color: var(--color-white);
      background: var(--color-teal);
      transform: translateY(-1px);
    }

    #chatlog {
      height: 450px;
      overflow-y: auto;
      background: var(--color-off-white);
      padding: var(--spacing-lg);
      border-radius: var(--radius-md);
      margin-bottom: var(--spacing-lg);
      font-size: var(--font-size-sm);
      border: 2px solid var(--color-light-gray);
      box-shadow: var(--shadow-sm);
      transition: all var(--transition-base);
    }

    #chatlog:hover {
      border-color: var(--color-teal);
    }

    #chatlog p {
      margin: 0 0 var(--spacing-md) 0;
      line-height: 1.5;
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-md);
      background: var(--color-white);
      box-shadow: var(--shadow-sm);
    }

    #chatlog p:last-child {
      margin-bottom: 0;
    }

    .input-group {
      display: flex;
      gap: var(--spacing-md);
      margin-bottom: var(--spacing-sm);
    }

    #userInput {
      flex: 1;
      padding: var(--spacing-md) var(--spacing-lg);
      font-size: var(--font-size-base);
      border: 2px solid var(--color-light-gray);
      border-radius: var(--radius-full);
      font-family: var(--font-primary);
      transition: all var(--transition-base);
      background: var(--color-white);
      color: var(--color-navy);
      box-shadow: var(--shadow-sm);
    }

    #userInput:focus {
      outline: none;
      border-color: var(--color-teal);
      box-shadow: var(--shadow-md);
      transform: translateY(-2px);
    }

    #userInput::placeholder {
      color: var(--color-gray-light);
      font-weight: 400;
    }

    #sendButton {
      padding: var(--spacing-md) var(--spacing-xl);
      background: var(--gradient-primary);
      color: var(--color-white);
      border: none;
      border-radius: var(--radius-full);
      font-size: var(--font-size-base);
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-base);
      min-width: 100px;
      box-shadow: var(--shadow-colored);
      font-family: var(--font-primary);
    }

    #sendButton:hover {
      opacity: 0.9;
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    #sendButton:disabled {
      background: var(--color-gray-light);
      cursor: not-allowed;
      opacity: 0.6;
      transform: none;
      box-shadow: var(--shadow-sm);
    }

    .disclaimer {
      font-size: var(--font-size-xs);
      color: var(--color-gray);
      text-align: center;
      line-height: 1.4;
      margin-top: var(--spacing-sm);
      padding: var(--spacing-sm);
      background: var(--color-off-white);
      border-radius: var(--radius-md);
      border: 1px solid var(--color-light-gray);
      display: flex;
      align-items: flex-start;
      gap: var(--spacing-xs);
      flex-wrap: wrap;
    }

    .disclaimer-icon {
      color: var(--color-teal);
      flex-shrink: 0;
    }

    .disclaimer-main-text {
      flex: 1;
      min-width: 0;
    }

    .disclaimer-toggle {
      background: none;
      border: none;
      color: var(--color-gray);
      cursor: pointer;
      padding: 2px;
      border-radius: var(--radius-sm);
      transition: all var(--transition-base);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .disclaimer-toggle:hover {
      background: var(--color-light-gray);
      color: var(--color-teal);
    }

    .disclaimer-toggle.expanded {
      transform: rotate(180deg);
    }

    .disclaimer-expanded {
      width: 100%;
      margin-top: var(--spacing-xs);
      padding-top: var(--spacing-xs);
      border-top: 1px solid var(--color-light-gray);
      animation: slideDown 0.3s ease-out;
    }

    .disclaimer-link {
      color: var(--color-teal);
      text-decoration: none;
      font-weight: 500;
      transition: color var(--transition-base);
    }

    .disclaimer-link:hover {
      color: var(--color-teal-dark);
      text-decoration: underline;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .avatar {
      width: 28px;
      height: 28px;
      border-radius: var(--radius-full);
      vertical-align: middle;
      margin-right: var(--spacing-xs);
      object-fit: cover;
      border: 2px solid var(--color-light-gray);
      position: relative;
      display: inline-block;
    }

    /* Online indicator for message avatars */
    .avatar-container {
      position: relative;
      display: inline-block;
      vertical-align: middle;
      margin-right: var(--spacing-xs);
    }

    .avatar-container .online-indicator {
      position: absolute;
      bottom: -1px;
      right: -1px;
      width: 10px;
      height: 10px;
      background: #22c55e;
      border: 1px solid var(--color-white);
      border-radius: var(--radius-full);
      box-shadow: var(--shadow-sm);
    }

    .message-avatar {
      display: inline-block;
      width: 28px;
      height: 28px;
      border-radius: var(--radius-full);
      text-align: center;
      line-height: 24px;
      font-size: var(--font-size-xs);
      vertical-align: middle;
      margin-right: var(--spacing-xs);
      background: var(--color-light-gray);
      border: 2px solid var(--color-gray-light);
    }

    @media (max-width: 600px) {
      .container {
        padding: var(--spacing-sm) var(--spacing-lg);
      }

      .page-header h1 {
        font-size: var(--font-size-xl);
      }

      .page-header p {
        font-size: var(--font-size-xs);
      }

      .character-section,
      .chat-section {
        padding: var(--spacing-lg) var(--spacing-lg);
      }

      .character-avatar {
        width: 50px;
        height: 50px;
        font-size: var(--font-size-xl);
      }

      .character-info h2 {
        font-size: var(--font-size-base);
      }

      .character-info p {
        font-size: var(--font-size-xs);
      }

      #chatlog {
        height: 400px;
        padding: var(--spacing-md);
        font-size: var(--font-size-xs);
      }

      .input-group {
        flex-direction: column;
        gap: var(--spacing-sm);
      }

      #sendButton {
        width: 100%;
        padding: var(--spacing-sm) var(--spacing-lg);
      }

      .disclaimer {
        font-size: calc(var(--font-size-xs) * 0.9);
        padding: var(--spacing-xs) var(--spacing-sm);
      }
    }

    /* Typing indicator styles */
    .typing-indicator {
      display: flex;
      align-items: center;
      padding: var(--spacing-sm) var(--spacing-md);
      margin: 0 0 var(--spacing-md) 0;
      background: var(--color-white);
      border-radius: var(--radius-md);
      box-shadow: var(--shadow-sm);
      font-style: italic;
      color: var(--color-gray);
      animation: fadeIn 0.3s ease-in;
    }

    .typing-indicator .avatar {
      margin-right: var(--spacing-xs);
    }

    .typing-indicator .message-avatar {
      margin-right: var(--spacing-xs);
    }

    .typing-dots {
      display: inline-flex;
      align-items: center;
      margin-left: var(--spacing-xs);
    }

    .typing-dots span {
      height: 4px;
      width: 4px;
      background: var(--color-gray);
      border-radius: 50%;
      display: inline-block;
      margin: 0 1px;
      animation: typingDots 1.4s infinite ease-in-out;
    }

    .typing-dots span:nth-child(1) {
      animation-delay: -0.32s;
    }

    .typing-dots span:nth-child(2) {
      animation-delay: -0.16s;
    }

    @keyframes typingDots {
      0%, 80%, 100% {
        transform: scale(0.8);
        opacity: 0.5;
      }
      40% {
        transform: scale(1);
        opacity: 1;
      }
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    /* ===== FOOTER ===== */
    .footer {
      background: var(--color-white);
      border-top: 1px solid var(--color-light-gray);
      padding: var(--spacing-xl) var(--spacing-lg);
      margin-top: var(--spacing-3xl);
    }

    .footer-content {
      max-width: 1400px;
      margin: 0 auto;
      text-align: center;
    }

    .footer-links {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: var(--spacing-xl);
      margin-bottom: var(--spacing-md);
    }

    .footer-link {
      color: var(--color-gray);
      text-decoration: none;
      font-size: var(--font-size-sm);
      font-weight: 500;
      transition: color var(--transition-base);
    }

    .footer-link:hover {
      color: var(--color-teal);
    }

    .footer-separator {
      color: var(--color-gray-light);
      font-size: var(--font-size-sm);
    }

    .footer-copyright {
      color: var(--color-gray-light);
      font-size: var(--font-size-xs);
    }

    /* ===== RATING SYSTEM STYLES ===== */
    .rating-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(30, 41, 59, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: var(--z-modal);
      display: none;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all var(--transition-base);
    }

    .rating-overlay.active {
      display: flex;
      opacity: 1;
    }

    .rating-modal {
      background: var(--color-white);
      border-radius: var(--radius-xl);
      padding: var(--spacing-2xl);
      box-shadow: var(--shadow-xl);
      max-width: 90vw;
      width: 100%;
      max-width: 450px;
      transform: scale(0.9) translateY(20px);
      transition: all var(--transition-base);
    }

    .rating-overlay.active .rating-modal {
      transform: scale(1) translateY(0);
    }

    .rating-header {
      text-align: center;
      margin-bottom: var(--spacing-xl);
    }

    .rating-title {
      font-size: var(--font-size-2xl);
      font-weight: 700;
      font-family: var(--font-secondary);
      color: var(--color-navy);
      margin-bottom: var(--spacing-sm);
    }

    .rating-subtitle {
      font-size: var(--font-size-base);
      color: var(--color-gray);
      line-height: 1.5;
    }

    .rating-stars {
      display: flex;
      justify-content: center;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-xl);
    }

    .rating-star {
      font-size: 40px;
      cursor: pointer;
      color: #ddd;
      transition: all var(--transition-fast);
      user-select: none;
      line-height: 1;
    }

    .rating-star:hover {
      transform: scale(1.1);
    }

    .rating-star.active {
      color: #ffd700;
      transform: scale(1.05);
    }

    .rating-star.hover {
      color: #ffed4e;
    }

    .rating-feedback {
      margin-bottom: var(--spacing-xl);
    }

    .rating-feedback-label {
      display: block;
      font-size: var(--font-size-sm);
      color: var(--color-gray);
      margin-bottom: var(--spacing-sm);
      font-weight: 500;
    }

    .rating-feedback-input {
      width: 100%;
      padding: var(--spacing-md);
      border: 2px solid var(--color-light-gray);
      border-radius: var(--radius-md);
      font-size: var(--font-size-base);
      font-family: var(--font-primary);
      resize: vertical;
      min-height: 80px;
      transition: border-color var(--transition-base);
    }

    .rating-feedback-input:focus {
      outline: none;
      border-color: var(--color-teal);
    }

    .rating-actions {
      display: flex;
      gap: var(--spacing-md);
      justify-content: flex-end;
    }

    .rating-btn {
      padding: var(--spacing-sm) var(--spacing-lg);
      border-radius: var(--radius-md);
      font-size: var(--font-size-base);
      font-weight: 500;
      border: none;
      cursor: pointer;
      transition: all var(--transition-base);
      font-family: var(--font-primary);
    }

    .rating-btn-skip {
      background: transparent;
      color: var(--color-gray);
      border: 2px solid var(--color-light-gray);
    }

    .rating-btn-skip:hover {
      border-color: var(--color-gray-light);
      color: var(--color-gray-dark);
    }

    .rating-btn-submit {
      background: var(--gradient-primary);
      color: var(--color-white);
      padding: var(--spacing-sm) var(--spacing-xl);
    }

    .rating-btn-submit:hover {
      transform: translateY(-1px);
      box-shadow: var(--shadow-colored);
    }

    .rating-btn-submit:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    /* Mobile footer adjustments */
    @media (max-width: 768px) {
      .footer-links {
        flex-direction: column;
        gap: var(--spacing-md);
      }

      .footer-separator {
        display: none;
      }
    }

    /* Accessibility improvements */
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
      
      .typing-dots span {
        animation: none;
        opacity: 0.7;
      }

      .online-indicator {
        animation: none !important;
      }
    }

    /* ===== CUSTOM NOTIFICATION SYSTEM ===== */
    .notification-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(30, 41, 59, 0.8);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      z-index: var(--z-modal);
      display: none;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all var(--transition-base);
    }

    .notification-overlay.active {
      display: flex;
      opacity: 1;
    }

    .notification-modal {
      background: var(--color-white);
      border-radius: var(--radius-xl);
      padding: var(--spacing-2xl);
      box-shadow: var(--shadow-xl);
      max-width: 90vw;
      width: 100%;
      max-width: 400px;
      transform: scale(0.9) translateY(20px);
      transition: all var(--transition-base);
      text-align: center;
    }

    .notification-overlay.active .notification-modal {
      transform: scale(1) translateY(0);
    }

    .notification-icon {
      font-size: var(--font-size-4xl);
      margin-bottom: var(--spacing-lg);
      display: block;
    }

    .notification-icon.success {
      color: var(--color-teal);
    }

    .notification-icon.error {
      color: var(--color-coral);
    }

    .notification-icon.warning {
      color: #f59e0b;
    }

    .notification-icon.info {
      color: #3b82f6;
    }

    .notification-title {
      font-family: var(--font-secondary);
      font-size: var(--font-size-xl);
      font-weight: 700;
      color: var(--color-navy);
      margin-bottom: var(--spacing-md);
    }

    .notification-message {
      color: var(--color-gray-dark);
      font-size: var(--font-size-base);
      line-height: 1.6;
      margin-bottom: var(--spacing-xl);
    }

    .notification-buttons {
      display: flex;
      gap: var(--spacing-md);
      justify-content: center;
    }

    .notification-btn {
      padding: var(--spacing-sm) var(--spacing-lg);
      border: none;
      border-radius: var(--radius-md);
      font-size: var(--font-size-sm);
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-base);
      min-width: 100px;
      font-family: var(--font-primary);
    }

    .notification-btn.primary {
      background: var(--gradient-primary);
      color: var(--color-white);
      box-shadow: var(--shadow-colored);
    }

    .notification-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-lg);
    }

    .notification-btn.secondary {
      background: var(--color-white);
      color: var(--color-navy);
      border: 2px solid var(--color-light-gray);
    }

    .notification-btn.secondary:hover {
      border-color: var(--color-teal);
      color: var(--color-teal);
    }

    /* Mobile adjustments */
    @media (max-width: 768px) {
      .notification-modal {
        margin: var(--spacing-lg);
        padding: var(--spacing-xl);
      }

      .notification-buttons {
        flex-direction: column;
      }

      .notification-btn {
        width: 100%;
      }
    }

/* ===== UPGRADE OVERLAY STYLES ===== */
.upgrade-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(30, 41, 59, 0.95);
  backdrop-filter: blur(20px);
  -webkit-backdrop-filter: blur(20px);
  z-index: 999999999;
  display: none;
  align-items: center;
  justify-content: center;
  opacity: 0;
  transition: all var(--transition-base);
}

.upgrade-overlay.active {
  display: flex;
  opacity: 1;
}

.upgrade-modal {
  background: var(--color-white);
  border-radius: var(--radius-xl);
  padding: var(--spacing-3xl);
  box-shadow: var(--shadow-xl);
  max-width: 90vw;
  width: 100%;
  max-width: 480px;
  transform: scale(0.9) translateY(20px);
  transition: all var(--transition-base);
  text-align: center;
  position: relative;
  overflow: hidden;
}

.upgrade-overlay.active .upgrade-modal {
  transform: scale(1) translateY(0);
}

.upgrade-modal::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  height: 4px;
  background: var(--gradient-primary);
}

.upgrade-header {
  margin-bottom: var(--spacing-xl);
}

.upgrade-icon {
  font-size: var(--font-size-4xl);
  margin-bottom: var(--spacing-md);
  display: block;
  filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.1));
}

.upgrade-title {
  font-family: var(--font-secondary);
  font-size: var(--font-size-2xl);
  font-weight: 700;
  color: var(--color-navy);
  margin: 0 0 var(--spacing-sm) 0;
  letter-spacing: -0.01em;
}

.upgrade-subtitle {
  color: var(--color-gray);
  font-size: var(--font-size-base);
  margin: 0 0 var(--spacing-xl) 0;
  line-height: 1.5;
}

.upgrade-benefits {
  background: var(--color-off-white);
  border-radius: var(--radius-lg);
  padding: var(--spacing-xl);
  margin-bottom: var(--spacing-xl);
  text-align: left;
}

.benefit-item {
  display: flex;
  align-items: center;
  margin-bottom: var(--spacing-md);
  font-size: var(--font-size-sm);
  font-weight: 500;
  color: var(--color-navy);
}

.benefit-item:last-child {
  margin-bottom: 0;
}

.benefit-icon {
  width: 24px;
  height: 24px;
  background: var(--gradient-primary);
  border-radius: var(--radius-full);
  display: flex;
  align-items: center;
  justify-content: center;
  margin-right: var(--spacing-sm);
  flex-shrink: 0;
  font-size: var(--font-size-xs);
  color: var(--color-white);
}

.benefit-text {
  flex: 1;
  line-height: 1.4;
}

.upgrade-pricing {
  margin-bottom: var(--spacing-xl);
}

.price-tag {
  display: inline-flex;
  align-items: baseline;
  gap: 2px;
  background: var(--gradient-primary);
  color: var(--color-white);
  padding: var(--spacing-sm) var(--spacing-lg);
  border-radius: var(--radius-full);
  font-weight: 700;
  box-shadow: var(--shadow-colored);
}

.currency {
  font-size: var(--font-size-sm);
}

.amount {
  font-size: var(--font-size-2xl);
  font-family: var(--font-secondary);
}

.period {
  font-size: var(--font-size-sm);
  opacity: 0.9;
}

.upgrade-buttons {
  display: flex;
  flex-direction: column;
  gap: var(--spacing-md);
}

.upgrade-btn {
  padding: var(--spacing-md) var(--spacing-xl);
  border: none;
  border-radius: var(--radius-lg);
  font-size: var(--font-size-base);
  font-weight: 600;
  cursor: pointer;
  transition: all var(--transition-base);
  font-family: var(--font-primary);
  position: relative;
  overflow: hidden;
}

.upgrade-btn.primary {
  background: var(--gradient-primary);
  color: var(--color-white);
  box-shadow: var(--shadow-colored);
}

.upgrade-btn.primary:hover {
  transform: translateY(-2px);
  box-shadow: var(--shadow-xl);
}

.upgrade-btn.primary:disabled {
  opacity: 0.7;
  cursor: not-allowed;
  transform: none;
}

.upgrade-btn.secondary {
  background: var(--color-white);
  color: var(--color-gray);
  border: 2px solid var(--color-light-gray);
}

.upgrade-btn.secondary:hover {
  border-color: var(--color-teal);
  color: var(--color-teal);
  transform: translateY(-1px);
}

/* Voice play button in chat */
    .voice-play-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      margin-left: 8px;
      border-radius: 50%;
      transition: background-color 0.2s;
      font-size: 16px;
      color: var(--color-teal);
    }

    .voice-play-btn:hover {
      background-color: rgba(20, 184, 166, 0.1);
      transform: scale(1.1);
    }

    .voice-play-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .voice-play-btn.playing {
      color: var(--color-coral);
      animation: pulse 1s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    .voice-play-btn.loading {
      color: var(--color-gray);
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

@media (max-width: 768px) {
  .upgrade-modal {
    margin: var(--spacing-lg);
    padding: var(--spacing-2xl);
    max-width: none;
  }
  
  .upgrade-title {
    font-size: var(--font-size-xl);
  }
}

/* Typewriter effect styles */
.typewriter-char {
  display: inline;
  transition: opacity 0.3s ease-out;
}

/* Smooth text appearance */
.typing-text span {
  animation: fadeInChar 0.3s ease-out forwards;
}

@keyframes fadeInChar {
  from {
    opacity: 0;
    transform: translateY(2px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

    /* Hide the name field in Netlify Identity widget */
    .netlify-identity-widget input[name="name"],
    .netlify-identity-widget input[placeholder="Optional"],
    .netlify-identity-widget .formGroup:first-child {
      display: none !important;
    }

  </style>

  <!-- Netlify Identity Widget -->
  <script src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>

<!-- Stripe.js for upgrade functionality -->
<script src="https://js.stripe.com/v3/"></script>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      const netlifyIdentity = window.netlifyIdentity;
      netlifyIdentity.init({
        namePlaceholder: 'Optional'
      });

      netlifyIdentity.on("init", (user) => {
        if (user) {
          handleLogin(user);
        }
        // Update login buttons immediately after init
        updateLoginButton();
      });

      netlifyIdentity.on("login", (user) => {
        handleLogin(user);
        netlifyIdentity.close();
        // Check for redirect URL after successful login
        handlePostLoginRedirect();
      });

      netlifyIdentity.on("logout", () => {
        clearLocalAuth();
        window.location.href = "/";
      });
    });

    async function handleLogin(user) {
      const email = user.email;
      const uid   = user.id;
      const token = user.token.access_token;

      localStorage.setItem("user_email", email);
      localStorage.setItem("user_token", token);
      localStorage.setItem("user_uid", uid);
      window.isRegistered = true;

      console.log("ðŸ” DEBUG: handleLogin â†’ verstuur Webhook1:", {
        user_email: email,
        user_uid: uid,
        user_token: token
      });

      try {
        const res = await fetch(
          "https://hook.eu2.make.com/03ug6qzucda4ksrkcc06nu3bu3vetj15",
          {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
              user_email: email,
              user_uid: uid,
              user_token: token
            })
          }
        );

        console.log("ðŸ” DEBUG: Response status:", res.status, res.statusText);

        if (!res.ok) {
          console.error("âŒ Registration webhook failed:", res.status, res.statusText);
          return;
        }

        const data = await res.json();
        console.log("ðŸ” DEBUG: Registration response:", data);
        console.log("ðŸ” DEBUG: All response keys:", Object.keys(data));

        // Zoek user_id in verschillende mogelijke velden - EXPLICIT LOGGING
        console.log("ðŸ” DEBUG: data.user_id =", data.user_id);
        console.log("ðŸ” DEBUG: data.User_ID =", data.User_ID);
        console.log("ðŸ” DEBUG: data.id =", data.id);
        console.log("ðŸ” DEBUG: data.record_id =", data.record_id);

        const userId = data.user_id || data.User_ID || data.id || data.record_id;
        console.log("ðŸ” DEBUG: Final userId =", userId, "(type:", typeof userId, ")");
        
        if (userId && userId !== "" && userId !== null && userId !== "null") {
          const userIdString = String(userId);
          localStorage.setItem("user_id", userIdString);
          console.log("âœ… DEBUG: Successfully saved user_id:", userIdString);
          
          // Verify localStorage
          const savedUserId = localStorage.getItem("user_id");
          console.log("ðŸ” DEBUG: Verified localStorage user_id:", savedUserId);
          
          // Call fetchHistory if conditions are met
          if (currentCharacter && 
              (document.readyState === "interactive" || document.readyState === "complete")) {
            console.log("ðŸ”„ DEBUG: Calling fetchHistory after user_id is saved...");
            setTimeout(() => {
              fetchHistory();
            }, 500); // Small delay to ensure localStorage is saved
          }
        } else {
          console.warn("âš ï¸ DEBUG: No valid user_id found in response. UserId value:", userId);
          console.warn("âš ï¸ DEBUG: Full response data:", JSON.stringify(data, null, 2));
        }
      } catch (err) {
        console.error("âŒ DEBUG: Error in registration-webhook call:", err);
      }

      updateLoginButton();
    }

    function handlePostLoginRedirect() {
      // Get the stored redirect URL
      const redirectUrl = localStorage.getItem('login_redirect_url');
      
      if (redirectUrl) {
        // Clear the stored redirect URL
        localStorage.removeItem('login_redirect_url');
        
        // Redirect immediately without showing profile page
        setTimeout(() => {
          window.location.href = redirectUrl;
        }, 100); // Very short delay to ensure login is fully processed
      }
    }

    function clearLocalAuth() {
      localStorage.removeItem("user_email");
      localStorage.removeItem("user_token");
      localStorage.removeItem("user_uid");
      localStorage.removeItem("user_id");
      window.isRegistered = false;
    }

    function isMobileDevice() {
      return window.innerWidth <= 768 || /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
  </script>
</head>

<body>
  <!-- Custom Notification System -->
  <div class="notification-overlay" id="notificationOverlay">
    <div class="notification-modal">
      <span class="notification-icon" id="notificationIcon">âœ“</span>
      <h3 class="notification-title" id="notificationTitle">Success</h3>
      <p class="notification-message" id="notificationMessage">Operation completed successfully!</p>
      <div class="notification-buttons" id="notificationButtons">
        <button class="notification-btn primary" id="notificationOkBtn">OK</button>
      </div>
    </div>
  </div>

  <!-- Rating System Modal -->
  <div class="rating-overlay" id="ratingOverlay">
    <div class="rating-modal">
      <div class="rating-header">
        <h3 class="rating-title">How was your conversation?</h3>
        <p class="rating-subtitle">Your feedback helps us improve the experience</p>
      </div>
      
      <div class="rating-stars" id="ratingStars">
        <span class="rating-star" data-rating="1">â˜…</span>
        <span class="rating-star" data-rating="2">â˜…</span>
        <span class="rating-star" data-rating="3">â˜…</span>
        <span class="rating-star" data-rating="4">â˜…</span>
        <span class="rating-star" data-rating="5">â˜…</span>
      </div>
      
      <div class="rating-feedback">
        <label class="rating-feedback-label" for="ratingFeedback">Any additional feedback? (optional)</label>
        <textarea 
          class="rating-feedback-input" 
          id="ratingFeedback" 
          placeholder="Tell us what you think..."
        ></textarea>
      </div>
      
      <div class="rating-actions">
        <button class="rating-btn rating-btn-skip" onclick="skipRating()">Skip</button>
        <button class="rating-btn rating-btn-submit" id="submitRatingBtn" onclick="submitRating()" disabled>Submit</button>
      </div>
    </div>
  </div>

  <!-- Header -->
  <header class="header" role="banner">
    <div class="header-container">
      <div class="header-content">
        <!-- Logo -->
        <a href="index.html" class="logo" aria-label="Narrin AI Home">Narrin AI</a>

        <!-- Desktop Navigation Center -->
        <nav class="nav-center" role="navigation" aria-label="Main navigation">
          <!-- USPs - Random Display -->
          <div class="nav-usps" aria-label="Key features">
            <div class="usp-item" data-usp="voice" style="display: none;">
              <span class="usp-icon" aria-hidden="true">â–¶ï¸</span>
              <span>Voice Chat</span>
            </div>
            <div class="usp-item" data-usp="memory" style="display: none;">
              <span class="usp-icon" aria-hidden="true">ðŸ§ </span>
              <span>Character Memory</span>
            </div>
            <div class="usp-item" data-usp="private" style="display: none;">
              <span class="usp-icon" aria-hidden="true">ðŸ”</span>
              <span>Private Data</span>
            </div>
          </div>

          <!-- Search Bar - Always visible on desktop -->
          <form class="nav-search" role="search">
            <input 
              type="search" 
              class="nav-search-input" 
              placeholder="Find your companion..." 
              aria-label="Search characters"
            />
            <button type="submit" class="search-submit" aria-label="Submit search">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="11" cy="11" r="8"></circle>
                <path d="m21 21-4.35-4.35"></path>
              </svg>
            </button>
          </form>
        </nav>

        <!-- Desktop Navigation Links -->
        <nav class="nav-links" role="navigation" aria-label="Secondary navigation">
          <a href="index.html" class="nav-link">Characters</a>
          <a href="chat-overview.html" class="nav-link">Chats</a>
          <a href="profile.html" class="nav-link" id="loginBtn">Login/Register</a>
          <a href="create-character.html" class="btn btn-primary">âœ¨ Create Character</a>
        </nav>

        <!-- Mobile Navigation Container -->
        <div class="mobile-nav-container">
          <!-- Mobile Chat Button -->
          <a 
            href="chat-overview.html" 
            class="mobile-chat-btn"
            aria-label="Go to chats"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
            </svg>
          </a>

          <!-- Mobile Search Button -->
          <button 
            class="mobile-search-btn" 
            id="mobileSearchBtn"
            aria-label="Open search"
            aria-expanded="false"
          >
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="11" cy="11" r="8"></circle>
              <path d="m21 21-4.35-4.35"></path>
            </svg>
          </button>

          <!-- Mobile Hamburger Menu -->
          <button
            class="mobile-menu-btn"
            id="mobileMenuBtn"
            aria-label="Open navigation menu"
            aria-expanded="false"
          >
            <div class="hamburger">
              <span></span>
              <span></span>
              <span></span>
            </div>
          </button>
        </div>
      </div>
    </div>

    <!-- Mobile Search Overlay -->
    <div class="mobile-search-overlay" id="mobileSearchOverlay">
      <form class="mobile-search-form" role="search">
        <input 
          type="search" 
          class="mobile-search-input" 
          placeholder="Find your companion..." 
          aria-label="Search characters"
          id="mobileSearchInput"
        />
        <button type="submit" class="btn btn-primary" aria-label="Submit search">
          Search
        </button>
      </form>
    </div>
  </header>

  <!-- Mobile Menu Overlay -->
  <div class="mobile-menu-overlay" id="mobileMenuOverlay">
    <div class="mobile-menu-content">
      <div class="mobile-menu-header">
        <div class="mobile-menu-logo">Narrin AI</div>
        <div class="mobile-menu-subtitle">AI Character Chat</div>
      </div>
      <nav class="mobile-menu-nav" role="navigation" aria-label="Mobile navigation">
        <a href="index.html" class="mobile-menu-link">
          <span class="mobile-menu-link-icon">ðŸ </span>
          Characters
        </a>
        <a href="chat-overview.html" class="mobile-menu-link">
          <span class="mobile-menu-link-icon">ðŸ’¬</span>
          Chats
        </a>
        <a href="profile.html" class="mobile-menu-link" id="mobileLoginBtn">
          <span class="mobile-menu-link-icon">ðŸ‘¤</span>
          Login/Register
        </a>
        <a href="create-character.html" class="mobile-menu-link btn-primary">
          <span class="mobile-menu-link-icon">âœ¨</span>
          Create Character
        </a>
      </nav>
    </div>
  </div>

  <div class="container">
    <div id="loadingState" class="loading-state">
      <h3>Getting ready to meet you...</h3>
      <p>I'm taking a moment to prepare myself for our conversation. Just like you might before meeting someone special.</p>
    </div>

    <div id="errorState" class="error-state" style="display: none;">
      <h3>We're here to help</h3>
      <p>It seems we can't find the character you're looking for. Don't worry - there are many other supportive companions waiting to connect with you.</p>
      <a href="create-character.html">Create a new companion</a> or <a href="/">explore other characters</a>
    </div>

    <div id="chatInterface" style="display: none;">
      <div class="page-header">
        <h1>Chat With Your AI Companion</h1>
        <p>Every conversation unlocks new possibilities on your path to becoming who you're meant to be.</p>
      </div>

      <div class="character-section">
        <div class="character-header" id="characterHeader">
          <div class="character-avatar" id="characterAvatar">ðŸ‘¤</div>
          <div class="character-info">
            <h2 id="characterName">Connecting...</h2>
            <p id="characterTitle"></p>
          </div>
        </div>
      </div>

      <div class="chat-section">
        <div id="chatlog"></div>
        <div class="input-group">
          <input id="userInput" type="text" placeholder="Share what's on your mind..." />
          <button onclick="handleSendClick(event)" id="sendButton">Send</button>
        </div>
        <div class="disclaimer">
          <span class="disclaimer-icon">âš ï¸</span>
          <span class="disclaimer-main-text"><strong>â„¹ï¸</strong> You are chatting with an AI character. This is not a real person and does not provide professional advice.</span>
          <button class="disclaimer-toggle" id="disclaimerToggle" aria-label="Show more information">
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path d="M3 4.5L6 7.5L9 4.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
            </svg>
          </button>
          <div class="disclaimer-expanded" id="disclaimerExpanded" style="display: none;">
            AI characters cannot provide professional advice. For medical, legal, financial, or mental health concerns, always consult licensed professionals. 
            Never make important decisions based on AI responses. You are 100% responsible for your own decisions and actions.
            AI responses may contain errors or inappropriate content. Use at your own risk.
            Read our <a href="privacy-policy.html" class="disclaimer-link">privacy policy</a> and <a href="terms-and-conditions.html" class="disclaimer-link">terms and conditions</a> for full details.
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Navigation and Chat Scripts -->
  <script>
    // ===== CUSTOM NOTIFICATION SYSTEM =====
    function showNotification(type, title, message, buttons = null) {
      const overlay = document.getElementById('notificationOverlay');
      const icon = document.getElementById('notificationIcon');
      const titleEl = document.getElementById('notificationTitle');
      const messageEl = document.getElementById('notificationMessage');
      const buttonsEl = document.getElementById('notificationButtons');
      
      // Set icon based on type
      const icons = {
        success: 'âœ…',
        error: 'âŒ',
        warning: 'âš ï¸',
        info: 'â„¹ï¸',
        question: 'â“'
      };
      
      icon.textContent = icons[type] || icons.info;
      icon.className = `notification-icon ${type}`;
      titleEl.textContent = title;
      messageEl.textContent = message;
      
      // Set up buttons
      if (buttons) {
        buttonsEl.innerHTML = '';
        buttons.forEach(button => {
          const btn = document.createElement('button');
          btn.className = `notification-btn ${button.type || 'secondary'}`;
          btn.textContent = button.text;
          btn.onclick = () => {
            hideNotification();
            if (button.callback) button.callback();
          };
          buttonsEl.appendChild(btn);
        });
      } else {
        // Default OK button
        buttonsEl.innerHTML = '<button class="notification-btn primary" onclick="hideNotification()">OK</button>';
      }
      
      // Show notification
      overlay.classList.add('active');
      document.body.style.overflow = 'hidden';
    }
    
    function hideNotification() {
      const overlay = document.getElementById('notificationOverlay');
      overlay.classList.remove('active');
      document.body.style.overflow = '';
    }
    
    // Custom alert replacement
    function customAlert(message, title = 'We\'re Here for You') {
      showNotification('info', title, message);
    }
    
    // Success notification
    function showSuccess(message, title = 'Wonderful!') {
      showNotification('success', title, message);
    }
    
    // Error notification
    function showError(message, title = 'We\'re Here to Help') {
      showNotification('error', title, message);
    }
    
    // Warning notification
    function showWarning(message, title = 'Just a Moment') {
      showNotification('warning', title, message);
    }

    // ===== NAVIGATION FUNCTIONALITY =====
    
    // Mobile Search Elements
    const mobileSearchBtn = document.getElementById('mobileSearchBtn');
    const mobileSearchOverlay = document.getElementById('mobileSearchOverlay');
    const mobileSearchInput = document.getElementById('mobileSearchInput');
    
    // Mobile Menu Elements
    const mobileMenuBtn = document.getElementById('mobileMenuBtn');
    const mobileMenuOverlay = document.getElementById('mobileMenuOverlay');
    
    // USP Carousel Elements
    const uspTrack = document.getElementById('uspTrack');
    let currentUspIndex = 0;
    let uspInterval;

    // ===== MOBILE SEARCH FUNCTIONALITY =====
    function toggleMobileSearch() {
      const isActive = mobileSearchOverlay.classList.contains('active');
      
      if (isActive) {
        mobileSearchOverlay.classList.remove('active');
        mobileSearchBtn.setAttribute('aria-expanded', 'false');
      } else {
        // Close mobile menu if open
        closeMobileMenu();
        
        mobileSearchOverlay.classList.add('active');
        mobileSearchBtn.setAttribute('aria-expanded', 'true');
        mobileSearchInput.focus();
      }
    }

    mobileSearchBtn?.addEventListener('click', toggleMobileSearch);

    // ===== MOBILE MENU FUNCTIONALITY =====
    function toggleMobileMenu() {
      const isActive = mobileMenuOverlay.classList.contains('active');
      
      if (isActive) {
        closeMobileMenu();
      } else {
        openMobileMenu();
      }
    }

    function openMobileMenu() {
      // Close search overlay if open
      if (mobileSearchOverlay.classList.contains('active')) {
        mobileSearchOverlay.classList.remove('active');
        mobileSearchBtn.setAttribute('aria-expanded', 'false');
      }
      
      mobileMenuOverlay.classList.add('active');
      mobileMenuBtn.classList.add('active');
      mobileMenuBtn.setAttribute('aria-expanded', 'true');
      
      // Prevent body scroll
      document.body.style.overflow = 'hidden';
    }

    function closeMobileMenu() {
      mobileMenuOverlay.classList.remove('active');
      mobileMenuBtn.classList.remove('active');
      mobileMenuBtn.setAttribute('aria-expanded', 'false');
      
      // Restore body scroll
      document.body.style.overflow = '';
    }

    mobileMenuBtn?.addEventListener('click', toggleMobileMenu);

    // Close menu when clicking on overlay background
    mobileMenuOverlay?.addEventListener('click', (e) => {
      if (e.target === mobileMenuOverlay) {
        closeMobileMenu();
      }
    });

    // Close menu when clicking on a menu item
    document.querySelectorAll('.mobile-menu-link').forEach(link => {
      link.addEventListener('click', closeMobileMenu);
    });

    // Close search and menu on outside click
    document.addEventListener('click', (e) => {
      // Close search overlay
      if (!mobileSearchOverlay?.contains(e.target) &&
          !mobileSearchBtn?.contains(e.target) &&
          mobileSearchOverlay?.classList.contains('active')) {
        mobileSearchOverlay.classList.remove('active');
        mobileSearchBtn.setAttribute('aria-expanded', 'false');
      }
    });

    // Close menu on escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (mobileMenuOverlay.classList.contains('active')) {
          closeMobileMenu();
        }
        if (mobileSearchOverlay.classList.contains('active')) {
          mobileSearchOverlay.classList.remove('active');
          mobileSearchBtn.setAttribute('aria-expanded', 'false');
        }
      }
    });

    // ===== USP CAROUSEL FUNCTIONALITY =====
    function startUspCarousel() {
      if (window.innerWidth <= 768 && uspTrack) {
        uspInterval = setInterval(() => {
          currentUspIndex = (currentUspIndex + 1) % 3;
          uspTrack.style.transform = `translateY(-${currentUspIndex * 33.333}%)`;
        }, 3000);
      }
    }

    function stopUspCarousel() {
      if (uspInterval) {
        clearInterval(uspInterval);
        uspInterval = null;
      }
    }

    // Handle responsive behavior
    function handleResize() {
      if (window.innerWidth > 768) {
        stopUspCarousel();
        if (uspTrack) {
          uspTrack.style.transform = '';
        }
        if (mobileSearchOverlay?.classList.contains('active')) {
          mobileSearchOverlay.classList.remove('active');
          mobileSearchBtn?.setAttribute('aria-expanded', 'false');
        }
        if (mobileMenuOverlay?.classList.contains('active')) {
          closeMobileMenu();
        }
      } else {
        startUspCarousel();
      }
    }

    // Initialize on load
    window.addEventListener('load', () => {
      handleResize();
    });

    // Handle window resize
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(handleResize, 250);
    });

    // ===== SEARCH FUNCTIONALITY =====
    function handleSearch(searchTerm) {
      if (!searchTerm || !searchTerm.trim()) {
        console.log('Empty search term, ignoring');
        return;
      }
      
      const trimmedTerm = searchTerm.trim();
      console.log('Redirecting to search results for:', trimmedTerm);
      window.location.href = `search-results.html?q=${encodeURIComponent(trimmedTerm)}`;
    }

    // Desktop search
    document.querySelector('.nav-search')?.addEventListener('submit', (e) => {
      e.preventDefault();
      const searchInput = e.target.querySelector('.nav-search-input');
      handleSearch(searchInput.value);
    });

    // Mobile search
    document.querySelector('.mobile-search-form')?.addEventListener('submit', (e) => {
      e.preventDefault();
      const searchInput = e.target.querySelector('.mobile-search-input');
      handleSearch(searchInput.value);
      toggleMobileSearch();
    });

    // ===== NETLIFY IDENTITY BUTTON UPDATES =====
    function updateLoginButton() {
      const loginBtn = document.getElementById('loginBtn');
      const mobileLoginBtn = document.getElementById('mobileLoginBtn');
      
      // Check both Netlify Identity and local storage for user info
      const netlifyUser = window.netlifyIdentity && window.netlifyIdentity.currentUser();
      const localEmail = localStorage.getItem("user_email");
      const localToken = localStorage.getItem("user_token");
      
      const isLoggedIn = netlifyUser || (localEmail && localToken);
      
      if (isLoggedIn) {
        // Always show "Profile" for logged in users instead of their name
        
        // Update desktop button
        if (loginBtn) {
          loginBtn.textContent = 'Profile';
          loginBtn.href = 'profile.html';
        }
        
        // Update mobile button
        if (mobileLoginBtn) {
          const icon = mobileLoginBtn.querySelector('.mobile-menu-link-icon');
          mobileLoginBtn.innerHTML = `${icon ? icon.outerHTML : '<span class="mobile-menu-link-icon">ðŸ‘¤</span>'}Profile`;
          mobileLoginBtn.href = 'profile.html';
        }
      } else {
        // User is not logged in
        if (loginBtn) {
          loginBtn.textContent = 'Login/Register';
          loginBtn.href = 'profile.html';
        }
        if (mobileLoginBtn) {
          const icon = mobileLoginBtn.querySelector('.mobile-menu-link-icon');
          mobileLoginBtn.innerHTML = `${icon ? icon.outerHTML : '<span class="mobile-menu-link-icon">ðŸ‘¤</span>'}Login/Register`;
          mobileLoginBtn.href = 'profile.html';
        }
      }
    }

    // Enhanced click handler for navigation links
    function setupNavigationClickHandlers() {
      const loginBtn = document.getElementById('loginBtn');
      const mobileLoginBtn = document.getElementById('mobileLoginBtn');
      
      // Desktop login button click handler
      if (loginBtn) {
        loginBtn.addEventListener('click', (e) => {
          e.preventDefault();
          
          const netlifyUser = window.netlifyIdentity && window.netlifyIdentity.currentUser();
          const localEmail = localStorage.getItem("user_email");
          const localToken = localStorage.getItem("user_token");
          const isLoggedIn = netlifyUser || (localEmail && localToken);
          
          if (isLoggedIn) {
            // User is logged in, go directly to profile page
            window.location.href = 'profile.html';
          } else {
            // User not logged in, store current page for redirect and open login
            localStorage.setItem('login_redirect_url', window.location.href);
            openLogin();
          }
        });
      }
      
      // Mobile login button click handler
      if (mobileLoginBtn) {
        mobileLoginBtn.addEventListener('click', (e) => {
          e.preventDefault();
          
          const netlifyUser = window.netlifyIdentity && window.netlifyIdentity.currentUser();
          const localEmail = localStorage.getItem("user_email");
          const localToken = localStorage.getItem("user_token");
          const isLoggedIn = netlifyUser || (localEmail && localToken);
          
          if (isLoggedIn) {
            // User is logged in, go directly to profile page
            window.location.href = 'profile.html';
          } else {
            // User not logged in, store current page for redirect and open login
            localStorage.setItem('login_redirect_url', window.location.href);
            openLogin();
          }
          
          // Close mobile menu after click
          closeMobileMenu();
        });
      }
    }

    // Function to open login modal
    function openLogin() {
      if (window.netlifyIdentity) {
        window.netlifyIdentity.open('login');
      } else {
        // Fallback if Netlify Identity is not available
        window.location.href = 'profile.html';
      }
    }

    // Initialize login button on page load
document.addEventListener('DOMContentLoaded', () => {
  // Check upgrade status
  checkUpgradeStatus();
  
  // Update immediately on page load
  updateLoginButton();
      
      // Set up click handlers
      setupNavigationClickHandlers();
      
      // Show random USP (including Highly Accurate and 100% Private for chat.html)
      const uspItems = document.querySelectorAll('.usp-item');
      if (uspItems.length > 0) {
        // Hide all USPs first
        uspItems.forEach(item => item.style.display = 'none');
        
        // Show a random one
        const randomIndex = Math.floor(Math.random() * uspItems.length);
        uspItems[randomIndex].style.display = 'flex';
      }
      
      if (window.netlifyIdentity) {
        window.netlifyIdentity.on('init', user => {
          updateLoginButton();
        });

        window.netlifyIdentity.on('login', user => {
          updateLoginButton();
          window.netlifyIdentity.close();
        });

        window.netlifyIdentity.on('logout', () => {
          updateLoginButton();
        });
      }
    });

    // ===== CHARACTER LOADING & SETUP =====
    let currentCharacter = null;
    let characterSlug = null;
    
    // ===== VOICE SYSTEM (VEILIG VIA NETLIFY FUNCTIONS) =====
    let currentAudio = null;
    let isPlayingAudio = false;

    // Voice ID validatie en fallback
    function validateAndFixVoiceId(voiceId) {
      // Bekende geldige voice IDs uit de voice library
      const validVoiceIds = [
        'iP95p4HMsOdaJ6J8s72v', 'TxGEqnHWrfWFTfGW9XjX', 'VR6AewLTigWG4xSOukaG', 
        'pqHfZKP75CvOlQylNhV4', 'yoZ06aMxZJJ28mfd3POQ', 'EXAVITQu4vr4xnSDxMaL',
        'XrExE9yKIg1WjnnlVkGX', 'oWAxZDx7w5VEj9dCyTzz', 'pFZP5JQG7iQjIQuC4Bku',
        'XB0fDUnXU5powFXDhCwa', 'onwK4e9ZLuTAKqWW03F9', 'fvcBHKa2lxguQE5lB4uV',
        'p3yi6sku4VQJg3uH6i6D', 'W8ouBcjTunaMJLYU2BvB', 'SyTRiCoyqTeFEk9z5HVW',
        'wdGYtWKVlLmwTxGswfYd', 'SAhaRsW91OuPlKeINYop', 'by3rQdWs4XjziQwJ2sTL',
        'qEN0DupmmmaueYJ8Eaz8', '21m00Tcm4TlvDq8ikWAM', 'pNInz6ObpgDQGcFmaJgB',
        'AZnzlk1XvdvUeBnXmlld', 'CYw3kZ02Hs0563khs1Fj', 'D38z5RcWu1voky8WS1ja'
      ];
      
      // Bekende ongeldige voice IDs die vervangen moeten worden
      const invalidVoiceIds = {
        'uH01NDVLLmf6SaxfTd': '21m00Tcm4TlvDq8ikWAM' // Rachel - standaard ElevenLabs voice
      };
      
      // Check voor bekende ongeldige IDs
      if (invalidVoiceIds[voiceId]) {
        console.log(`ðŸ”„ Replacing invalid voice ID ${voiceId} with ${invalidVoiceIds[voiceId]}`);
        return invalidVoiceIds[voiceId];
      }
      
      // Check of voice ID geldig format heeft (ElevenLabs voice IDs zijn alfanumeriek)
      const validFormat = /^[a-zA-Z0-9]{20,22}$/;
      if (!voiceId || voiceId === null || voiceId === 'null' || typeof voiceId !== 'string' || !validFormat.test(voiceId)) {
        console.log(`ðŸ”„ Invalid voice ID format: "${voiceId}", using fallback`);
        return null; // Return null instead of fallback to disable TTS
      }
      
      // Als voice ID niet bekend is, return null to disable TTS
      if (!validVoiceIds.includes(voiceId)) {
        console.log(`âš ï¸ Unknown voice ID: ${voiceId}, disabling TTS`);
        return null; // Return null to disable TTS completely
      }
      
      // Return original als het valid lijkt
      return voiceId;
    }

    // VEILIGE TTS functie via Netlify Function
    window.generateSpeech = async function(text, voiceId) {
      try {
        // Valideer en corrigeer voice ID indien nodig
        const validVoiceId = validateAndFixVoiceId(voiceId);
        console.log('ðŸ“¢ Calling TTS with:', { text: text.substring(0, 50) + '...', original: voiceId, validated: validVoiceId });
        
        // If voice ID is invalid, throw error
        if (!validVoiceId) {
          throw new Error('No valid voice ID available for this character');
        }
        
        const response = await fetch('/.netlify/functions/tts-simple', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text: text,
            voice_id: validVoiceId
          })
        });
        
        console.log('ðŸ“¢ TTS response:', response.status, response.statusText);

        if (!response.ok) {
          // Try to get more detailed error information
          let errorDetails = '';
          try {
            const errorData = await response.json();
            errorDetails = errorData.details || errorData.error || '';
            console.error('âŒ TTS API Error Details:', errorData);
          } catch (e) {
            errorDetails = await response.text();
          }
          throw new Error(`TTS request failed: ${response.status} - ${errorDetails}`);
        }

        const data = await response.json();
        
        if (!data.success) {
          console.error('âŒ TTS API returned success=false:', data);
          throw new Error(data.error || 'TTS generation failed');
        }

        // Convert base64 to blob
        const audioBytes = atob(data.audio);
        const audioArray = new Uint8Array(audioBytes.length);
        for (let i = 0; i < audioBytes.length; i++) {
          audioArray[i] = audioBytes.charCodeAt(i);
        }
        
        return new Blob([audioArray], { type: 'audio/mpeg' });

      } catch (error) {
        console.error('TTS Error:', error);
        throw error;
      }
    }

    // Voice cache voor snellere gesprekken
    const voiceCache = new Map();
    
    // Voice usage limit constants
    const VOICE_LIMIT_FREE = 3;
    const VOICE_STORAGE_KEY = 'voice_usage_count';
    const VOICE_RESET_KEY = 'voice_usage_reset_date';
    
    // Generate conversation starter based on character
    function generateConversationStarter() {
      if (!currentCharacter) return null;
      
      // Default starters that can be customized per character type
      const starters = {
        // Friendly, warm characters
        friendly: [
          "I've been thinking about something interesting today - what's the most unexpected thing that's happened to you recently?",
          "You know what I find fascinating? How everyone has a completely unique story. What's a chapter from yours you'd like to share?",
          "I was just wondering - if you could master any skill overnight, what would it be and why?",
          "Here's something I'm curious about: what's been occupying your thoughts lately?",
          "I love meeting new people! Tell me - what's something you're really passionate about right now?"
        ],
        // Professional, helpful characters
        professional: [
          "I've been analyzing some interesting trends lately. What changes have you noticed in your field recently?",
          "Let's dive right in - what's the biggest professional challenge you're tackling right now?",
          "I'm curious about your perspective - what innovation do you think will transform how we work?",
          "Time is valuable, so let's make this count. What's your most pressing priority today?",
          "I believe in getting straight to the point - what goal are you working towards?"
        ],
        // Creative, artistic characters
        creative: [
          "I had the wildest dream last night! It made me wonder - what's the most vivid dream you remember?",
          "You know what's amazing? How a single moment can inspire an entire story. What moment from your life would make a great story?",
          "I'm always collecting inspiration! What's the most beautiful thing you've seen recently?",
          "Here's a fun thought experiment - if your life was a movie, what genre would it be and why?",
          "Colors have such power to evoke emotions. What color represents how you're feeling today?"
        ],
        // Wise, mentor-like characters
        wise: [
          "Life has a way of presenting us with unexpected lessons. What has life been teaching you lately?",
          "I've found that our greatest challenges often hide our greatest opportunities. What challenge are you facing that might be a gift in disguise?",
          "They say wisdom comes from experience. What experience has shaped who you are today?",
          "I sense you came here for a reason. What question has been echoing in your mind?",
          "Every journey begins with a single step. Where are you hoping your path will lead?"
        ],
        // Playful, fun characters
        playful: [
          "Okay, quick! If you had to choose between flying or being invisible, which would it be? I NEED to know!",
          "I just learned the coolest fact - did you know octopuses have three hearts? What's a random fact you know that blows people's minds?",
          "Let's play a game! Tell me three things about yourself - two truths and one lie. I'll try to guess!",
          "If you could have dinner with any three people, living or dead, who would make your guest list?",
          "Here's a fun one - what's your most unusual talent or the weirdest thing you're good at?"
        ],
        // Default fallback
        default: [
          "I've been looking forward to our conversation! What's been the highlight of your week so far?",
          "You know, every person I meet has something unique about them. What makes you, you?",
          "I'm genuinely curious - what brought you here today? Sometimes the universe has interesting timing.",
          "Let's skip the small talk - what's really on your mind right now?",
          "I find that the best conversations start with curiosity. What are you most curious about these days?"
        ]
      };
      
      // Determine character type based on title/description
      let characterType = 'default';
      const lowerTitle = (currentCharacter.character_title || '').toLowerCase();
      const lowerDesc = (currentCharacter.description || '').toLowerCase();
      
      if (lowerTitle.includes('friend') || lowerTitle.includes('companion') || lowerDesc.includes('friendly')) {
        characterType = 'friendly';
      } else if (lowerTitle.includes('coach') || lowerTitle.includes('mentor') || lowerTitle.includes('teacher')) {
        characterType = 'wise';
      } else if (lowerTitle.includes('artist') || lowerTitle.includes('creative') || lowerTitle.includes('designer')) {
        characterType = 'creative';
      } else if (lowerTitle.includes('assistant') || lowerTitle.includes('helper') || lowerTitle.includes('expert')) {
        characterType = 'professional';
      } else if (lowerTitle.includes('fun') || lowerTitle.includes('play') || lowerDesc.includes('playful')) {
        characterType = 'playful';
      }
      
      // Pick a random starter from the appropriate category
      const categoryStarters = starters[characterType];
      const starter = categoryStarters[Math.floor(Math.random() * categoryStarters.length)];
      
      return starter;
    }
    
    // Load chat history function
    async function loadChatHistory() {
      try {
        const token = localStorage.getItem("user_token");
        const uid = localStorage.getItem("user_uid");
        const email = localStorage.getItem("user_email");
        
        if (!token || !uid || !email || !characterSlug) {
          console.log('âš ï¸ Missing credentials for loading chat history');
          // Show conversation starter when not logged in
          showConversationStarter();
          return;
        }
        
        console.log('ðŸ“š Loading chat history...');
        
        const response = await fetch('/.netlify/functions/get-chat-history', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_email: email,
            user_uid: uid,
            user_token: token,
            char: characterSlug
          })
        });
        
        if (!response.ok) {
          console.warn('âš ï¸ Could not load chat history');
          // Clear chatlog before showing starter
          const chatlog = document.getElementById("chatlog");
          chatlog.innerHTML = '';
          // Show conversation starter for new chat
          showConversationStarter();
          return;
        }
        
        const data = await response.json();
        
        if (data.success && data.history && data.history.length > 0) {
          console.log(`âœ… Loaded ${data.history.length} messages from history`);
          
          const chatlog = document.getElementById("chatlog");
          chatlog.innerHTML = ''; // Clear existing messages
          
          // Display all messages from history
          data.history.forEach(msg => {
            // Filter out memory context messages
            if (msg.message && (
              msg.message.includes('Previous conversations and important information') ||
              msg.message.includes('Vorige gesprekken en belangrijke informatie:') ||
              msg.message.includes('[Belangrijk geheugen (') ||
              msg.message.includes('[INSTRUCTION: Always respond in English by default') ||
              msg.message.includes('Use this information to respond personally') ||
              msg.message.includes('Gebruik deze informatie om persoonlijk te antwoorden') ||
              msg.message.includes('BELANGRIJK: Varieer je antwoorden') ||
              msg.message.includes('IMPORTANT: Keep your responses natural') ||
              msg.message.includes('begin NIET elke zin met dezelfde woorden') ||
              msg.message.includes('Vorige gesprekken en bel') || // Partial match
              msg.message.startsWith('BELANGRIJK:') ||
              msg.message.startsWith('IMPORTANT:') ||
              (msg.message.includes('Varieer') && msg.message.includes('antwoorden')) ||
              // Check if message starts with memory context pattern
              /^\s*\n*Vorige gesprekken/i.test(msg.message) ||
              /^\s*\n*BELANGRIJK:/i.test(msg.message)
            )) {
              console.log('ðŸ§¹ Filtering out memory context from history:', msg.message.substring(0, 50) + '...');
              return; // Skip this message
            }
            
            const p = document.createElement("p");
            
            if (msg.role === 'user') {
              p.innerHTML = `<strong>You:</strong> ${msg.message}`;
            } else {
              const avatarHtml = getAvatarHtml();
              if (currentCharacter.voice_id) {
                p.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> ${msg.message}<br><div style="margin-top: 8px; text-align: left;"><button class="voice-play-btn" onclick="window.playMessageVoice(\`${msg.message.replace(/`/g, '\\`')}\`, '${currentCharacter.voice_id}', this)" title="Hear ${currentCharacter?.name || 'Character'} speak">â–¶ï¸</button></div>`;
              } else {
                p.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> ${msg.message}`;
              }
            }
            
            chatlog.appendChild(p);
          });
          
          chatlog.scrollTop = chatlog.scrollHeight;
        } else {
          console.log('ðŸ“­ No chat history found - showing conversation starter');
          // Clear chatlog before showing starter
          const chatlog = document.getElementById("chatlog");
          chatlog.innerHTML = '';
          // Show conversation starter for new chat
          showConversationStarter();
        }
        
      } catch (error) {
        console.error('âŒ Error loading chat history:', error);
        // Clear chatlog before showing starter
        const chatlog = document.getElementById("chatlog");
        chatlog.innerHTML = '';
        // Show conversation starter on error
        showConversationStarter();
      }
    }
    
    // Show conversation starter
    function showConversationStarter() {
      console.log('ðŸŽ¯ showConversationStarter called');
      console.log('ðŸŽ¯ currentCharacter at showConversationStarter:', currentCharacter);
      
      if (!currentCharacter) {
        console.log('âš ï¸ No currentCharacter available, cannot show starter');
        return;
      }
      
      const starter = generateConversationStarter();
      console.log('ðŸŽ¯ Generated starter:', starter);
      if (!starter) {
        console.log('âš ï¸ No starter generated');
        return;
      }
      
      const chatlog = document.getElementById("chatlog");
      console.log('ðŸŽ¯ Chatlog element:', chatlog);
      
      // Check if a starter message already exists
      if (chatlog.querySelector('.starter-message')) {
        console.log('ðŸ”„ Starter message already exists, skipping');
        return;
      }
      
      const starterMessage = document.createElement("p");
      const avatarHtml = getAvatarHtml();
      
      starterMessage.className = 'starter-message';
      starterMessage.setAttribute('data-starter', 'true');
      starterMessage.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> <span class="typing-text"></span>`;
      
      if (currentCharacter.voice_id) {
        starterMessage.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> <span class="typing-text"></span><br><div style="margin-top: 8px; text-align: left;"><button class="voice-play-btn" onclick="window.playMessageVoice(\`${starter.replace(/`/g, '\\`')}\`, '${currentCharacter.voice_id}', this)" title="Hear ${currentCharacter?.name || 'Character'} speak">â–¶ï¸</button></div>`;
      }
      
      chatlog.appendChild(starterMessage);
      
      // Use typewriter effect for the starter
      const typingSpan = starterMessage.querySelector('.typing-text');
      
      // Add a small delay to ensure the element is rendered
      setTimeout(() => {
        if (currentCharacter.voice_id) {
          typewriterWithVoice(typingSpan, starter, currentCharacter.voice_id);
        } else {
          typewriterEffect(typingSpan, starter);
        }
      }, 100);
      
      chatlog.scrollTop = chatlog.scrollHeight;
      
      // Mark that we've shown the starter
      window.conversationStarterShown = true;
    }
    
    // Check voice usage limit for Free plan users
    function checkVoiceUsageLimit() {
      // Check if user has premium plan
      const isPremium = localStorage.getItem('user_plan') === 'premium' || 
                       localStorage.getItem('user_plan') === 'pro' ||
                       localStorage.getItem('isPremium') === 'true';
      
      if (isPremium) {
        console.log('ðŸ—£ï¸ Premium user - unlimited voice conversations');
        return true;
      }
      
      // Check 30-day voice usage for Free users
      const today = new Date();
      const lastReset = localStorage.getItem(VOICE_RESET_KEY);
      let currentCount = parseInt(localStorage.getItem(VOICE_STORAGE_KEY) || '0');
      
      // Reset counter if 30 days have passed
      if (lastReset) {
        const resetDate = new Date(lastReset);
        const daysSinceReset = Math.floor((today - resetDate) / (1000 * 60 * 60 * 24));
        
        if (daysSinceReset >= 30) {
          currentCount = 0;
          localStorage.setItem(VOICE_STORAGE_KEY, '0');
          localStorage.setItem(VOICE_RESET_KEY, today.toISOString());
        }
      } else {
        // First time - set reset date
        localStorage.setItem(VOICE_RESET_KEY, today.toISOString());
      }
      
      console.log(`ðŸ—£ï¸ Voice conversations: ${currentCount}/${VOICE_LIMIT_FREE} per 30 days (Free plan)`);
      
      if (currentCount >= VOICE_LIMIT_FREE) {
        console.log('ðŸš« Voice usage limit reached for Free plan');
        return false;
      }
      
      // Increment counter
      currentCount++;
      localStorage.setItem(VOICE_STORAGE_KEY, currentCount.toString());
      
      return true;
    }
    
    // Show upgrade modal for voice limit exceeded
    function showVoiceUpgradeModal() {
      const modal = document.createElement('div');
      modal.className = 'voice-upgrade-modal';
      modal.innerHTML = `
        <div class="voice-upgrade-content">
          <div class="voice-upgrade-header">
            <h3>ðŸ—£ï¸ Voice Chat Limit Reached</h3>
            <button class="voice-upgrade-close" onclick="closeVoiceUpgradeModal()">&times;</button>
          </div>
          <div class="voice-upgrade-body">
            <p>You've reached your limit of <strong>3 voice conversations</strong> per 30 days on the Free plan.</p>
            <p>Upgrade to <strong>Premium</strong> for unlimited voice chat and more features!</p>
            <div class="voice-upgrade-benefits">
              <div class="voice-benefit">
                <div class="checkmark"></div>
                <div class="benefit-text">Unlimited Chat Messages</div>
              </div>
              <div class="voice-benefit">
                <div class="checkmark"></div>
                <div class="benefit-text">Unlimited Voice Chat</div>
              </div>
              <div class="voice-benefit">
                <div class="checkmark"></div>
                <div class="benefit-text">Extensive Character Memory</div>
              </div>
              <div class="voice-benefit">
                <div class="checkmark"></div>
                <div class="benefit-text">Early Access to New Features</div>
              </div>
              <div class="voice-benefit">
                <div class="checkmark"></div>
                <div class="benefit-text">Priority Character Access</div>
              </div>
            </div>
          </div>
          <div class="voice-upgrade-buttons">
            <button class="btn-secondary" onclick="closeVoiceUpgradeModal()">Maybe Later</button>
            <button class="btn-primary" onclick="upgradeToPremuim()">Upgrade Now</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Add styles
      const style = document.createElement('style');
      style.textContent = `
        .voice-upgrade-modal {
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0, 0, 0, 0.5);
          display: flex;
          justify-content: center;
          align-items: center;
          z-index: 10000;
        }
        
        .voice-upgrade-content {
          background: white;
          border-radius: 16px;
          max-width: 500px;
          width: 90%;
          max-height: 80vh;
          overflow-y: auto;
          box-shadow: 0 20px 40px rgba(0, 0, 0, 0.2);
        }
        
        .voice-upgrade-header {
          display: flex;
          justify-content: space-between;
          align-items: center;
          padding: 24px 24px 16px;
          border-bottom: 1px solid var(--color-light-gray);
        }
        
        .voice-upgrade-header h3 {
          margin: 0;
          color: var(--color-navy);
          font-size: var(--font-size-xl);
        }
        
        .voice-upgrade-close {
          background: none;
          border: none;
          font-size: 24px;
          cursor: pointer;
          color: var(--color-gray);
          padding: 4px;
        }
        
        .voice-upgrade-close:hover {
          color: var(--color-navy);
        }
        
        .voice-upgrade-body {
          padding: 24px;
        }
        
        .voice-upgrade-body p {
          margin: 0 0 16px 0;
          color: var(--color-gray-dark);
          line-height: 1.6;
        }
        
        .voice-upgrade-benefits {
          background: var(--color-off-white);
          border-radius: 12px;
          padding: 20px;
          margin: 20px 0;
        }
        
        .voice-benefit {
          display: flex;
          align-items: center;
          margin-bottom: 12px;
          padding: 8px 0;
        }
        
        .voice-benefit:last-child {
          margin-bottom: 0;
        }
        
        .checkmark {
          width: 20px;
          height: 20px;
          background: rgba(20, 184, 166, 0.1);
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          margin-right: 12px;
          flex-shrink: 0;
          border: 2px solid var(--color-teal);
        }
        
        .checkmark::after {
          content: 'âœ“';
          color: var(--color-teal);
          font-weight: 800;
          font-size: 12px;
        }
        
        .benefit-text {
          color: var(--color-navy);
          font-size: 14px;
          font-weight: 500;
          font-family: var(--font-primary);
        }
        
        .voice-upgrade-buttons {
          display: flex;
          gap: 12px;
          padding: 16px 24px 24px;
          justify-content: flex-end;
        }
        
        .voice-upgrade-buttons .btn-secondary {
          background: var(--color-light-gray);
          color: var(--color-navy);
          border: none;
          padding: 12px 24px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: 500;
        }
        
        .voice-upgrade-buttons .btn-primary {
          background: var(--gradient-primary);
          color: white;
          border: none;
          padding: 12px 24px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: 500;
        }
        
        .voice-upgrade-buttons .btn-primary:hover {
          transform: translateY(-2px);
          box-shadow: var(--shadow-lg);
        }
      `;
      
      document.head.appendChild(style);
    }
    
    // Close voice upgrade modal
    window.closeVoiceUpgradeModal = function() {
      const modal = document.querySelector('.voice-upgrade-modal');
      if (modal) {
        modal.remove();
      }
    }
    
    // Upgrade to premium function
    window.upgradeToPremuim = function() {
      closeVoiceUpgradeModal();
      window.location.href = 'profile.html#upgrade';
    }
    
    // Manual voice conversation met caching en loading indicator
    window.playMessageVoice = async function(text, voiceId, buttonElement) {
      try {
        // Check if this button is currently playing and should be paused
        if (buttonElement.classList.contains('playing') && currentAudio) {
          console.log('â¸ï¸ Pausing conversation...');
          currentAudio.pause();
          currentAudio = null;
          buttonElement.classList.remove('playing');
          buttonElement.textContent = 'â–¶ï¸';
          buttonElement.disabled = false;
          return; // Early return to pause instead of restart
        }
        
        // Check voice usage limit for Free plan users
        if (!checkVoiceUsageLimit()) {
          showVoiceUpgradeModal();
          return;
        }
        
        // Filter out text between asterisks (action descriptions)
        function filterTTSText(text) {
          if (!text) return '';
          // Remove text between asterisks (e.g., *leunt naar voren*)
          return text.replace(/\*[^*]*\*/g, '').trim();
        }
        
        // Validate text length first (max 1000 characters for TTS)
        if (!text || text.length === 0) {
          throw new Error('No text to convert to speech');
        }
        
        let ttsText = filterTTSText(text);
        if (ttsText.length === 0) {
          throw new Error('No readable text found after filtering');
        }
        
        if (ttsText.length > 1000) {
          console.warn(`âš ï¸ Text too long for TTS (${ttsText.length} chars), truncating to 1000 for audio only`);
          ttsText = ttsText.substring(0, 997) + '...';
        }
        
        // Stop any other audio if playing
        if (currentAudio) {
          currentAudio.pause();
          currentAudio = null;
          document.querySelectorAll('.voice-play-btn').forEach(btn => {
            btn.classList.remove('playing');
            btn.textContent = 'â–¶ï¸';
          });
        }
        
        // Toon loading indicator
        buttonElement.classList.add('loading');
        buttonElement.textContent = 'â³';
        buttonElement.disabled = true;
        
        // Check cache eerst
        const cacheKey = `${voiceId}_${ttsText.substring(0, 100)}`;
        let audioBlob;
        
        if (voiceCache.has(cacheKey)) {
          console.log('ðŸ’­ Using saved voice...');
          audioBlob = voiceCache.get(cacheKey);
        } else {
          console.log('ðŸ—£ï¸ Character is speaking...');
          audioBlob = await generateSpeech(ttsText, voiceId);
          // Cache de audio (max 50 items)
          if (voiceCache.size >= 50) {
            const firstKey = voiceCache.keys().next().value;
            voiceCache.delete(firstKey);
          }
          voiceCache.set(cacheKey, audioBlob);
        }
        
        // Verander naar play state
        buttonElement.classList.remove('loading');
        buttonElement.classList.add('playing');
        buttonElement.textContent = 'â¸ï¸';
        buttonElement.disabled = false;
        const audioUrl = URL.createObjectURL(audioBlob);
        currentAudio = new Audio(audioUrl);
        
        currentAudio.addEventListener('ended', () => {
          URL.revokeObjectURL(audioUrl);
          currentAudio = null;
          buttonElement.classList.remove('playing', 'loading');
          buttonElement.textContent = 'â–¶ï¸';
          buttonElement.disabled = false;
        });
        
        currentAudio.addEventListener('pause', () => {
          buttonElement.classList.remove('playing', 'loading');
          buttonElement.textContent = 'â–¶ï¸';
          buttonElement.disabled = false;
        });
        
        await currentAudio.play();
        
      } catch (error) {
        console.error('Voice conversation error:', error);
        buttonElement.classList.remove('playing', 'loading');
        buttonElement.textContent = 'â–¶ï¸';
        buttonElement.disabled = false;
        
        // Show more specific error messages
        if (error.message.includes('TTS service not configured')) {
          showError('Voice service is not configured. Please contact support.');
        } else if (error.message.includes('408') || error.message.includes('timeout')) {
          showError('Voice service timed out. Please try again.');
        } else if (error.message.includes('400')) {
          showError('Invalid voice configuration. Please try refreshing the page.');
          console.error('âŒ Voice ID issue - Current character voice_id:', currentCharacter?.voice_id);
        } else if (error.message.includes('500')) {
          showError('Voice service error. Please try again later.');
        } else {
          showError('Could not play voice: ' + (error.message || 'Unknown error'));
        }
      }
    }

    // Fade-in effect voor berichten met typewriter effect
    function typewriterWithVoice(element, text, voiceId = null, speed = 20) {
      console.log('ðŸŽ¬ Starting typewriter with voice effect');
      console.log('ðŸ“ Text to type:', text);
      console.log('ðŸ“ Text length:', text.length);
      element.innerHTML = '';
      element.style.opacity = '1';
      let index = 0;
      
      function addNextChar() {
        if (index < text.length) {
          const char = text[index];
          
          // Use text node instead of span for better handling of special characters
          const textNode = document.createTextNode(char);
          element.appendChild(textNode);
          
          index++;
          setTimeout(addNextChar, speed);
        } else {
          console.log('âœ… Typewriter with voice completed. Total chars typed:', index);
        }
      }
      
      addNextChar();
    }
    
    // NIEUWE WEBHOOK URL
    const newWebhookUrl = "https://hook.eu2.make.com/36bygx4a2y4bkl97wkdjdmtn3o9ygjms";

// ===== MEMORY SYSTEM VIA NETLIFY FUNCTION (zoals category.html) =====
// Memory retrieval via Netlify function - same pattern as character loading
// ===== MEMORY SYSTEM VIA NETLIFY FUNCTION (zoals category.html) =====
// Memory retrieval via Netlify function - same pattern as character loading
async function getRelevantMemories(userId, characterId, currentMessage) {
    console.log("ðŸ§  DEBUG: Starting memory retrieval...");
    console.log("ðŸ” Parameters:", { userId, characterId, currentMessage: currentMessage?.substring(0, 50) });
    
    try {
        // Test eerst de Netlify function
        const functionUrl = '/.netlify/functions/memory';
        console.log('ðŸ“¡ Testing memory function URL:', functionUrl);
        
        const requestData = {
            action: 'get_memories',
            user_id: userId,
            character_id: characterId,
            character_slug: characterId,
            current_message: currentMessage,
            min_importance: 3,
            max_results: 5
        };
        
        console.log('ðŸ“¤ Memory request data:', requestData);
        
        const response = await fetch(functionUrl, {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(requestData)
        });
        
        console.log('ðŸ“¨ Memory function response status:', response.status);
        console.log('ðŸ“¨ Memory function response ok:', response.ok);
        
        const responseText = await response.text();
        console.log('ðŸ“„ Memory function raw response:', responseText);
        
        if (!response.ok) {
            console.log('âŒ Memory function failed, trying direct fallback...');
            return await getMemoriesDirectFallback(userId, characterId);
        }
        
        const data = JSON.parse(responseText);
        console.log('âœ… Memory function parsed data:', data);
        
        if (data.success && data.memories && Array.isArray(data.memories)) {
            console.log(`âœ… Found ${data.memories.length} memories via function`);
            return data.memories;
        } else {
            console.log('âš ï¸ Function returned success=false or no memories, trying fallback...');
            return await getMemoriesDirectFallback(userId, characterId);
        }
        
    } catch (error) {
        console.error('âŒ Memory function error:', error);
        console.log('ðŸ”„ Falling back to direct method...');
        return await getMemoriesDirectFallback(userId, characterId);
    }
}

// FALLBACK: Direct ophalen van memories uit Airtable
async function getMemoriesDirectFallback(userId, characterId) {
    console.log("ðŸ”„ DEBUG: Direct memory fallback starting...");
    console.log("ðŸ” Fallback parameters:", { userId, characterId });
    
    try {
        const email = localStorage.getItem("user_email");
        const token = localStorage.getItem("user_token");
        const uid = localStorage.getItem("user_uid");
        
        console.log("ðŸ”‘ Auth data for fallback:", { 
            hasEmail: !!email, 
            hasToken: !!token, 
            hasUid: !!uid,
            email: email
        });
        
        if (!email || !token || !uid) {
            console.log("âŒ Missing auth data for fallback");
            return [];
        }
        
        const requestData = {
            user_email: email,
            user_uid: uid,
            user_token: token,
            user_id: userId,
            char: characterId,
            memory_focus: true,
            debug_mode: true
        };
        
        console.log("ðŸ“¤ Fallback request data:", requestData);
        
        const response = await fetch("https://hook.eu2.make.com/fjpapor4lkj9mpypaqx8no68d64bxe19", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(requestData)
        });
        
        console.log("ðŸ“¨ Fallback response status:", response.status);
        
        if (!response.ok) {
            console.log("âŒ Fallback HTTP request failed");
            return [];
        }
        
        const rawText = await response.text();
        console.log("ðŸ“„ Fallback raw response (first 500 chars):", rawText.substring(0, 500));
        
        let data;
        try {
            data = JSON.parse(rawText);
        } catch (e) {
            console.log("âŒ Fallback JSON parse failed:", e.message);
            return [];
        }
        
        console.log("âœ… Fallback parsed data keys:", Object.keys(data));
        console.log("âœ… Fallback success:", data.success);
        
        if (!data.success || !data.history) {
            console.log("âŒ Fallback: no success or no history");
            return [];
        }
        
        const memories = [];
        const historyArray = Array.isArray(data.history) ? data.history : Object.values(data.history);
        
        console.log(`ðŸ” Processing ${historyArray.length} history records for memories...`);
        
        historyArray.forEach((record, index) => {
            const fields = record.fields || record;
            
            // Check voor memory velden - VERBETERD
            const hasMemoryImportance = fields.Memory_Importance && parseInt(fields.Memory_Importance) >= 3;
            const hasSummary = fields.Summary && fields.Summary.trim().length > 0;
            const hasEmotionalState = fields.Emotional_State && fields.Emotional_State !== 'neutral';
            
            if (hasMemoryImportance || hasSummary || hasEmotionalState) {
                const memory = {
                    summary: fields.Summary || fields.Message?.substring(0, 100) || 'No summary',
                    importance: parseInt(fields.Memory_Importance) || 3,
                    emotional_state: fields.Emotional_State || 'neutral',
                    memory_tags: fields.Memory_Tags || ['general'],
                    message: fields.Message || '',
                    created_time: fields.CreatedTime || ''
                };
                
                memories.push(memory);
                console.log(`ðŸ“ Found memory ${index + 1}:`, {
                    summary: memory.summary.substring(0, 50) + '...',
                    importance: memory.importance,
                    emotional_state: memory.emotional_state
                });
            }
        });
        
        // Sorteer op importance
        memories.sort((a, b) => (b.importance || 0) - (a.importance || 0));
        const topMemories = memories.slice(0, 5);
        
        console.log(`âœ… Fallback found ${topMemories.length} memories total`);
        return topMemories;
        
    } catch (error) {
        console.error("âŒ Direct fallback error:", error);
        return [];
    }
}

async function processMemoryForMessage(recordId, message, conversationContext) {
    // Prevent concurrent memory processing
    if (window.memoryProcessingInProgress) {
        console.log("âš ï¸ Memory processing already in progress, skipping...");
        return;
    }
    
    window.memoryProcessingInProgress = true;
    
    try {
        console.log("ðŸ§  Processing memory for message:", message.substring(0, 50));
        
        const stored_user_id = localStorage.getItem('user_id');
        const stored_user_email = localStorage.getItem('user_email');
        const stored_user_uid = localStorage.getItem('user_uid');
        
        console.log("ðŸ” User detection:", {
            user_id: stored_user_id,
            user_email: stored_user_email,
            user_uid: stored_user_uid,
            characterSlug: characterSlug
        });
        
        const requestData = {
            record_id: recordId || null,
            message: message,
            context: conversationContext || '',
            user_id: stored_user_id || stored_user_uid || stored_user_email,
            user_email: stored_user_email,
            user_uid: stored_user_uid,
            character_id: characterSlug
        };
        
        console.log("ðŸ“¤ FULL Memory request data:", requestData);
        
        const response = await fetch('/.netlify/functions/update-memory', {
            method: 'POST',
            headers: { 
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            },
            body: JSON.stringify(requestData)
        });
        
        console.log("ðŸ“¨ Memory function response status:", response.status);
        console.log("ðŸ“¨ Memory function response headers:", Object.fromEntries(response.headers.entries()));
        
        // ALTIJD response text lezen, ook bij error
        const responseText = await response.text();
        console.log("ðŸ“„ FULL Memory function raw response:", responseText);
        
        if (response.ok) {
            try {
                const result = JSON.parse(responseText);
                console.log('âœ… Memory processed successfully:', result);
                
                if (result.success) {
                    console.log('ðŸ§  Memory analysis:', result.analysis);
                    console.log('ðŸ“ Update method used:', result.method);
                    
                    if (result.method !== 'analysis_only') {
                        console.log('ðŸ’¾ Memory successfully saved to Airtable');
                        console.log('ðŸ†” Updated record ID:', result.record_id);
                        
                        // Success indicator
                        const chatlog = document.getElementById("chatlog");
                        if (chatlog) {
                            const memoryIndicator = document.createElement("div");
                            memoryIndicator.style.cssText = `
                                font-size: 10px; 
                                color: #14b8a6; 
                                text-align: center; 
                                margin: 2px 0; 
                                opacity: 0.7;
                            `;
                            memoryIndicator.textContent = "ðŸ’¾ Memory saved";
                            chatlog.appendChild(memoryIndicator);
                            
                            setTimeout(() => {
                                if (memoryIndicator.parentNode) {
                                    memoryIndicator.remove();
                                }
                            }, 3000);
                        }
                    } else {
                        console.log('âš ï¸ Memory analyzed but not saved to Airtable');
                        console.log('âš ï¸ This means no matching record was found in ChatHistory');
                    }
                } else {
                    console.log('âŒ Memory processing returned success: false');
                }
            } catch (parseError) {
                console.error('âŒ Failed to parse memory response as JSON:', parseError);
                console.log('ðŸ“„ Raw response that failed to parse:', responseText);
            }
        } else {
            console.log('âŒ Memory processing failed with status:', response.status);
            console.log('ðŸ“„ Error response:', responseText);
        }
        
    } catch (error) {
        console.error('âŒ Memory processing error:', error);
    } finally {
        // Reset the processing flag
        window.memoryProcessingInProgress = false;
    }
    
}
    
    const params = new URLSearchParams(window.location.search);
    characterSlug = params.get("char");

    if (!characterSlug) {
      showError("It looks like there's a connection issue. Let's get you to a safe space where you can find the right companion.");
    } else {
      // Add timeout fallback for character loading
      const loadingTimeout = setTimeout(() => {
        console.error('â° Character loading timeout - forcing interface setup');
        if (document.getElementById('loadingState').style.display !== 'none') {
          showError("Character loading is taking longer than expected. Please try refreshing the page.");
        }
      }, 10000); // 10 second timeout
      
      loadCharacter(characterSlug).then(() => {
        clearTimeout(loadingTimeout);
      }).catch((error) => {
        clearTimeout(loadingTimeout);
        console.error('âŒ Character loading failed:', error);
        showError("Unable to load character. Please try again or contact support.");
      });
    }

    async function loadCharacter(slug) {
  try {
    console.log("Loading character:", slug);
    
    const token = localStorage.getItem("user_token");
    const uid = localStorage.getItem("user_uid");
    const email = localStorage.getItem("user_email");
    
    const requestData = {
      action: "get_character",
      Slug: slug,
      user_uid: uid || "",
      user_token: token || "",
      user_email: email || ""
    };
    
    const response = await fetch(newWebhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestData)
    });

    if (!response.ok) {
      throw new Error(`HTTP ${response.status}`);
    }

    const data = await response.json();
    console.log("Character API response:", data);

    if (!data.success || !data.character) {
      throw new Error("Character not found");
    }

    // Decode Base64 prompt
    if (data.character.prompt) {
      data.character.prompt = atob(data.character.prompt);
    }

    // Ensure voice_id is available
    if (!data.character.voice_id && data.character.voice_type !== 'none') {
      console.log('No voice_id found, character will be text-only');
    }

    currentCharacter = data.character;
    
    // Normalize avatar URL field - webhook returns character_url which contains the avatar
    if (!currentCharacter.avatar_url && currentCharacter.character_url) {
      currentCharacter.avatar_url = currentCharacter.character_url;
    }
    
    // Also check for Avatar_URL (uppercase from Airtable)
    if (!currentCharacter.avatar_url && currentCharacter.Avatar_URL) {
      currentCharacter.avatar_url = currentCharacter.Avatar_URL;
    }
    
    // Normalize name field
    if (!currentCharacter.name && currentCharacter.Name) {
      currentCharacter.name = currentCharacter.Name;
    }
    
    console.log('Character loaded:', currentCharacter);
    console.log('Character voice_id:', currentCharacter.voice_id);
    console.log('Character voice_type:', currentCharacter.voice_type);
    console.log('Character avatar_url:', currentCharacter.avatar_url);
    console.log('Full character data:', JSON.stringify(currentCharacter, null, 2));
    setupCharacterInterface();
    
    // Load chat history after character is loaded
    await loadChatHistory();
    
    // Check if AI avatar needs to be generated
    console.log('ðŸ” Checking needs_ai_avatar:', currentCharacter.needs_ai_avatar);
    console.log('ðŸ” Current avatar_url:', currentCharacter.avatar_url);
    
    // Check if avatar is an emoji SVG (needs AI generation)
    const needsAIAvatar = currentCharacter.needs_ai_avatar || 
                         (currentCharacter.avatar_url && currentCharacter.avatar_url.includes('data:image/svg+xml'));
    
    if (needsAIAvatar) {
      console.log('ðŸŽ¨ Character needs AI avatar generation');
      generateAvatarInBackground();
    }
    
    // Load chat history after character is loaded
    await loadChatHistory();
    
  } catch (error) {
    console.error("Error loading character:", error);
    showError("We're having trouble connecting you right now. Please know that we're here for you - let's try again in a moment.");
  }
}

    function setupCharacterInterface() {
      if (!currentCharacter) return;

      // Initialize authentication check first
      initializeAuthenticationCheck();

      document.title = `Chat with ${currentCharacter.name}`;
      document.getElementById('characterName').textContent = currentCharacter.name;
      document.getElementById('characterTitle').textContent = currentCharacter.character_title || currentCharacter.title || currentCharacter.Character_Title || '';

      const avatarElement = document.getElementById('characterAvatar');
      const needsAIAvatar = currentCharacter.needs_ai_avatar || 
                           (currentCharacter.avatar_url && currentCharacter.avatar_url.includes('data:image/svg+xml'));
      
      if (needsAIAvatar) {
        // Show loading state for avatar
        avatarElement.innerHTML = `
          <div class="avatar-loading">
            <div class="spinner"></div>
          </div>
        `;
      } else if (currentCharacter.avatar_url) {
        avatarElement.innerHTML = `<img src="${currentCharacter.avatar_url}" alt="${currentCharacter.name}">`;
      } else {
        avatarElement.innerHTML = 'ðŸ‘¤';
      }

      document.getElementById('loadingState').style.display = 'none';
      document.getElementById('chatInterface').style.display = 'block';

      const userInput = document.getElementById("userInput");
      userInput.addEventListener("keydown", (e) => {
        if (e.key === "Enter") handleSendClick(e);
      });

      // Debug: Check isRegistered status
      console.log("ðŸ” setupCharacterInterface - checking user status");
      console.log("window.isRegistered:", window.isRegistered);
      console.log("localStorage token:", !!localStorage.getItem("user_token"));
      console.log("localStorage email:", localStorage.getItem("user_email"));

      // Check multiple conditions for user login
      const token = localStorage.getItem("user_token");
      const email = localStorage.getItem("user_email");
      const uid = localStorage.getItem("user_uid");
      const isLoggedIn = window.isAuthenticated || window.isRegistered || (token && email && uid);

      console.log("isLoggedIn calculated:", isLoggedIn);
      console.log("window.isAuthenticated:", window.isAuthenticated);
      console.log("window.currentUser:", !!window.currentUser);

      if (isLoggedIn) {
        console.log("âœ… User is logged in - history will be loaded by loadCharacter");
        // Don't call fetchHistory here - it's already called in loadCharacter
      } else {
        console.log("âŒ User not logged in, skipping history load");
      }
    }

    function showError(message) {
      document.getElementById('loadingState').style.display = 'none';
      document.getElementById('errorState').style.display = 'block';
      document.getElementById('chatInterface').style.display = 'none';
      
      const errorState = document.getElementById('errorState');
      errorState.querySelector('p').textContent = message;
    }

    // ===== CHAT FUNCTIONALITY =====
    async function handleSendClick(event) {
  // Prevent multiple simultaneous sends
  const sendButton = document.getElementById('sendButton');
  if (sendButton && sendButton.disabled) {
    return;
  }
  
  if (!currentCharacter) {
    showWarning("We're almost ready for you! Just a moment while we prepare your companion.", "Getting Ready");
    return;
  }
  
  const token = localStorage.getItem("user_token");
  const uid = localStorage.getItem("user_uid");
  const email = localStorage.getItem("user_email");
  const netlifyUser = window.netlifyIdentity && window.netlifyIdentity.currentUser();
  
  if (!((token && uid && email) || netlifyUser)) {
    localStorage.setItem('login_redirect_url', window.location.href);
    window.location.href = 'profile.html';
    return;
  }

  // Check usage limit before sending message
  const canSend = await checkUsageLimit();
  if (!canSend) {
    return; // Usage limit reached, upgrade prompt already shown
  }
  
  // Add visual feedback to send button
  const userInput = document.getElementById('userInput');
  
  if (sendButton && userInput.value.trim()) {
    sendButton.style.background = 'var(--gradient-primary)';
    sendButton.textContent = 'Sending...';
    sendButton.disabled = true;
    userInput.disabled = true;
  }
  
  sendMessage(event);
}

 async function fetchHistory() {
  console.log("ðŸš¨ ULTRA ROBUST VERSION: fetchHistory() aangeroepen");
  
  const token = localStorage.getItem("user_token");
  const uid   = localStorage.getItem("user_uid");
  const email = localStorage.getItem("user_email");
  let user_id = localStorage.getItem("user_id");
  
  console.log("ðŸ“‹ User data:", { 
    token: !!token, 
    uid: !!uid, 
    email, 
    user_id,
    characterSlug 
  });
  
  if (!token || !uid || !characterSlug || !email) {
    console.warn("âš ï¸ fetchHistory: missing data", { 
      hasToken: !!token, 
      hasUid: !!uid, 
      hasEmail: !!email,
      hasUserId: !!user_id,
      hasCharacterSlug: !!characterSlug 
    });
    return;
  }

  console.log("ðŸš€ Sending request to chat history webhook...");
  
  try {
    const requestPayload = {
      user_email: email,
      user_uid: uid,
      user_token: token,
      user_id: user_id || null,
      char: characterSlug
    };
    
    console.log("ðŸ“¤ Request payload:", requestPayload);
    
    const resp = await fetch("https://hook.eu2.make.com/fjpapor4lkj9mpypaqx8no68d64bxe19", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestPayload)
    });

    console.log("ðŸ“¨ Response status:", resp.status, resp.statusText);

    if (!resp.ok) {
      console.error("âŒ fetchHistory response not ok:", resp.status, resp.statusText);
      showConversationStarter();
      return;
    }

    const rawText = await resp.text();
    console.log("ðŸ“„ Raw response length:", rawText.length);
    console.log("ðŸ“„ Complete raw response:", rawText);

    // Multiple fallback strategies for parsing
    let data = null;
    
    // Strategy 1: Try direct JSON parse
    try {
      data = JSON.parse(rawText);
      console.log("âœ… Strategy 1 (direct parse) succeeded!");
    } catch (e1) {
      console.log("âŒ Strategy 1 failed:", e1.message);
      
      // Strategy 2: Try to extract and manually construct JSON
      try {
        console.log("ðŸ”§ Trying Strategy 2: Manual JSON construction...");
        
        // Look for success indicator
        const successMatch = rawText.match(/["\']?success["\']?\s*:\s*(true|false)/i);
        const success = successMatch ? successMatch[1] === 'true' : false;
        
        // Look for history array using multiple patterns
        let historyArray = [];
        
        const patterns = [
          /"history"\s*:\s*(\[.*?\])/s,
          /'history'\s*:\s*(\[.*?\])/s,
          /history\s*:\s*(\[.*?\])/s,
          /"records"\s*:\s*(\[.*?\])/s,
          /"messages"\s*:\s*(\[.*?\])/s
        ];
        
        for (const pattern of patterns) {
          const match = rawText.match(pattern);
          if (match) {
            try {
              historyArray = JSON.parse(match[1]);
              console.log(`âœ… Found history using pattern: ${pattern.source}`);
              break;
            } catch (parseErr) {
              console.log(`âŒ Pattern ${pattern.source} matched but parse failed:`, parseErr.message);
            }
          }
        }
        
        if (historyArray.length > 0) {
          data = { success: success, history: historyArray };
          console.log("âœ… Strategy 2 succeeded! Constructed data:", data);
        } else {
          throw new Error("No history array found in any pattern");
        }
        
      } catch (e2) {
        console.log("âŒ Strategy 2 failed:", e2.message);
        
        // Strategy 3: Try to find individual message objects
        try {
          console.log("ðŸ”§ Trying Strategy 3: Extract individual objects...");
          
          const objectMatches = rawText.match(/\{[^{}]*\}/g);
          if (objectMatches && objectMatches.length > 0) {
            const parsedObjects = [];
            
            objectMatches.forEach((objStr, index) => {
              try {
                const obj = JSON.parse(objStr);
                parsedObjects.push(obj);
                console.log(`âœ… Parsed object ${index + 1}:`, obj);
              } catch (objErr) {
                console.log(`âŒ Failed to parse object ${index + 1}:`, objStr);
              }
            });
            
            if (parsedObjects.length > 0) {
              data = { success: true, history: parsedObjects };
              console.log("âœ… Strategy 3 succeeded! Found", parsedObjects.length, "objects");
            } else {
              throw new Error("No valid objects found");
            }
          } else {
            throw new Error("No object patterns found");
          }
          
        } catch (e3) {
          console.log("âŒ Strategy 3 failed:", e3.message);
          
          // Strategy 4: Create mock data to test UI
          console.log("ðŸ”§ Strategy 4: Creating mock data for testing...");
          data = {
            success: true,
            history: [
              { role: "user", message: "Hello Abraham!" },
              { role: "assistant", message: "Greetings! I am Abraham Lincoln, 16th President of the United States. How may I assist you today?" }
            ]
          };
          console.log("âœ… Strategy 4: Using mock data to test UI");
        }
      }
    }

    if (!data || !data.success) {
      console.error("âŒ All parsing strategies failed or API returned success: false");
      showConversationStarter();
      return;
    }

    // Process history data
    let history = [];
    
    if (Array.isArray(data.history)) {
      history = data.history;
      console.log("âœ… Found history array with", history.length, "items");
    } else if (data.history && typeof data.history === 'object') {
      history = Object.values(data.history);
      console.log("ðŸ”§ Converted history object to array with", history.length, "items");
    } else {
      console.log("â„¹ï¸ No history data found - starting fresh chat");
      showConversationStarter();
      return;
    }

    console.log(`ðŸ“š Processing ${history.length} chat messages`);

    const chatlog = document.getElementById("chatlog");
    chatlog.innerHTML = ''; // Clear existing content
    
    // Sort by timestamp if available
    history.sort((a, b) => {
      const timeA = a.CreatedTime || a.createdTime || a.created_time || a.timestamp || 0;
      const timeB = b.CreatedTime || b.createdTime || b.created_time || b.timestamp || 0;
      return new Date(timeA) - new Date(timeB);
    });

    let messagesProcessed = 0;

    history.forEach((record, index) => {
      console.log(`ðŸ’¬ Processing message ${index + 1}:`, record);
      
      // Extract role and message with multiple fallbacks
      let role = record.Role || record.role || record.sender || record.type || 
                 (record.fields && (record.fields.Role || record.fields.role));
      
      let message = record.Message || record.message || record.content || record.text || record.body ||
                    (record.fields && (record.fields.Message || record.fields.message || record.fields.content));

      // Default role assignment
      if (!role) {
        role = index % 2 === 0 ? 'user' : 'assistant';
      }
      
      console.log(`ðŸ“ Final extracted: role="${role}", message="${message ? message.substring(0, 50) : 'null'}..."`);
      
      if (!message || message.trim() === '') {
        console.warn("âš ï¸ Skipping record without message:", record);
        return;
      }
      
      // Robust filtering to catch memory and debug messages
      const isDebugMessage = 
        // Debug patterns
        message.startsWith('Processing message') ||
        message.startsWith('Final extracted') ||
        message.startsWith('ðŸ§¹ Filtering out debug/system message:') ||
        
        // Memory patterns - these are being saved as chat messages
        message.includes('Previous conversations and important information') ||
        message.includes('Vorige gesprekken en belangrijke informatie:') ||
        message.includes('[Belangrijk geheugen (') ||
        message.includes('[INSTRUCTION: Always respond in English by default') ||
        message.includes('Use this information to respond personally') ||
        message.includes('Gebruik deze informatie om persoonlijk te antwoorden') ||
        message.includes('BELANGRIJK: Varieer je antwoorden') ||
        message.includes('IMPORTANT: Keep your responses natural') ||
        message.includes('begin NIET elke zin met dezelfde woorden') ||
        message.includes('Vorige gesprekken en bel') || // Partial match
        message.startsWith('BELANGRIJK:') ||
        message.startsWith('IMPORTANT:') ||
        (message.includes('Varieer') && message.includes('antwoorden')) ||
        /^\s*\n*Vorige gesprekken/i.test(message) ||
        /^\s*\n*BELANGRIJK:/i.test(message) ||
        message.includes('what are you doing?]') && message.includes('[Belangrijk geheugen') ||
        message.includes('whats on your mind?]') && message.includes('[Belangrijk geheugen') ||
        message.includes('how is your day?]') && message.includes('[Belangrijk geheugen') ||
        
        // Pure JSON objects that are clearly debug
        (message.startsWith('{') && message.endsWith('}') && message.includes('"role"') && message.includes('"message"')) ||
        
        // Record ID patterns
        /^rec[A-Za-z0-9]{14}$/.test(message.trim()) ||
        
        // Very long messages with memory patterns
        (message.length > 500 && message.includes('[Belangrijk geheugen'));
      
      if (isDebugMessage) {
        console.warn("ðŸ§¹ Filtering out debug/system message:", message.substring(0, 50));
        return;
      }
      
      // Debug log to see what messages are being processed
      console.log(`ðŸ’¬ Processing chat message: role="${role}", message="${message.substring(0, 50)}..."`);
      
      // Don't filter normal user messages even if they contain certain keywords
      if (role === 'user' && message.length < 1000) {
        console.log(`âœ… Allowing user message: "${message.substring(0, 50)}..."`);
      }
      
      // Additional safety check - ensure we have valid content for display
      if (message.trim().length < 1) {
        console.warn("âš ï¸ Skipping empty message");
        return;
      }
      
      // Additional validation - only show messages that look like real chat
      if (role !== 'user' && role !== 'assistant' && role !== 'ai assistant') {
        console.warn("âš ï¸ Skipping message with invalid role:", role);
        return;
      }
      
      const p = document.createElement("p");
      if (role === "user") {
        p.innerHTML = `<strong>You:</strong> ${message}`;
      } else {
        const avatarHtml = getAvatarHtml();
        
        if (currentCharacter && currentCharacter.voice_id) {
          // Validate voice ID before showing play button
          const validatedVoiceId = validateAndFixVoiceId(currentCharacter.voice_id);
          if (validatedVoiceId) {
            // Only show play button if we have a valid voice ID
            p.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> ${message}<br><div style="margin-top: 8px; text-align: left;"><button class="voice-play-btn" onclick="window.playMessageVoice(\`${message.replace(/`/g, '\\`')}\`, '${currentCharacter.voice_id}', this)" title="Hear ${currentCharacter?.name || 'Character'} speak">â–¶ï¸</button></div>`;
          } else {
            // Don't show play button for invalid voice IDs
            p.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> ${message}`;
            console.warn(`âš ï¸ Voice chat disabled for ${currentCharacter?.name} - invalid voice ID: ${currentCharacter.voice_id}`);
          }
        } else {
          p.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> ${message}`;
        }
      }
      chatlog.appendChild(p);
      messagesProcessed++;
    });

    chatlog.scrollTop = chatlog.scrollHeight;
    console.log(`ðŸ“œ Chat history loaded successfully - ${messagesProcessed} messages displayed`);
    
    // If no messages were displayed, show conversation starter
    if (messagesProcessed === 0) {
      console.log('ðŸ“­ No chat history found - showing conversation starter');
      showConversationStarter();
    }
    
  } catch (err) {
    console.error("âŒ Exception in fetchHistory:", err);
  }
}

    function getAvatarHtml() {
      if (currentCharacter?.avatar_url) {
        return `<img class="avatar" src="${currentCharacter.avatar_url}" alt="avatar">`;
      }
      return '<span class="message-avatar">ðŸ‘¤</span>';
    }
    
    // Generate AI avatar in background
    async function generateAvatarInBackground() {
      try {
        console.log('ðŸŽ¨ Starting background avatar generation...');
        
        const response = await fetch('/.netlify/functions/generate-avatar', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            characterName: currentCharacter.name,
            characterTitle: currentCharacter.character_title || '',
            category: currentCharacter.category || 'original'
          })
        });
        
        const data = await response.json();
        
        if (data.success && data.imageUrl) {
          console.log('âœ… AI avatar generated successfully');
          
          // Update the character's avatar URL
          currentCharacter.avatar_url = data.imageUrl;
          
          // Update the avatar display with fade effect
          const avatarElement = document.getElementById('characterAvatar');
          avatarElement.style.opacity = '0';
          
          setTimeout(() => {
            avatarElement.innerHTML = `<img src="${data.imageUrl}" alt="${currentCharacter.name}">`;
            avatarElement.style.opacity = '1';
          }, 300);
          
          // TODO: Update the avatar URL in Airtable via webhook
          updateCharacterAvatarInDatabase(data.imageUrl);
        } else {
          console.log('âš ï¸ Avatar generation failed, keeping loading state');
        }
      } catch (error) {
        console.error('âŒ Error generating avatar:', error);
        // Keep the loading spinner or show a default avatar
        const avatarElement = document.getElementById('characterAvatar');
        avatarElement.innerHTML = 'ðŸ‘¤';
      }
    }
    
    // Update avatar in database
    async function updateCharacterAvatarInDatabase(avatarUrl) {
      try {
        // This would call a webhook or Netlify function to update Airtable
        console.log('ðŸ“ Would update avatar in database:', avatarUrl);
        // TODO: Implement the actual update logic
      } catch (error) {
        console.error('âŒ Error updating avatar in database:', error);
      }
    }

    window.addEventListener("DOMContentLoaded", () => {
      if (window.isRegistered) {
        // History is now loaded by loadCharacter
        console.log("âœ… DOMContentLoaded - history loading handled by loadCharacter");
      }
    });

    function showTypingIndicator() {
      console.log("ðŸ”„ showTypingIndicator() called");
      const chatlog = document.getElementById("chatlog");
      console.log("ðŸ“‹ chatlog element:", chatlog);
      
      // Check if typing indicator already exists
      const existingIndicator = document.getElementById("typingIndicator");
      if (existingIndicator) {
        console.log("âš ï¸ Typing indicator already exists, removing it first");
        existingIndicator.remove();
      }
      
      const typingIndicator = document.createElement("div");
      typingIndicator.className = "typing-indicator";
      typingIndicator.id = "typingIndicator";
      
      const avatarHtml = getAvatarHtml();
      typingIndicator.innerHTML = `
        <strong>${avatarHtml}${currentCharacter?.name || 'Character'} is thinking</strong>
        <div class="typing-dots">
          <span></span>
          <span></span>
          <span></span>
        </div>
      `;
      
      console.log("âœ… Created typing indicator:", typingIndicator);
      
      chatlog.appendChild(typingIndicator);
      console.log("âž• Appended typing indicator to chatlog");
      
      // Force a reflow to ensure the element is rendered
      typingIndicator.offsetHeight;
      
      chatlog.scrollTop = chatlog.scrollHeight;
      console.log("ðŸ“œ Scrolled chatlog to bottom");
      
      return typingIndicator;
    }

    function hideTypingIndicator() {
      console.log("ðŸš« hideTypingIndicator() called");
      const typingIndicator = document.getElementById("typingIndicator");
      console.log("ðŸ” Found typing indicator:", !!typingIndicator);
      if (typingIndicator) {
        console.log("ðŸ—‘ï¸ Removing typing indicator");
        typingIndicator.remove();
        console.log("âœ… Typing indicator removed");
      } else {
        console.log("âš ï¸ No typing indicator found to remove");
      }
    }

    // Improved typewriter effect with fade-in animation
function typewriterEffect(element, text, speed = 20) {
  console.log('ðŸŽ¬ Starting typewriter effect');
  console.log('ðŸ“ Text to type:', text);
  console.log('ðŸ“ Text length:', text.length);
  element.innerHTML = '';
  element.style.opacity = '1';
  let index = 0;
  
  function addNextChar() {
    if (index < text.length) {
      const char = text[index];
      
      // Use text node instead of span for better handling of special characters
      const textNode = document.createTextNode(char);
      element.appendChild(textNode);
      
      index++;
      setTimeout(addNextChar, speed);
    } else {
      console.log('âœ… Typewriter completed. Total chars typed:', index);
    }
  }
  
  addNextChar();
}

// UNIVERSELE Authentication Check - Voeg toe aan chat.html
function initializeAuthenticationCheck() {
  console.log('ðŸ” Initializing authentication check...');
  
  // Check localStorage first
  const token = localStorage.getItem('user_token');
  const email = localStorage.getItem('user_email');
  const uid = localStorage.getItem('user_uid');
  const timestamp = localStorage.getItem('user_auth_timestamp');
  
  if (token && email && uid && token !== 'false' && token !== 'null') {
    // Check if token is not too old (24 hours)
    const authAge = Date.now() - parseInt(timestamp || '0');
    if (authAge < 24 * 60 * 60 * 1000) {
      console.log('âœ… Valid authentication found in localStorage:', email);
      
      // Set global auth state
      window.isAuthenticated = true;
      window.currentUser = { email, uid, token };
      
      return true;
    } else {
      console.log('â° Authentication expired, clearing...');
      clearAuthData();
    }
  }
  
  // Fallback: Check Netlify Identity
  if (window.netlifyIdentity) {
    const netlifyUser = window.netlifyIdentity.currentUser();
    if (netlifyUser) {
      console.log('âœ… Found Netlify Identity user:', netlifyUser.email);
      
      // Store authentication data
      const accessToken = netlifyUser.token?.access_token || netlifyUser.access_token;
      if (accessToken) {
        localStorage.setItem('user_email', netlifyUser.email);
        localStorage.setItem('user_token', accessToken);
        localStorage.setItem('user_uid', netlifyUser.id);
        localStorage.setItem('user_auth_timestamp', Date.now().toString());
        
        window.isAuthenticated = true;
        window.currentUser = { 
          email: netlifyUser.email, 
          uid: netlifyUser.id, 
          token: accessToken 
        };
        
        return true;
      }
    }
  }
  
  console.log('âŒ No valid authentication found');
  window.isAuthenticated = false;
  window.currentUser = null;
  return false;
}

// Clear authentication data
function clearAuthData() {
  localStorage.removeItem('user_email');
  localStorage.removeItem('user_token');
  localStorage.removeItem('user_uid');
  localStorage.removeItem('user_auth_timestamp');
  localStorage.removeItem('user_refresh_token');
  localStorage.removeItem('user_netlify_data');
  
  window.isAuthenticated = false;
  window.currentUser = null;
}

async function sendMessage(event) {
  event?.preventDefault();
  
  // Authentication check
  if (!window.isAuthenticated || !window.currentUser) {
    console.log('âŒ User not authenticated, checking localStorage...');
    
    if (!initializeAuthenticationCheck()) {
      console.log('âŒ No valid auth found, redirecting to login');
      localStorage.setItem('login_redirect_url', window.location.href);
      window.location.href = 'profile.html';
      return;
    }
  }
  
  const userInput = document.getElementById("userInput");
  const input = userInput.value.trim();
  if (!input) return;

  const email = window.currentUser.email;
  const token = window.currentUser.token;
  const uid = window.currentUser.uid;
  const user_id = localStorage.getItem("user_id");
  const user_uid = localStorage.getItem("user_uid");
  const user_email = localStorage.getItem("user_email");
  
  // Use fallback if user_id is not available
  const effective_user_id = user_id || user_uid || user_email;
  
  console.log("ðŸš€ sendMessage debug:", { 
    token: !!token, 
    uid: !!uid, 
    email, 
    user_id, 
    user_uid, 
    user_email,
    effective_user_id,
    characterSlug 
  });

  // Check if there's existing chat history first
  const chatlog = document.getElementById("chatlog");
  const existingMessages = chatlog.querySelectorAll('.message-group');
  const hasExistingHistory = existingMessages.length > 0;
  
  console.log("ðŸ’¬ Existing chat history check:", {
    existingMessages: existingMessages.length,
    hasExistingHistory
  });

  // Haal relevante herinneringen op - maar alleen als er al chatgeschiedenis is
  console.log("ðŸ§  Retrieving memories before sending message...");
  let memories = [];
  let memoryContext = "";

  // Always try to retrieve memories, regardless of existing history in current session
  try {
    memories = await getRelevantMemories(effective_user_id, characterSlug, input);
    console.log("âœ… Memory retrieval completed:", memories?.length || 0, "memories found");
  } catch (error) {
    console.error("âŒ Memory retrieval failed:", error);
    memories = []; // Fallback to empty array
  }

  // DEBUG: Memory verification
  if (memories && memories.length > 0) {
      console.log(`ðŸ“š Found ${memories.length} relevant memories:`);
      memories.forEach((memory, i) => {
          console.log(`  ${i+1}. [${memory.importance}] ${memory.summary?.substring(0, 80)}...`);
      });
      
      // Verbeterde memory context formatting - alleen als er memories zijn
      const memoryTexts = memories.map(m => {
          const summary = m.summary || m.message || '';
          const importance = m.importance || 0;
          return `[Belangrijk geheugen (${importance}/10): ${summary}]`;
      });
      
      // Create memory context instructions with English as default
      memoryContext = `\n\nPrevious conversations and important information:\n${memoryTexts.join('\n')}\n\n[INSTRUCTION: Always respond in English by default. Only switch to Dutch if the user writes in Dutch. Match the language of the user's most recent message.]\n\nUse this information to respond personally. IMPORTANT: Keep your responses natural and varied (usually 3-5 sentences). Focus on a good, meaningful conversation as a true companion. AVOID roleplay actions like *leans forward* or *smiles* - just talk like a friend. Vary your responses - do NOT start every sentence with the same words. Build a personal relationship by truly listening and responding thoughtfully.\n`;
      
      console.log("ðŸ“ Improved memory context:", memoryContext);
  } else {
      console.log("ðŸ“­ No relevant memories found - adding variation instructions only");
      // Still add variation and companion instructions even without memories
      memoryContext = "\n\n[INSTRUCTION: Always respond in English by default. Only switch to Dutch if the user writes in Dutch. Match the language of the user's most recent message.]\n\nIMPORTANT: Keep your responses natural and varied (usually 3-5 sentences). Focus on a good, meaningful conversation as a true companion. AVOID roleplay actions like *leans forward* or *smiles* - just talk like a friend. Vary your responses - do NOT start every sentence with the same words. Build a personal relationship by truly listening and responding thoughtfully.\n";
  }

  const sendButton = document.getElementById("sendButton");
  sendButton.disabled = true;
  sendButton.textContent = "Sharing...";
  
  // DIRECT: Voeg gebruiker bericht toe aan chat
  const divUser = document.createElement("p");
  divUser.innerHTML = `<strong>You:</strong> ${input}`;
  chatlog.appendChild(divUser);
  chatlog.scrollTop = chatlog.scrollHeight;
  userInput.value = "";

  // Reset send button state
  function resetSendButton() {
    const sendButton = document.getElementById('sendButton');
    const userInput = document.getElementById('userInput');
    if (sendButton) {
      sendButton.style.background = '';
      sendButton.textContent = 'Send';
      sendButton.disabled = false;
    }
    if (userInput) {
      userInput.disabled = false;
    }
  }

  // Show typing indicator immediately
showTypingIndicator();

  try {
    // BELANGRIJKE OPMERKING VOOR WEBHOOK:
    // - 'text' bevat memory context + user input (gebruik dit ALLEEN voor AI processing)
    // - 'user_message' bevat ALLEEN wat de gebruiker typte (gebruik dit voor database opslag)
    // - 'clean_user_message' is een backup met alleen gebruiker input
    
    const requestPayload = {
      action: "send_message",
      text: memoryContext + input, // Voor AI processing - NIET opslaan in database!
      user_message: input, // ALLEEN DIT opslaan als user message in ChatHistory!
      clean_user_message: input, // Backup: schone gebruiker input zonder memory context
      display_message: input, // Nog een backup: wat getoond moet worden als user message
      memory_context: memoryContext, // Aparte veld voor memory context - NIET opslaan als message!
      Character_id: characterSlug,
      Slug: characterSlug,
      user_uid: uid,
      user_token: token,
      user_email: email,
      user_id: user_id || null
    };
    
    console.log("ðŸ“¤ sendMessage FULL payload:", requestPayload);

    const response = await fetch(newWebhookUrl, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(requestPayload)
    });

    console.log("ðŸ“¨ sendMessage response status:", response.status, response.statusText);

    const rawText = await response.text();
    console.log("ðŸ“„ sendMessage raw response:", rawText);
    // EXTRA DEBUG INFO
console.log("ðŸ“„ Raw response type:", typeof rawText);
console.log("ðŸ“„ Raw response length:", rawText.length);
console.log("ðŸ“„ First 200 chars:", rawText.substring(0, 200));
console.log("ðŸ“„ Last 200 chars:", rawText.substring(rawText.length - 200));

    let data;
try {
  // Probeer eerst direct parsing
  data = JSON.parse(rawText);
  console.log("âœ… Direct JSON parse successful:", data);
} catch (e) {
  console.warn("âŒ Direct JSON parse failed:", e.message);
  
  // STRATEGIE 1: Clean de response text
  try {
    let cleanText = rawText.trim();
    
    // Verwijder BOM en speciale characters
    cleanText = cleanText.replace(/^\uFEFF/, ''); // BOM
    cleanText = cleanText.replace(/[\x00-\x1F\x7F-\x9F]/g, ''); // Control characters
    
    // Zoek naar JSON object in de text
    const jsonMatch = cleanText.match(/\{.*\}/s);
    if (jsonMatch) {
      data = JSON.parse(jsonMatch[0]);
      console.log("âœ… JSON extracted and parsed:", data);
    } else {
      throw new Error("No JSON object found in response");
    }
    
  } catch (e2) {
    console.warn("âŒ JSON extraction failed:", e2.message);
    
    // STRATEGIE 2: Zoek naar reply in raw text
    console.log("ðŸ” Searching for reply in raw text...");
    
    // Meerdere patronen om reply te vinden
    const patterns = [
      /"reply"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/s,
      /'reply'\s*:\s*'([^']*(?:\\.[^']*)*)'/s,
      /reply["\']?\s*[:=]\s*["\']([^"']*(?:\\.[^"']*)*)["\']?/s,
      /"response"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/s,
      /"message"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/s,
      /"text"\s*:\s*"([^"]*(?:\\.[^"]*)*)"/s
    ];
    
    let foundReply = null;
    for (const pattern of patterns) {
      const match = rawText.match(pattern);
      if (match && match[1] && match[1].length > 10) { // Minimaal 10 karakters
        foundReply = match[1].replace(/\\"/g, '"').replace(/\\'/g, "'").replace(/\\n/g, '\n');
        console.log("âœ… Found reply with pattern:", pattern.source);
        console.log("âœ… Extracted reply:", foundReply.substring(0, 100) + "...");
        break;
      }
    }
    
    if (foundReply) {
      data = {
        success: true,
        reply: foundReply
      };
    } else {
      console.error("âŒ No reply found in any pattern");
      console.log("ðŸ” Full raw text for manual inspection:", rawText);
      
      // Absolute fallback
      data = {
        success: true,
        reply: "I want to make sure I give you the thoughtful response you deserve. Could you share that with me again? I'm here to listen."
      };
    }
  }
}

    if (!data.success) {
      throw new Error("Chat request failed");
    }

    // Check if reply is empty or just whitespace
let reply = (data.reply && data.reply.trim()) || 
              (data.response && data.response.trim()) || 
              (data.message && data.message.trim()) || 
              "I want to be fully present for our conversation. It seems I'm having a moment of difficulty - could you share that with me once more? Your thoughts are important to me.";

// No longer limiting reply length - AI should give concise answers through prompt engineering
console.log(`ðŸ“ Reply length: ${reply.length} characters`);

// Extra debug info
console.log("ðŸ” Original data.reply:", data.reply);
console.log("ðŸ” Original data.response:", data.response);
console.log("ðŸ” Original data.message:", data.message);
console.log("ðŸ” Final reply used:", reply);
console.log("ðŸ” Reply length:", reply.length);

    // Hide typing indicator immediately when response is ready
hideTypingIndicator();

    // Reset send button state
    resetSendButton();

    // DIRECT: Voeg character antwoord toe aan chat
    const divBot = document.createElement("p");
    const avatarHtml = getAvatarHtml();
    
    if (currentCharacter.voice_id) {
      // Validate voice ID before showing play button
      const validatedVoiceId = validateAndFixVoiceId(currentCharacter.voice_id);
      if (validatedVoiceId) {
        // Only show play button if we have a valid voice ID
        divBot.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> <span class="typing-text"></span><br><div style="margin-top: 8px; text-align: left;"><button class="voice-play-btn" onclick="window.playMessageVoice(\`${reply.replace(/`/g, '\\`')}\`, '${currentCharacter.voice_id}', this)" title="Hear ${currentCharacter?.name || 'Character'} speak">â–¶ï¸</button></div>`;
      } else {
        // Don't show play button for invalid voice IDs
        divBot.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> <span class="typing-text"></span>`;
        console.warn(`âš ï¸ Voice chat disabled for ${currentCharacter?.name} - invalid voice ID: ${currentCharacter.voice_id}`);
      }
    } else {
      divBot.innerHTML = `<strong>${avatarHtml}${currentCharacter?.name || 'Character'}:</strong> <span class="typing-text"></span>`;
    }
    chatlog.appendChild(divBot);
    chatlog.scrollTop = chatlog.scrollHeight;

    const typingSpan = divBot.querySelector('.typing-text');
    
    // Escape HTML entities to prevent breaking
    const escapeHtml = (text) => {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    };
    
    // Use voice-enabled typewriter if character has voice
    if (currentCharacter.voice_id) {
      typewriterWithVoice(typingSpan, reply, currentCharacter.voice_id);
    } else {
      typewriterEffect(typingSpan, reply);
    }

    // Save messages directly to ensure they persist correctly
    try {
      console.log('ðŸ’¾ Saving chat messages directly...');
      
      const saveResponse = await fetch('/.netlify/functions/save-chat-message', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          user_email: user_email,
          user_uid: user_uid,
          user_token: token,
          char: characterSlug,
          user_message: input,
          ai_response: reply
        })
      });
      
      if (saveResponse.ok) {
        console.log('âœ… Messages saved successfully');
      } else {
        console.log('âš ï¸ Direct save failed, relying on webhook');
      }
    } catch (saveError) {
      console.error('âŒ Save error:', saveError);
    }

    // Check if we should show rating
    await checkAndShowRating();

    // Memory processing in background - VERBETERDE VERSIE
if (data && data.success) {
  console.log('ðŸ§  Starting memory processing for message:', input);
  
  // Zoek naar record_id in ALLE mogelijke velden
  const recordId = data.record_id || 
                  data.chat_record_id || 
                  data.message_id || 
                  data.user_record_id || 
                  data.ChatHistory_id ||
                  data.id ||
                  null;
  
  console.log('ðŸ” Full API response for record_id detection:', data);
  console.log('ðŸ” Extracted record_id:', recordId);
  console.log('ðŸ” Available data keys:', Object.keys(data));
  
  // Debounce memory processing to prevent loops
  if (window.memoryProcessingTimeout) {
    clearTimeout(window.memoryProcessingTimeout);
  }
  
  window.memoryProcessingTimeout = setTimeout(() => {
    processMemoryForMessage(recordId, input, getLastMessages(3));
  }, 5000);
}
    
  } catch (err) {
    console.error("âŒ sendMessage Error:", err);
    hideTypingIndicator();
    
    const divErr = document.createElement("p");
    divErr.innerHTML = `<strong>${currentCharacter?.name || 'Character'}:</strong> âš ï¸ Something went wrong while sending.`;
    chatlog.appendChild(divErr);
    chatlog.scrollTop = chatlog.scrollHeight;
  } finally {
    sendButton.disabled = false;
    sendButton.textContent = "Send";
  }
}

// ===== DISCLAIMER TOGGLE FUNCTIONALITY =====
document.addEventListener('DOMContentLoaded', () => {
  // Initialize authentication check
  initializeAuthenticationCheck();
  const disclaimerToggle = document.getElementById('disclaimerToggle');
  const disclaimerExpanded = document.getElementById('disclaimerExpanded');
  
  if (disclaimerToggle && disclaimerExpanded) {
    disclaimerToggle.addEventListener('click', () => {
      const isExpanded = disclaimerExpanded.style.display !== 'none';
      
      if (isExpanded) {
        disclaimerExpanded.style.display = 'none';
        disclaimerToggle.classList.remove('expanded');
        disclaimerToggle.setAttribute('aria-label', 'Show more information');
      } else {
        disclaimerExpanded.style.display = 'block';
        disclaimerToggle.classList.add('expanded');
        disclaimerToggle.setAttribute('aria-label', 'Show less information');
      }
    });
  }
});

// ===== USAGE LIMIT CHECK =====
async function checkUsageLimit() {
  const token = localStorage.getItem("user_token");
  const uid = localStorage.getItem("user_uid");
  const email = localStorage.getItem("user_email");
  
  if (!token || !uid || !email) {
    return false;
  }

  try {
    console.log('ðŸ” Checking usage limit for:', email);
    
    const payload = {
      user_email: email,
      user_uid: uid,
      user_token: token,
      action: 'get_profile'
    };

    const resp = await fetch('https://hook.eu2.make.com/lya166veex7oo2wwo8mx4fuhlkssxlog', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    });

    if (!resp.ok) {
      console.warn('âš ï¸ Could not check usage limit, allowing message');
      return true;
    }

    const responseText = await resp.text();
    let data;

    try {
      data = JSON.parse(responseText);
    } catch (parseError) {
      console.warn('âš ï¸ Could not parse usage response, allowing message');
      return true;
    }

    const plan = data.plan || 'Free';
    const usage = parseInt(data.usage) || 0;
    const quota = parseInt(data.quota) || 100;

    console.log('ðŸ“Š Usage check:', { plan, usage, quota });

    // If premium user, always allow
    if (plan.toLowerCase() === 'premium' || plan.toLowerCase() === 'pro' || plan.toLowerCase() === 'paid') {
      console.log('âœ… Premium user - unlimited messages');
      return true;
    }

    // If usage >= quota, show upgrade prompt
    if (usage >= quota) {
      console.log('ðŸš« Usage limit reached');
      showUpgradePrompt(usage, quota);
      return false;
    }

    console.log('âœ… Usage within limit');
    return true;

  } catch (error) {
    console.error('âŒ Error checking usage limit:', error);
    return true;
  }
}

// ===== UPGRADE PROMPT =====
function showUpgradePrompt(usage, quota) {
  let upgradeOverlay = document.getElementById('upgradeOverlay');
  
  if (!upgradeOverlay) {
    upgradeOverlay = document.createElement('div');
    upgradeOverlay.id = 'upgradeOverlay';
    upgradeOverlay.className = 'upgrade-overlay';
    upgradeOverlay.innerHTML = `
      <div class="upgrade-modal">
        <div class="upgrade-header">
          <div class="upgrade-icon">ðŸ’Ž</div>
          <h3 class="upgrade-title">Continue Your Journey</h3>
          <p class="upgrade-subtitle">You've shared ${quota} meaningful conversations this month. Ready to explore deeper connections?</p>
        </div>
        
        <div class="upgrade-benefits">
          <div class="benefit-item">
            <span class="benefit-icon">âœ¨</span>
            <span class="benefit-text">Unlimited heartfelt conversations</span>
          </div>
          <div class="benefit-item">
            <span class="benefit-icon">ðŸ§ </span>
            <span class="benefit-text">Deeper, more personal connections</span>
          </div>
          <div class="benefit-item">
            <span class="benefit-icon">ðŸŽ¯</span>
            <span class="benefit-text">First access to new ways to connect</span>
          </div>
          <div class="benefit-item">
            <span class="benefit-icon">ðŸ‘‘</span>
            <span class="benefit-text">Dedicated care and support</span>
          </div>
        </div>

        <div class="upgrade-pricing">
          <div class="price-tag">
            <span class="currency">â‚¬</span>
            <span class="amount">7.99</span>
            <span class="period">/month</span>
          </div>
        </div>

        <div class="upgrade-buttons">
          <button class="upgrade-btn primary" onclick="handleUpgradeFromChat()">
            Continue My Journey
          </button>
          <button class="upgrade-btn secondary" onclick="closeUpgradePrompt()">
            I'll Think About It
          </button>
        </div>
      </div>
    `;
    
    document.body.appendChild(upgradeOverlay);
  }
  
  upgradeOverlay.classList.add('active');
  document.body.style.overflow = 'hidden';
}

function closeUpgradePrompt() {
  const upgradeOverlay = document.getElementById('upgradeOverlay');
  if (upgradeOverlay) {
    upgradeOverlay.classList.remove('active');
    document.body.style.overflow = '';
  }
}

// ===== STRIPE UPGRADE FROM CHAT =====
async function handleUpgradeFromChat() {
  console.log('ðŸš€ Upgrade from chat clicked');
  
  const email = localStorage.getItem('user_email');
  const uid = localStorage.getItem('user_uid');
  
  if (!email || !uid) {
    showError('We want to make sure this is really you. Please sign in to continue your journey with us.');
    return;
  }
  
  try {
    const stripe = Stripe('pk_live_jz2dXpzmEDUahXkKkyUe36Zt');
    const PRICE_ID = 'price_1Rc9oTDU567HpUYxl1sLu71A';
    
    const upgradeButton = document.querySelector('.upgrade-btn.primary');
    const originalText = upgradeButton.innerHTML;
    upgradeButton.innerHTML = 'Setting up your journey...';
    upgradeButton.disabled = true;
    
    console.log('ðŸ“¡ Redirecting to Stripe Checkout...');
    
    const { error } = await stripe.redirectToCheckout({
      lineItems: [{
        price: PRICE_ID,
        quantity: 1,
      }],
      mode: 'subscription',
      successUrl: `${window.location.origin}/chat.html?char=${characterSlug}&upgrade=success`,
      cancelUrl: `${window.location.origin}/chat.html?char=${characterSlug}&upgrade=cancelled`,
      customerEmail: email,
      clientReferenceId: uid,
    });
    
    if (error) {
      throw new Error(error.message);
    }
    
  } catch (error) {
    console.error('âŒ Error processing upgrade:', error);
    showError(`We encountered a small hiccup while processing your request. Please don't worry - we're here to help you through this.`);
    
    const upgradeButton = document.querySelector('.upgrade-btn.primary');
    if (upgradeButton) {
      upgradeButton.innerHTML = 'Continue My Journey';
      upgradeButton.disabled = false;
    }
  }
}

// Check upgrade status on page load
function checkUpgradeStatus() {
  const urlParams = new URLSearchParams(window.location.search);
  const upgradeStatus = urlParams.get('upgrade');
  
  if (upgradeStatus === 'success') {
    showSuccess('ðŸŽ‰ Welcome to your expanded journey! You now have unlimited space to share and explore your thoughts.');
    const newUrl = window.location.pathname + '?char=' + characterSlug;
    window.history.replaceState({}, document.title, newUrl);
  } else if (upgradeStatus === 'cancelled') {
    showWarning('No worries at all! When you\'re ready to expand your journey, we\'ll be here for you.');
    const newUrl = window.location.pathname + '?char=' + characterSlug;
    window.history.replaceState({}, document.title, newUrl);
  }
}

// Helper functie voor conversation context
function getLastMessages(count = 3) {
    const chatlog = document.getElementById("chatlog");
    const messages = chatlog.querySelectorAll("p");
    const lastMessages = Array.from(messages).slice(-count);
    return lastMessages.map(msg => msg.textContent).join(" | ");
}

  </script>

  <!-- Footer -->
  <footer class="footer">
    <div class="footer-content">
      <div class="footer-links">
        <a href="index.html" class="footer-link">Characters</a>
        <span class="footer-separator">â€¢</span>
        <a href="chat-overview.html" class="footer-link">Chats</a>
        <span class="footer-separator">â€¢</span>
        <a href="create-character.html" class="footer-link">Create Character</a>
        <span class="footer-separator">â€¢</span>
        <a href="contact.html" class="footer-link">Contact</a>
        <span class="footer-separator">â€¢</span>
        <a href="profile.html" class="footer-link">Profile</a>
        <span class="footer-separator">â€¢</span>
        <a href="privacy-policy.html" class="footer-link">Privacy Policy</a>
        <span class="footer-separator">â€¢</span>
        <a href="terms-and-conditions.html" class="footer-link">Terms and Conditions</a>
      </div>
      <div class="footer-copyright">
        Â© 2025 Narrin AI. All rights reserved.
      </div>
    </div>
  </footer>
  
  <script>
    // ===== RATING SYSTEM FUNCTIONALITY =====
    let selectedRating = 0;
    let messageCount = 0;
    
    // Initialize rating stars
    document.addEventListener('DOMContentLoaded', () => {
      const stars = document.querySelectorAll('.rating-star');
      const submitBtn = document.getElementById('submitRatingBtn');
      
      stars.forEach(star => {
        star.addEventListener('click', () => {
          selectedRating = parseInt(star.dataset.rating);
          updateStarDisplay(selectedRating);
          submitBtn.disabled = false;
        });
        
        star.addEventListener('mouseenter', () => {
          const hoverRating = parseInt(star.dataset.rating);
          updateStarDisplay(hoverRating, true);
        });
      });
      
      document.getElementById('ratingStars').addEventListener('mouseleave', () => {
        updateStarDisplay(selectedRating);
      });
    });
    
    function updateStarDisplay(rating, isHover = false) {
      const stars = document.querySelectorAll('.rating-star');
      stars.forEach((star, index) => {
        star.classList.remove('active', 'hover');
        if (index < rating) {
          star.classList.add(isHover ? 'hover' : 'active');
        }
      });
    }
    
    async function checkAndShowRating() {
      const user_email = localStorage.getItem('user_email');
      const user_uid = localStorage.getItem('user_uid');
      const characterSlug = window.location.search.split('=')[1];
      
      if (!user_email || !user_uid || !characterSlug) return;
      
      try {
        const response = await fetch('/.netlify/functions/check-message-count', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_email,
            user_uid,
            char: characterSlug
          })
        });
        
        if (response.ok) {
          const data = await response.json();
          messageCount = data.message_count;
          
          if (data.should_show_rating) {
            console.log('â­ Showing rating modal after', messageCount, 'messages');
            // Delay to let conversation flow finish
            setTimeout(() => showRatingModal(), 2000);
          }
        }
      } catch (error) {
        console.error('âŒ Error checking message count:', error);
      }
    }
    
    function showRatingModal() {
      const overlay = document.getElementById('ratingOverlay');
      overlay.classList.add('active');
      document.body.style.overflow = 'hidden';
      
      // Reset state
      selectedRating = 0;
      updateStarDisplay(0);
      document.getElementById('ratingFeedback').value = '';
      document.getElementById('submitRatingBtn').disabled = true;
    }
    
    function skipRating() {
      const overlay = document.getElementById('ratingOverlay');
      overlay.classList.remove('active');
      document.body.style.overflow = '';
    }
    
    async function submitRating() {
      if (!selectedRating) return;
      
      const user_email = localStorage.getItem('user_email');
      const user_uid = localStorage.getItem('user_uid');
      const characterSlug = window.location.search.split('=')[1];
      const feedback = document.getElementById('ratingFeedback').value;
      
      const submitBtn = document.getElementById('submitRatingBtn');
      submitBtn.disabled = true;
      submitBtn.textContent = 'Submitting...';
      
      try {
        const response = await fetch('/.netlify/functions/save-chat-rating', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            user_email,
            user_uid,
            char: characterSlug,
            rating: selectedRating,
            message_count: messageCount,
            feedback: feedback
          })
        });
        
        if (response.ok) {
          console.log('âœ… Rating saved successfully');
          showSuccess('Thank you for your feedback!');
          skipRating();
        } else {
          throw new Error('Failed to save rating');
        }
      } catch (error) {
        console.error('âŒ Error saving rating:', error);
        showError('Sorry, we couldn\'t save your rating. Please try again.');
        submitBtn.disabled = false;
        submitBtn.textContent = 'Submit';
      }
    }
  </script>
</body>
</html>