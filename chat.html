<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover, user-scalable=no" />
  <meta name="robots" content="noindex">
  <title>Chat with AI Companion | Organize Your Thoughts & Find Mental Clarity - Narrin AI</title>
  <meta name="description" content="Transform scattered thoughts into clear insights through personalized AI conversations. Chat with your companion to organize your mind and end each day feeling clearer.">
  
  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://narrin.ai/chat">
  <meta property="og:title" content="Chat with AI Companion | Transform Mental Chaos Into Clarity">
  <meta property="og:description" content="Transform scattered thoughts into organized insights through AI conversations. Find mental clarity and end each day feeling clearer.">
  <meta property="og:image" content="https://narrin.ai/og-image.jpg">
  
  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://narrin.ai/chat">
  <meta property="twitter:title" content="AI Chat for Mental Clarity | Organize Your Thoughts - Narrin AI">
  <meta property="twitter:description" content="Transform mental chaos into clear thinking through personalized AI conversations. Organize your thoughts and find clarity.">
  <meta property="twitter:image" content="https://narrin.ai/og-image.jpg">

  <!-- Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-D6T01M6XTJ"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-D6T01M6XTJ');
  </script>

  <!-- Netlify Identity Widget -->
  <script type="text/javascript" src="https://identity.netlify.com/v1/netlify-identity-widget.js"></script>

  <!-- Network Performance Optimizations -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link rel="preconnect" href="https://narrin.ai">
  <link rel="preconnect" href="https://hook.eu2.make.com">
  <link rel="dns-prefetch" href="https://api.airtable.com">

  <!-- Fonts -->
  <link rel="preload" href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700;800&family=Outfit:wght@300;400;500;600;700;800&display=swap" as="style" onload="this.onload=null;this.rel='stylesheet'">
  <noscript><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Plus+Jakarta+Sans:wght@300;400;500;600;700;800&family=Outfit:wght@300;400;500;600;700;800&display=swap"></noscript>

  <style>
    :root {
      /* Narrin Color Palette */
      --color-white: #ffffff;
      --color-off-white: #fafafa;
      --color-light-gray: #f5f5f5;
      --color-teal: #14b8a6;
      --color-teal-light: #5eead4;
      --color-teal-dark: #0f766e;
      --color-coral: #f97316;
      --color-coral-light: #fb923c;
      --color-navy: #1e293b;
      --color-navy-light: #334155;
      --color-gray: #64748b;
      --color-gray-light: #94a3b8;
      --color-gray-dark: #475569;
      
      /* Gradients */
      --gradient-primary: linear-gradient(135deg, var(--color-teal) 0%, var(--color-coral) 100%);
      
      /* Selira-inspired spacing */
      --spacing-xs: 8px;
      --spacing-sm: 12px;
      --spacing-md: 16px;
      --spacing-lg: 20px;
      --spacing-xl: 24px;
      --spacing-2xl: 32px;
      
      /* Typography */
      --font-primary: 'Plus Jakarta Sans', -apple-system, BlinkMacSystemFont, sans-serif;
      --font-secondary: 'Outfit', -apple-system, BlinkMacSystemFont, sans-serif;
      
      /* Border Radius */
      --radius-sm: 8px;
      --radius-md: 12px;
      --radius-lg: 16px;
      --radius-xl: 20px;
      --radius-full: 50px;
      
      /* Transitions */
      --transition-base: 300ms ease-out;

      /* Shadows */
      --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: var(--font-primary);
      background: var(--color-off-white);
      color: var(--color-navy);
      overflow: hidden;
      height: 100vh; /* Fallback for older browsers */
      height: 100dvh; /* Dynamic viewport height for mobile browsers */
      padding-top: env(safe-area-inset-top);
      padding-left: env(safe-area-inset-left);
      padding-right: env(safe-area-inset-right);
      padding-bottom: env(safe-area-inset-bottom);
    }

    /* App Layout - Selira inspired */
    .app-container {
      display: flex;
      height: 100vh; /* Fallback for older browsers */
      height: 100dvh; /* Dynamic viewport height for mobile browsers */
      overflow: hidden;
    }

    /* Main Chat Area - Full width on mobile */
    .chat-main {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--color-white);
    }

    /* Chat Header - Compact */
    .chat-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--spacing-md) var(--spacing-lg);
      border-bottom: 1px solid var(--color-light-gray);
      background: var(--color-white);
      flex-shrink: 0;
    }

    .character-info-header {
      display: flex;
      align-items: center;
      gap: var(--spacing-sm);
      margin-left: 60px; /* Space for hamburger menu */
    }

    .character-avatar-header {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      overflow: hidden;
      border: 2px solid var(--color-teal);
      flex-shrink: 0;
    }

    .character-avatar-header img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .character-details {
      min-width: 0;
    }

    .character-name-header {
      font-family: var(--font-secondary);
      font-size: 18px;
      font-weight: 700;
      color: var(--color-navy);
      margin-bottom: 2px;
    }

    .character-status {
      color: var(--color-gray);
      font-size: 14px;
    }

    .chat-actions {
      display: flex;
      gap: var(--spacing-xs);
      flex-shrink: 0;
    }

    .action-btn {
      width: 36px;
      height: 36px;
      background: var(--color-light-gray);
      border: none;
      border-radius: var(--radius-sm);
      color: var(--color-gray);
      cursor: pointer;
      transition: all var(--transition-base);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      position: relative;
    }

    .action-btn:hover {
      background: var(--color-teal);
      color: var(--color-white);
    }

    /* Memory notification badge */
    .memory-btn.has-notification::after {
      content: '';
      position: absolute;
      top: 2px;
      right: 2px;
      width: 8px;
      height: 8px;
      background: var(--color-coral);
      border-radius: 50%;
      border: 1px solid var(--color-white);
    }

    /* Chat Messages Area */
    .chat-messages {
      flex: 1;
      padding: var(--spacing-lg);
      overflow-y: auto;
      background: var(--color-off-white);
    }

    .welcome-message {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
      color: var(--color-gray);
    }

    .welcome-icon {
      font-size: 48px;
      margin-bottom: var(--spacing-md);
    }

    .welcome-message h3 {
      font-family: var(--font-secondary);
      font-size: 24px;
      font-weight: 600;
      color: var(--color-navy);
      margin-bottom: var(--spacing-xs);
    }

    .conversation-starters {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-sm);
      margin-top: var(--spacing-lg);
      max-width: 300px;
    }

    .starter-btn {
      background: var(--color-white);
      border: 1px solid var(--color-light-gray);
      border-radius: var(--radius-md);
      padding: var(--spacing-sm);
      font-size: 13px;
      color: var(--color-navy);
      cursor: pointer;
      transition: all var(--transition-base);
      text-align: center;
    }

    .starter-btn:hover {
      background: var(--color-teal-light);
      border-color: var(--color-teal);
      color: var(--color-navy);
    }

    .message {
      display: flex;
      gap: var(--spacing-sm);
      margin-bottom: var(--spacing-md);
      max-width: 85%;
    }

    .message.user {
      flex-direction: row-reverse;
      margin-left: auto;
    }

    .message-avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      overflow: hidden;
      flex-shrink: 0;
    }

    .message-avatar img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .message-content {
      background: var(--color-white);
      padding: var(--spacing-sm) var(--spacing-md);
      border-radius: var(--radius-lg);
      color: var(--color-navy);
      line-height: 1.4;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .message.user .message-content {
      background: var(--gradient-primary);
      color: var(--color-white);
    }

    .message-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: var(--spacing-xs);
      font-size: 11px;
      color: var(--color-gray);
    }

    .message-actions {
      display: flex;
      gap: var(--spacing-xs);
    }

    .message-action {
      background: none;
      border: none;
      color: var(--color-gray);
      cursor: pointer;
      padding: 2px 4px;
      border-radius: 4px;
      transition: all var(--transition-base);
    }

    .message-action:hover {
      background: var(--color-light-gray);
      color: var(--color-teal);
    }

    /* Chat Input - Selira inspired */
    .chat-input-container {
      padding: var(--spacing-md) var(--spacing-lg);
      border-top: 1px solid var(--color-light-gray);
      background: var(--color-white);
      flex-shrink: 0;
    }

    .chat-input-wrapper {
      display: flex;
      gap: var(--spacing-sm);
      align-items: flex-end;
    }

    #messageInput {
      flex: 1;
      background: var(--color-light-gray);
      border: none;
      border-radius: var(--radius-xl);
      padding: var(--spacing-sm) var(--spacing-md);
      color: var(--color-navy);
      font-family: inherit;
      font-size: 16px; /* Minimum 16px to prevent iOS auto-zoom */
      resize: none;
      max-height: 120px;
      overflow-y: auto;
      outline: none;
    }

    #messageInput:focus {
      background: var(--color-white);
      box-shadow: 0 0 0 2px var(--color-teal-light);
    }

    .send-btn {
      width: 36px;
      height: 36px;
      background: var(--color-teal);
      border: none;
      border-radius: 50%;
      color: var(--color-white);
      cursor: pointer;
      transition: all var(--transition-base);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      flex-shrink: 0;
    }

    .send-btn:hover {
      background: var(--color-teal-dark);
      transform: scale(1.05);
    }

    .send-btn:disabled {
      background: var(--color-gray-light);
      cursor: not-allowed;
      transform: none;
    }

    /* Organize Thoughts Button */
    .organize-btn {
      width: 36px;
      height: 36px;
      background: var(--color-coral-light);
      border: none;
      border-radius: 50%;
      color: var(--color-white);
      cursor: pointer;
      transition: all var(--transition-base);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      margin-right: var(--spacing-xs);
    }

    .organize-btn:hover {
      background: var(--color-coral);
      transform: scale(1.05);
    }

    /* Topics Panel */
    .topics-panel {
      position: fixed;
      bottom: 80px;
      left: var(--spacing-lg);
      right: var(--spacing-lg);
      background: var(--color-white);
      border: 1px solid var(--color-light-gray);
      border-radius: var(--radius-lg);
      padding: var(--spacing-md);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
      display: none;
      z-index: 100;
    }

    .topics-panel.open {
      display: block;
      animation: slideUp 0.3s ease-out;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .topics-header {
      font-weight: 600;
      color: var(--color-navy);
      margin-bottom: var(--spacing-sm);
      text-align: center;
    }

    .topics-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: var(--spacing-xs);
    }

    .topic-btn {
      background: var(--color-off-white);
      border: 1px solid var(--color-light-gray);
      border-radius: var(--radius-md);
      padding: var(--spacing-sm);
      font-size: 13px;
      color: var(--color-navy);
      cursor: pointer;
      transition: all var(--transition-base);
      text-align: center;
    }

    .topic-btn:hover {
      background: var(--color-teal-light);
      border-color: var(--color-teal);
      color: var(--color-navy);
    }

    /* Memory and Customize buttons */
    .memory-btn, .customize-btn {
      background: var(--gradient-primary);
      color: var(--color-white);
    }

    .memory-btn:hover, .customize-btn:hover {
      transform: scale(1.05);
    }

    /* Mobile Menu Button - borderless hamburger icon */
    .mobile-menu-btn {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 1000;
      width: 36px;
      height: 36px;
      background: transparent;
      border: none;
      color: var(--color-navy);
      font-size: 18px;
      cursor: pointer;
      transition: all var(--transition-base);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .mobile-menu-btn:hover {
      color: var(--color-teal);
      transform: scale(1.1);
    }

    /* Typing indicator */
    .typing-dots {
      display: flex;
      gap: 4px;
      align-items: center;
      padding: var(--spacing-xs) 0;
    }

    .typing-dots span {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--color-gray);
      animation: typing 1.4s infinite;
    }

    .typing-dots span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-dots span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes typing {
      0%, 60%, 100% {
        opacity: 0.3;
        transform: scale(0.8);
      }
      30% {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Mic Button Styles */
    .mic-button {
      width: 36px;
      height: 36px;
      background: var(--color-light-gray);
      border: none;
      border-radius: 50%;
      color: var(--color-gray);
      cursor: pointer;
      transition: all var(--transition-base);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .mic-button:hover {
      background: var(--color-teal);
      color: var(--color-white);
      transform: scale(1.05);
    }

    .mic-button.recording {
      background: var(--color-coral);
      color: var(--color-white);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.1); }
    }

    /* Upgrade Overlay Styles */
    .upgrade-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(30, 41, 59, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      z-index: 999999999;
      display: none;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: all var(--transition-base);
    }

    .upgrade-overlay.active {
      display: flex;
      opacity: 1;
    }

    .upgrade-modal {
      background: var(--color-white);
      border-radius: var(--radius-xl);
      padding: var(--spacing-3xl);
      box-shadow: var(--shadow-xl);
      max-width: 90vw;
      width: 100%;
      max-width: 480px;
      max-height: 90vh;
      overflow-y: auto;
      transform: scale(0.9) translateY(20px);
      transition: all var(--transition-base);
      text-align: center;
      position: relative;
    }

    .upgrade-overlay.active .upgrade-modal {
      transform: scale(1) translateY(0);
    }

    .upgrade-modal::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--gradient-primary);
      border-radius: var(--radius-xl) var(--radius-xl) 0 0;
    }

    .upgrade-header {
      margin-bottom: var(--spacing-lg);
    }

    .upgrade-title {
      font-family: var(--font-secondary);
      font-size: var(--font-size-2xl);
      font-weight: 700;
      color: var(--color-navy);
      margin: 0 0 var(--spacing-sm) 0;
      letter-spacing: -0.01em;
    }

    .upgrade-subtitle {
      color: var(--color-gray);
      font-size: var(--font-size-base);
      margin: 0 0 var(--spacing-xl) 0;
      line-height: 1.5;
    }

    .upgrade-benefits {
      background: var(--color-off-white);
      border-radius: var(--radius-lg);
      padding: var(--spacing-lg);
      margin-bottom: var(--spacing-lg);
      text-align: left;
    }

    .benefit-item {
      display: flex;
      align-items: center;
      margin-bottom: var(--spacing-sm);
      font-size: var(--font-size-sm);
      font-weight: 500;
      color: var(--color-navy);
    }

    .benefit-item:last-child {
      margin-bottom: 0;
    }

    .benefit-icon {
      margin-right: var(--spacing-sm);
      font-size: var(--font-size-lg);
      filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
    }

    .upgrade-buttons {
      display: flex;
      gap: var(--spacing-md);
      justify-content: center;
    }

    .upgrade-btn {
      padding: var(--spacing-md) var(--spacing-xl);
      border: none;
      border-radius: var(--radius-lg);
      font-size: var(--font-size-base);
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-base);
      font-family: var(--font-primary);
      position: relative;
      overflow: hidden;
    }

    .upgrade-btn.primary {
      background: var(--gradient-primary);
      color: var(--color-white);
      box-shadow: var(--shadow-colored);
    }

    .upgrade-btn.primary:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-xl);
    }

    .upgrade-btn.secondary {
      background: var(--color-white);
      color: var(--color-gray);
      border: 2px solid var(--color-light-gray);
    }

    .upgrade-btn.secondary:hover {
      border-color: var(--color-teal);
      color: var(--color-teal);
      transform: translateY(-1px);
    }

    @media (max-width: 768px) {
      .upgrade-modal {
        margin: var(--spacing-lg);
        padding: var(--spacing-2xl);
        max-width: none;
        max-height: 90vh;
      }
      
      .upgrade-title {
        font-size: var(--font-size-xl);
      }
      
      .upgrade-buttons {
        flex-direction: column;
      }
    }

    /* Modal Styles for Memory Hub and Customize */
    .modal-backdrop {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: var(--spacing-md);
    }

    /* Memory Hub Modal Styles */
    .memory-hub-modal {
      background: var(--color-white);
      border-radius: var(--radius-xl);
      max-width: 700px;
      width: 100%;
      max-height: 80vh; /* Fallback */
      max-height: 80dvh; /* Dynamic viewport height for mobile */
      overflow: hidden;
      box-shadow: var(--shadow-lg);
      display: flex;
      flex-direction: column;
      animation: slideUp 0.3s ease-out;
    }

    .memory-hub-modal .modal-close {
      position: absolute;
      top: 30px;
      right: 30px;
      background: transparent;
      border: none;
      width: auto;
      height: auto;
      font-size: 28px;
      color: var(--color-gray-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      z-index: 10;
      padding: 0;
      line-height: 1;
    }

    .memory-hub-modal .modal-close:hover {
      color: var(--color-navy);
      transform: scale(1.1);
    }

    .memory-hub-header {
      padding: 30px 30px 20px;
      border-bottom: 1px solid var(--color-light-gray);
      text-align: center;
      position: relative;
    }

    .memory-hub-body {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    #memoryHubContent {
      flex: 1;
      overflow-y: auto;
      padding: 20px 30px;
    }

    .memory-item {
      background: var(--color-off-white);
      border-radius: var(--radius-lg);
      padding: 20px;
      margin-bottom: 16px;
      border: 1px solid var(--color-light-gray);
      transition: all 0.3s ease;
    }

    .memory-item:hover {
      border-color: var(--color-teal);
      box-shadow: var(--shadow-md);
    }

    .memory-question {
      font-weight: 600;
      color: var(--color-navy);
      font-size: 14px;
      margin-bottom: 8px;
    }

    .memory-answer {
      color: var(--color-gray-dark);
      line-height: 1.5;
      font-size: 14px;
    }

    .memory-hub-footer {
      padding: 20px 30px;
      border-top: 1px solid var(--color-light-gray);
      display: flex;
      justify-content: center;
    }

    .update-answers-btn {
      background: var(--gradient-primary);
      color: white;
      border: none;
      border-radius: var(--radius-lg);
      padding: 12px 24px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .update-answers-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(20, 184, 166, 0.3);
    }

    .start-onboarding-btn {
      background: var(--gradient-primary);
      color: white;
      border: none;
      border-radius: var(--radius-lg);
      padding: 12px 24px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .no-memories {
      text-align: center;
      padding: 40px 20px;
    }

    .no-memories-title {
      font-family: var(--font-secondary);
      font-size: 20px;
      font-weight: 600;
      color: var(--color-navy);
      margin-bottom: var(--spacing-md);
    }

    .no-memories-text {
      color: var(--color-gray);
      line-height: 1.5;
      margin-bottom: var(--spacing-lg);
    }

    .loading-spinner {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 40px;
      color: var(--color-gray);
    }

    /* Customize Modal Styles */
    .customization-modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: var(--spacing-md);
      overflow-y: auto;
    }

    .customization-modal-content {
      background: var(--color-white);
      border-radius: var(--radius-xl);
      max-width: 800px;
      width: 100%;
      max-height: 90vh; /* Fallback */
      max-height: 90dvh; /* Dynamic viewport height for mobile */
      overflow-y: auto;
      box-shadow: var(--shadow-lg);
      animation: slideUp 0.3s ease-out;
    }

    .customization-header {
      padding: 30px 30px 20px;
      border-bottom: 1px solid var(--color-light-gray);
      text-align: center;
      position: relative;
    }

    .customization-header h2 {
      font-family: var(--font-secondary);
      font-size: 24px;
      font-weight: 700;
      color: var(--color-navy);
      margin: 0 0 8px 0;
    }

    .customization-subtitle {
      color: var(--color-gray);
      font-size: 14px;
      margin: 0;
    }

    .close-modal {
      position: absolute;
      top: 30px;
      right: 30px;
      background: transparent;
      border: none;
      font-size: 28px;
      color: var(--color-gray-dark);
      cursor: pointer;
      transition: all 0.2s ease;
      padding: 0;
      line-height: 1;
    }

    .close-modal:hover {
      color: var(--color-navy);
      transform: scale(1.1);
    }

    .customization-body {
      padding: 20px 30px 30px;
    }

    .form-section {
      margin-bottom: 30px;
    }

    .form-section h2 {
      font-family: var(--font-secondary);
      font-size: 18px;
      font-weight: 600;
      color: var(--color-navy);
      margin-bottom: var(--spacing-md);
    }

    .form-group {
      margin-bottom: var(--spacing-lg);
    }

    .form-group label {
      display: block;
      font-weight: 600;
      color: var(--color-navy);
      margin-bottom: var(--spacing-xs);
      font-size: 14px;
    }

    .form-group input[type="text"],
    .form-group textarea,
    .form-group select {
      width: 100%;
      padding: var(--spacing-sm);
      border: 1px solid var(--color-light-gray);
      border-radius: var(--radius-md);
      font-family: inherit;
      font-size: 14px;
      transition: border-color var(--transition-base);
    }

    .form-group input[type="text"]:focus,
    .form-group textarea:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--color-teal);
      box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
    }

    .char-counter {
      text-align: right;
      font-size: 12px;
      color: var(--color-gray);
      margin-top: var(--spacing-xs);
    }

    /* Personality Section */
    .personality-section {
      padding: var(--spacing-xl);
      border: 2px solid var(--color-light-gray);
      border-radius: var(--radius-lg);
      background: var(--color-off-white);
      margin-bottom: var(--spacing-lg);
    }

    .personality-section h3 {
      margin: 0 0 var(--spacing-lg) 0;
      font-family: var(--font-secondary);
      font-size: var(--font-size-lg);
      color: var(--color-navy);
      font-weight: 600;
      line-height: 1.4;
    }

    /* Sliders */
    .slider-group {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-md);
    }

    .slider-item {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-xs);
    }

    .slider-labels {
      display: flex;
      justify-content: space-between;
      font-size: var(--font-size-sm);
      color: var(--color-gray);
    }

    .slider-label {
      font-weight: 500;
    }

    .personality-slider {
      width: 100%;
      height: 8px;
      border-radius: 4px;
      background: var(--color-light-gray);
      outline: none;
      -webkit-appearance: none;
    }

    .personality-slider::-webkit-slider-thumb {
      appearance: none;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--color-teal);
      cursor: pointer;
      border: 2px solid var(--color-white);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .personality-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: var(--color-teal);
      cursor: pointer;
      border: 2px solid var(--color-white);
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    /* Personality Buttons */
    .button-group-personality {
      display: flex;
      flex-wrap: wrap;
      gap: var(--spacing-sm);
    }

    .personality-button {
      padding: var(--spacing-sm) var(--spacing-md);
      border: 2px solid var(--color-light-gray);
      border-radius: var(--radius-full);
      background: var(--color-white);
      color: var(--color-gray-dark);
      font-size: var(--font-size-sm);
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-base);
      outline: none;
      position: relative;
      display: inline-block;
      line-height: 1.2;
    }

    .personality-button:hover {
      background: var(--color-off-white);
      border-color: var(--color-gray);
      transform: translateY(-2px);
      box-shadow: var(--shadow-sm);
    }

    .personality-button.selected {
      background: var(--gradient-primary);
      color: var(--color-white);
      border-color: transparent;
      box-shadow: var(--shadow-md);
    }

    .personality-button.selected:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-lg);
    }

    /* Selection counters */
    .selection-counter {
      font-size: var(--font-size-xs);
      color: var(--color-gray);
      margin-top: var(--spacing-xs);
      text-align: right;
      font-style: italic;
    }

    .selection-counter.at-limit {
      color: var(--color-coral);
      font-weight: 600;
    }

    /* Voice Settings Styles */
    .voice-select {
      width: 100%;
      padding: var(--spacing-md) var(--spacing-lg);
      border: 2px solid var(--color-light-gray);
      border-radius: var(--radius-md);
      font-size: var(--font-size-md);
      background: var(--color-white);
      color: var(--color-navy);
      transition: all var(--transition-base);
      cursor: pointer;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%2314b8a6' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right var(--spacing-md) center;
      background-size: 20px;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      padding-right: calc(var(--spacing-lg) + 24px);
    }
    
    .voice-select:hover {
      border-color: var(--color-teal);
      background-color: var(--color-off-white);
      box-shadow: var(--shadow-sm);
    }
    
    .voice-select:focus {
      outline: none;
      border-color: var(--color-teal);
      box-shadow: 0 0 0 3px rgba(20, 184, 166, 0.1);
    }
    
    .preview-voice-btn {
      display: inline-flex;
      align-items: center;
      gap: var(--spacing-sm);
      padding: var(--spacing-md) var(--spacing-xl);
      background-color: var(--color-white);
      color: var(--color-teal);
      border: 2px solid var(--color-teal);
      border-radius: 50px;
      font-size: var(--font-size-md);
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-base);
    }
    
    .preview-voice-btn:hover:not(:disabled) {
      background-color: var(--color-teal);
      color: var(--color-white);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(45, 183, 181, 0.3);
    }
    
    .preview-voice-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Customization Actions */
    .customization-actions {
      display: flex;
      gap: var(--spacing-md);
      justify-content: flex-end;
      margin-top: var(--spacing-xl);
      padding-top: var(--spacing-xl);
      border-top: 1px solid var(--color-light-gray);
    }

    .auto-save-indicator {
      display: flex;
      align-items: center;
      gap: var(--spacing-xs);
      color: var(--color-teal);
      font-size: var(--font-size-sm);
    }

    .btn-primary-form {
      background: var(--gradient-primary);
      color: var(--color-white);
      box-shadow: var(--shadow-colored);
      padding: var(--spacing-md) var(--spacing-xl);
      border-radius: var(--radius-md);
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-base);
      font-family: var(--font-primary);
      font-size: var(--font-size-base);
      border: none;
      white-space: nowrap;
    }

    .btn-primary-form:hover:not(:disabled) {
      opacity: 0.9;
      transform: translateY(-2px);
      box-shadow: var(--shadow-xl);
    }

    .btn-secondary-form {
      background: var(--color-light-gray);
      color: var(--color-navy);
      border: 1px solid var(--color-light-gray);
      border-radius: var(--radius-md);
      padding: var(--spacing-sm) var(--spacing-md);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-base);
    }

    .btn-secondary-form:hover {
      background: var(--color-teal);
      color: var(--color-white);
      border-color: var(--color-teal);
    }

    .form-actions {
      display: flex;
      gap: var(--spacing-md);
      justify-content: flex-end;
      padding-top: var(--spacing-lg);
      border-top: 1px solid var(--color-light-gray);
      margin-top: var(--spacing-lg);
    }

    .btn-primary {
      background: var(--gradient-primary);
      color: white;
      border: none;
      border-radius: var(--radius-md);
      padding: var(--spacing-sm) var(--spacing-lg);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all var(--transition-base);
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(20, 184, 166, 0.3);
    }

    .btn-secondary {
      background: var(--color-white);
      color: var(--color-navy);
      border: 1px solid var(--color-light-gray);
      border-radius: var(--radius-md);
      padding: var(--spacing-sm) var(--spacing-lg);
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      transition: all var(--transition-base);
    }

    .btn-secondary:hover {
      background: var(--color-light-gray);
    }

    /* Legacy modal styles for compatibility */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-base);
    }

    .modal-overlay.open {
      opacity: 1;
      visibility: visible;
    }

    .modal-content {
      background: var(--color-white);
      border-radius: var(--radius-lg);
      padding: var(--spacing-xl);
      max-width: 90vw;
      max-height: 90vh; /* Fallback */
      max-height: 90dvh; /* Dynamic viewport height for mobile */
      overflow-y: auto;
      box-shadow: var(--shadow-lg);
      transform: scale(0.95);
      transition: transform var(--transition-base);
    }

    .modal-overlay.open .modal-content {
      transform: scale(1);
    }

    .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: var(--spacing-lg);
    }

    .modal-title {
      font-family: var(--font-secondary);
      font-size: 24px;
      font-weight: 600;
      color: var(--color-navy);
    }

    .modal-subtitle {
      color: var(--color-gray);
      font-size: 14px;
      margin: 0;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: var(--color-gray);
      cursor: pointer;
      transition: color var(--transition-base);
    }

    .modal-close:hover {
      color: var(--color-navy);
    }

    /* Disclaimer Styles */
    .disclaimer {
      font-size: 12px;
      color: var(--color-gray);
      text-align: center;
      line-height: 1.4;
      margin-top: var(--spacing-xs);
      padding: var(--spacing-xs) var(--spacing-sm);
      background: transparent;
      border-radius: var(--radius-sm);
    }

    /* Mobile Menu Overlay */
    .mobile-menu-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(30, 41, 59, 0.95);
      backdrop-filter: blur(20px);
      z-index: 500;
      opacity: 0;
      visibility: hidden;
      transition: all var(--transition-base);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .mobile-menu-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .mobile-menu-content {
      background: var(--color-white);
      border-radius: var(--radius-lg);
      padding: var(--spacing-2xl) var(--spacing-xl);
      box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1);
      max-width: 90vw;
      width: 100%;
      max-width: 400px;
      transform: scale(0.9) translateY(20px);
      transition: all var(--transition-base);
      position: relative;
    }

    .mobile-menu-overlay.active .mobile-menu-content {
      transform: scale(1) translateY(0);
    }

    .mobile-menu-header {
      text-align: center;
      margin-bottom: var(--spacing-xl);
    }

    .mobile-menu-logo {
      font-family: var(--font-secondary);
      font-size: 24px;
      font-weight: 800;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: var(--spacing-xs);
    }

    .mobile-menu-subtitle {
      color: var(--color-gray);
      font-size: 14px;
    }

    .mobile-menu-nav {
      display: flex;
      flex-direction: column;
      gap: var(--spacing-sm);
    }

    .mobile-menu-link {
      display: flex;
      align-items: center;
      padding: var(--spacing-sm) var(--spacing-md);
      color: var(--color-navy);
      text-decoration: none;
      font-weight: 500;
      transition: all var(--transition-base);
      border-radius: var(--radius-md);
      background: var(--color-off-white);
    }

    .mobile-menu-link:hover {
      background: var(--color-light-gray);
      color: var(--color-teal);
      transform: translateX(4px);
    }

    .mobile-menu-link-icon {
      margin-right: var(--spacing-sm);
      font-size: 18px;
    }

    .mobile-menu-link.btn-primary {
      background: var(--gradient-primary);
      color: var(--color-white);
      justify-content: center;
      font-weight: 700;
      margin-top: var(--spacing-md);
    }

    .mobile-menu-link.btn-primary:hover {
      background: var(--gradient-primary);
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,0,0,0.15);
    }

    /* Mobile Responsive - Selira inspired */
    @media (max-width: 768px) {
      .chat-header {
        padding: var(--spacing-sm) var(--spacing-md);
        position: relative;
      }

      .character-avatar-header {
        width: 36px;
        height: 36px;
      }

      .character-name-header {
        font-size: 16px;
      }

      .chat-messages {
        padding: var(--spacing-md);
      }

      .chat-input-container {
        padding: var(--spacing-sm) var(--spacing-md);
      }

      .topics-panel {
        left: var(--spacing-md);
        right: var(--spacing-md);
        bottom: 70px;
      }

      .message {
        max-width: 90%;
      }

      .conversation-starters {
        grid-template-columns: 1fr;
      }

      /* Memory Hub Mobile */
      .memory-hub-modal {
        max-height: 90vh; /* Fallback */
        max-height: 90dvh; /* Dynamic viewport height for mobile */
        border-radius: var(--radius-lg);
      }

      .memory-hub-header {
        padding: 50px 20px 15px;
      }

      .memory-hub-modal .modal-close {
        top: 15px;
        right: 15px;
        font-size: 24px;
      }

      #memoryHubContent {
        padding: 15px 20px;
      }

      .memory-item {
        padding: 15px;
      }

      .memory-hub-footer {
        padding: 15px 20px;
        flex-direction: column;
        gap: 10px;
      }

      /* Customize Modal Mobile */
      .customization-modal {
        padding: var(--spacing-sm);
      }

      .customization-modal-content {
        max-height: 95vh; /* Fallback */
        max-height: 95dvh; /* Dynamic viewport height for mobile */
        border-radius: var(--radius-lg);
      }

      .customization-header {
        padding: 50px 20px 15px;
      }

      .close-modal {
        top: 15px;
        right: 15px;
        font-size: 24px;
      }

      .customization-body {
        padding: 15px 20px 20px;
      }

      .form-actions {
        flex-direction: column-reverse;
      }

      .form-actions button {
        width: 100%;
      }
    }

    /* Very compact mobile (Selira-style) */
    @media (max-width: 480px) {
      .chat-header {
        padding: var(--spacing-xs) var(--spacing-sm);
      }

      .character-avatar-header {
        width: 32px;
        height: 32px;
      }

      .character-name-header {
        font-size: 15px;
      }

      .chat-messages {
        padding: var(--spacing-sm);
      }

      .chat-input-container {
        padding: var(--spacing-xs) var(--spacing-sm);
      }

      .topics-panel {
        left: var(--spacing-xs);
        right: var(--spacing-xs);
      }

      .action-btn {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }

      .send-btn, .organize-btn, .mic-button {
        width: 32px;
        height: 32px;
      }

      /* Personality system mobile styles */
      .personality-section {
        padding: var(--spacing-md);
        margin-bottom: var(--spacing-md);
      }

      .personality-section h3 {
        font-size: var(--font-size-base);
        margin-bottom: var(--spacing-md);
      }

      .button-group-personality {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: var(--spacing-xs);
      }

      .personality-button {
        padding: 6px 12px;
        font-size: 12px;
        min-height: auto;
        line-height: 1.2;
      }

      .slider-label {
        font-size: var(--font-size-xs);
      }

      .selection-counter {
        font-size: var(--font-size-xs);
      }

      .voice-select {
        padding: var(--spacing-sm) var(--spacing-md);
        font-size: var(--font-size-base);
      }

      .preview-voice-btn {
        padding: var(--spacing-sm) var(--spacing-md);
        font-size: var(--font-size-sm);
        width: 100%;
        margin-top: var(--spacing-sm);
      }

      .customization-actions {
        flex-wrap: wrap;
        padding: var(--spacing-md) !important;
      }

      .customization-actions button {
        min-width: 100px;
        font-size: var(--font-size-sm);
      }

      .auto-save-indicator {
        order: -1;
        width: 100%;
        margin-bottom: var(--spacing-sm);
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Main Chat Area -->
    <main class="chat-main">
      <!-- Mobile Menu Button -->
      <button class="mobile-menu-btn" onclick="toggleMobileMenu()" title="Menu">
        ‚ò∞
      </button>

      <!-- Chat Header -->
      <header class="chat-header">
        <div class="character-info-header">
          <div class="character-avatar-header" id="characterAvatarHeader">
            <img src="/avatars/emily-1754251534076.webp" alt="AI Companion" onerror="this.style.display='none';" id="headerAvatarImg">
          </div>
          <div class="character-details">
            <h2 class="character-name-header" id="characterNameHeader">AI Companion</h2>
            <p class="character-status" id="characterStatusHeader">Your Thoughtful Guide</p>
          </div>
        </div>
        <div class="chat-actions">
          <button class="action-btn memory-btn" onclick="openMemoryHub()" title="Memory Hub" id="memoryBtn">
            üß†
          </button>
          <button class="action-btn customize-btn" onclick="openCustomize()" title="Customize" id="customizeBtn">
            ‚öôÔ∏è
          </button>
        </div>
      </header>

      <!-- Chat Messages Area -->
      <div class="chat-messages" id="chatMessages">
        <div class="welcome-message">
          <div class="welcome-icon">üí≠</div>
          <h3>Welcome to Narrin AI</h3>
          <p id="welcomeText">Transform your thoughts into clarity with your AI companion!</p>
          <div class="conversation-starters" id="conversationStarters">
            <button class="starter-btn" onclick="selectStarter('How are you feeling today?')">Daily Check-in</button>
            <button class="starter-btn" onclick="selectStarter('What\\'s been on your mind lately?')">Share Thoughts</button>
            <button class="starter-btn" onclick="selectStarter('Help me organize my goals.')">Set Goals</button>
            <button class="starter-btn" onclick="selectStarter('I need someone to talk to.')">Just Talk</button>
          </div>
        </div>
      </div>

      <!-- Chat Input -->
      <div class="chat-input-container">
        <div class="chat-input-wrapper">
          <button class="organize-btn" onclick="toggleTopics()" title="Organize Thoughts">
            +
          </button>
          <textarea 
            id="messageInput" 
            placeholder="Share your thoughts" 
            rows="1"
            maxlength="2000"
          ></textarea>
          <button class="mic-button" onclick="toggleSpeechToText()" id="micButton" title="Voice input">
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M12 1C10.34 1 9 2.34 9 4V12C9 13.66 10.34 15 12 15C13.66 15 15 13.66 15 12V4C15 2.34 13.66 1 12 1Z"/>
              <path d="M19 10V12C19 15.866 15.866 19 12 19C8.13401 19 5 15.866 5 12V10"/>
              <path d="M12 19V23"/>
              <path d="M8 23H16"/>
            </svg>
          </button>
          <button class="send-btn" id="sendBtn" onclick="sendMessage()">
            ‚û§
          </button>
        </div>
        
        <!-- AI Disclaimer -->
        <div class="disclaimer">
          <span>AI companion - not a real person</span>
        </div>
      </div>
    </main>

    <!-- Mobile Menu Overlay -->
    <div class="mobile-menu-overlay" id="mobileMenuOverlay">
      <div class="mobile-menu-content">
        <div class="mobile-menu-header">
          <a href="/" class="mobile-menu-logo" style="text-decoration: none;">Narrin AI</a>
          <div class="mobile-menu-subtitle">AI Companion Platform</div>
        </div>
        <nav class="mobile-menu-nav">
          <a href="/chat-overview" class="mobile-menu-link">
            <span class="mobile-menu-link-icon">üí¨</span>
            My Companions
          </a>
          <a href="/pricing" class="mobile-menu-link">
            <span class="mobile-menu-link-icon">üíé</span>
            Plans
          </a>
          <a href="/memory-import" class="mobile-menu-link">
            <span class="mobile-menu-link-icon">üß†</span>
            Import Memory
          </a>
          <a href="/news" class="mobile-menu-link">
            <span class="mobile-menu-link-icon">üì∞</span>
            News & Insights
          </a>
          <a href="#" class="mobile-menu-link" id="mobileLoginBtn">
            <span class="mobile-menu-link-icon">üîê</span>
            Login/Register
          </a>
          <a href="/profile" class="mobile-menu-link" id="mobileProfileLink" style="display: none;">
            <span class="mobile-menu-link-icon">üë§</span>
            Profile
          </a>
          <a href="/create-character" class="mobile-menu-link btn-primary">
            <span class="mobile-menu-link-icon">‚ú®</span>
            Create Companion
          </a>
        </nav>
      </div>
    </div>

    <!-- Topics Panel -->
    <div class="topics-panel" id="topicsPanel">
      <div class="topics-header">Choose a topic to explore:</div>
      <div class="topics-grid" id="topicsGrid">
        <button class="topic-btn" onclick="selectTopic('daily-reflection')">Daily Reflection</button>
        <button class="topic-btn" onclick="selectTopic('goal-setting')">Goal Setting</button>
        <button class="topic-btn" onclick="selectTopic('mindfulness')">Mindfulness</button>
        <button class="topic-btn" onclick="selectTopic('relationships')">Relationships</button>
        <button class="topic-btn" onclick="selectTopic('productivity')">Productivity</button>
        <button class="topic-btn" onclick="selectTopic('creativity')">Creativity</button>
      </div>
    </div>

    <!-- Memory Hub Modal -->
    <div id="memoryHubModal" class="modal-backdrop" style="display: none;">
      <div class="memory-hub-modal">
        <div class="memory-hub-header">
          <button class="modal-close" onclick="closeMemoryHub()">‚úï</button>
          <h2 class="modal-title">üß† Memory Hub</h2>
          <p class="modal-subtitle">Your personal details and conversation preferences</p>
        </div>
        
        <div class="memory-hub-body">
          <div id="memoryHubContent">
            <div class="loading-spinner">Loading your memories...</div>
          </div>
          
          <div class="memory-hub-footer" style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <a href="/memory-import" class="update-answers-btn" style="text-decoration: none; display: inline-flex; align-items: center; justify-content: center; flex-direction: column; gap: 4px;">
              <div style="display: flex; align-items: center; gap: 8px;">
                <span>üì•</span> Import from ChatGPT
              </div>
              <span id="import-timestamp" style="font-size: 12px; opacity: 0.7; display: none;"></span>
            </a>
            <button class="update-answers-btn" onclick="restartOnboarding()">
              <span>üîÑ</span> Take Personal Quiz
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- Character Customization Modal -->
    <div class="customization-modal" id="customizationModal" style="display: none;">
      <div class="customization-modal-content">
        <div class="customization-header">
          <button class="close-modal" onclick="closeCustomizationModal()">‚úï</button>
          <h2>‚ú® Customize Companion</h2>
          <p class="customization-subtitle">Make this companion your own! Your customized version will be saved privately for you.</p>
        </div>
        
        <div class="customization-body">
        
        <form id="customizationForm">
          <!-- Basic Information -->
          <div class="form-section">
            <h2>Basic Information</h2>
            
            <div class="form-group">
              <label for="customName">Companion Name</label>
              <input type="text" id="customName" placeholder="Give your companion a name" maxlength="50">
              <div class="char-counter"><span id="nameCounter">0</span>/50</div>
            </div>
            
            <div class="form-group">
              <label for="customAvatar">Companion Profile Image</label>
              <div style="display: flex; gap: var(--spacing-md); align-items: flex-start; flex-wrap: wrap;">
                <!-- Image Preview on Left -->
                <div id="customAvatarPreview" style="flex: 0 0 auto; min-width: 80px;">
                  <img id="customAvatarImg" src="" alt="Avatar preview" style="width: 80px; height: 80px; border-radius: 50%; object-fit: cover; display: none;">
                  <div id="avatarPlaceholder" style="width: 80px; height: 80px; border-radius: 50%; background: var(--color-light-gray); display: flex; align-items: center; justify-content: center; font-size: 32px; color: var(--color-gray);">üë§</div>
                </div>
                
                <!-- Controls on Right -->
                <div style="flex: 1; min-width: 200px; display: flex; flex-direction: column; gap: var(--spacing-sm);">
                  <input type="file" id="customAvatarFile" accept="image/*" style="display: none;">
                  <div style="display: flex; gap: var(--spacing-sm); flex-wrap: wrap; align-items: center;">
                    <button type="button" class="btn-secondary-form" onclick="document.getElementById('customAvatarFile').click()" style="flex: 0 0 auto;">
                      Choose File
                    </button>
                    <span id="customAvatarFileName" style="display: none;">No file chosen</span>
                  </div>
                  <button type="button" class="btn-secondary-form" onclick="generateCompanionImage()" style="width: 100%;" id="generateImageBtn">
                    üé≤ Select Random Avatar
                  </button>
                </div>
              </div>
              <input type="hidden" id="customAvatarUrl" value="">
            </div>
          </div>

          <!-- Transfer History Option -->
          <div class="form-section" id="transferSection" style="display: none;">
            <h2>Transfer Conversation History</h2>
            <div class="form-group">
              <label class="checkbox-label" style="display: flex; align-items: center; gap: var(--spacing-md); cursor: pointer;">
                <input type="checkbox" id="transferHistory" style="width: 24px; height: 24px; cursor: pointer;">
                <div style="flex: 1;">
                  <div style="font-size: var(--font-size-sm); color: var(--color-gray); line-height: 1.5;">
                    Transfer conversation history and memories from the current character to your new customized version. This allows you to continue your conversation seamlessly with the new character.
                  </div>
                </div>
              </label>
            </div>
          </div>


          <!-- Personality Builder -->
          <div class="form-section">
            <h2>Personality</h2>
            
            <!-- Personality Spectrum -->
            <div class="personality-section">
              <h3>Personality Spectrum</h3>
              <div class="slider-group">
                <div class="slider-item">
                  <div class="slider-labels">
                    <span class="slider-label">Introvert</span>
                    <span class="slider-label">Extravert</span>
                  </div>
                  <input type="range" min="0" max="100" value="50" class="personality-slider" id="introvertExtravert" data-trait="social">
                </div>
                
                <div class="slider-item">
                  <div class="slider-labels">
                    <span class="slider-label">Logical</span>
                    <span class="slider-label">Emotional</span>
                  </div>
                  <input type="range" min="0" max="100" value="50" class="personality-slider" id="logicalEmotional" data-trait="thinking">
                </div>
                
                <div class="slider-item">
                  <div class="slider-labels">
                    <span class="slider-label">Serious</span>
                    <span class="slider-label">Playful</span>
                  </div>
                  <input type="range" min="0" max="100" value="50" class="personality-slider" id="seriousPlayful" data-trait="mood">
                </div>
                
                <div class="slider-item">
                  <div class="slider-labels">
                    <span class="slider-label">Formal</span>
                    <span class="slider-label">Casual</span>
                  </div>
                  <input type="range" min="0" max="100" value="50" class="personality-slider" id="formalCasual" data-trait="formality">
                </div>
                
                <div class="slider-item">
                  <div class="slider-labels">
                    <span class="slider-label">Patient</span>
                    <span class="slider-label">Impulsive</span>
                  </div>
                  <input type="range" min="0" max="100" value="50" class="personality-slider" id="patientImpulsive" data-trait="tempo">
                </div>
              </div>
            </div>
            
            <!-- Character Traits -->
            <div class="personality-section">
              <h3>Character Traits</h3>
              <div class="button-group-personality" id="personalityTraits">
                <button type="button" class="personality-button" data-trait="wise">Wise</button>
                <button type="button" class="personality-button" data-trait="humorous">Humorous</button>
                <button type="button" class="personality-button" data-trait="mysterious">Mysterious</button>
                <button type="button" class="personality-button" data-trait="caring">Caring</button>
                <button type="button" class="personality-button" data-trait="ambitious">Ambitious</button>
                <button type="button" class="personality-button" data-trait="sarcastic">Sarcastic</button>
                <button type="button" class="personality-button" data-trait="optimistic">Optimistic</button>
                <button type="button" class="personality-button" data-trait="protective">Protective</button>
                <button type="button" class="personality-button" data-trait="curious">Curious</button>
                <button type="button" class="personality-button" data-trait="dramatic">Dramatic</button>
                <button type="button" class="personality-button" data-trait="confident">Confident</button>
                <button type="button" class="personality-button" data-trait="gentle">Gentle</button>
                <button type="button" class="personality-button" data-trait="intense">Intense</button>
                <button type="button" class="personality-button" data-trait="creative">Creative</button>
                <button type="button" class="personality-button" data-trait="analytical">Analytical</button>
              </div>
              <div class="selection-counter" id="traitsCounter">Select 0-5 traits</div>
            </div>
          </div>
          
          <!-- Communication Style (updated) -->
          <div class="form-section">
            <h2>Communication Style</h2>
            
            <!-- Speaking Pattern (existing) -->
            <div class="personality-section">
              <h3>Speaking Pattern</h3>
              <div class="button-group-personality" id="speakingPattern">
                <button type="button" class="personality-button" data-pattern="formal-eloquent">Formal & Eloquent</button>
                <button type="button" class="personality-button" data-pattern="casual-friendly">Casual & Friendly</button>
                <button type="button" class="personality-button" data-pattern="bold-confident">Bold & Confident</button>
                <button type="button" class="personality-button" data-pattern="thoughtful-deep">Thoughtful & Deep</button>
                <button type="button" class="personality-button" data-pattern="witty-sarcastic">Witty & Sarcastic</button>
                <button type="button" class="personality-button" data-pattern="warm-nurturing">Warm & Nurturing</button>
                <button type="button" class="personality-button" data-pattern="direct-practical">Direct & Practical</button>
                <button type="button" class="personality-button" data-pattern="mysterious-cryptic">Mysterious & Cryptic</button>
              </div>
              <div class="selection-counter" id="speakingCounter">Select 0-3 speaking patterns</div>
            </div>
            
          </div>
          
          <!-- Voice Settings -->
          <div class="form-section">
            <h2>Voice Settings</h2>
            
            <div class="form-group">
              <label for="voiceType">Voice Type</label>
              <select id="voiceType" name="voiceType" class="voice-select">
                <option value="none">üîá No Voice - Text only</option>
                <option value="royal_authority">üëë Royal Authority - Authoritative and majestic</option>
                <option value="wise_mentor">üßô‚Äç‚ôÇÔ∏è Wise Mentor - Supportive and experienced</option>
                <option value="caring_therapist">üíù Caring Advisor - Understanding and soothing</option>
                <option value="romantic_partner">üíï Romantic Partner - Warm and loving</option>
                <option value="best_friend">ü§ó Best Friend - Casual and supportive</option>
                <option value="mysterious_stranger">üé≠ Mysterious Stranger - Intriguing and enigmatic</option>
                <option value="cheerful_comedian">üòÑ Cheerful Comedian - Joyful and humorous</option>
                <option value="wise_elder">üë¥ Wise Elder - Experienced and understanding</option>
                <option value="creative_dreamer">üé® Creative Dreamer - Imaginative and inspiring</option>
                <option value="anime_hero">‚ö° Anime Hero - Energetic and youthful</option>
                <option value="business_coach">üìä Business Coach - Professional and motivating</option>
                <option value="fitness_trainer">üí™ Fitness Trainer - Energetic and encouraging</option>
                <option value="storyteller">üìñ Storyteller - Engaging and captivating</option>
                <option value="rebel_spirit">üî• Rebel Spirit - Bold and defiant</option>
                <option value="mystical_guide">üîÆ Mystical Guide - Spiritual and enlightening</option>
              </select>
            </div>
            
            <div class="voice-preview" style="margin-top: var(--spacing-md);">
              <button type="button" id="previewVoiceBtn" class="preview-voice-btn" onclick="previewCustomVoice()">
                üîä Preview Voice
              </button>
            </div>
          </div>
          
          <!-- Extra Instructions -->
          <div class="form-section">
            <h2>Extra Instructions</h2>
            
            <div class="form-group">
              <label for="customPrompt">Extra instructions</label>
              <textarea id="customPrompt" rows="6" placeholder="Add specific instructions for your character. For example:
- Always greet me by my nickname
- Focus on practical advice
- Use humor to lighten the mood
- Ask follow-up questions
- Remember my goals"></textarea>
            </div>
          </div>
          
          <div class="customization-actions">
            <button type="button" class="btn-delete" onclick="deleteCustomization()" style="display: none;" id="deleteCustomBtn">Delete Customization</button>
            <div style="flex: 1;"></div>
            <div class="auto-save-indicator" style="color: var(--color-teal); font-size: var(--font-size-sm); display: flex; align-items: center; gap: var(--spacing-xs);">
              <span>üíæ</span>
              <span>Changes saved automatically</span>
            </div>
            <button type="button" class="btn-primary-form" onclick="closeCustomizationModal()">Done</button>
          </div>
        </form>
      </div>
      </div>
    </div>
  </div>

  <script>
    // Global variables
    let currentCharacter = null;
    let conversationHistory = [];
    let isTyping = false;
    let speechRecognition = null;
    let isRecording = false;
    let currentUser = null;
    let isAuthenticated = false;

    // Initialize
    document.addEventListener('DOMContentLoaded', function() {
      console.log('üöÄ Narrin AI Chat initialized');
      setupEventListeners();
      loadCharacterFromURL();
      initializeAuth();
      
      // Update button tooltips based on authentication status
      setTimeout(() => {
        updateButtonTooltips();
        setupMobileLoginButton(); // Ensure mobile menu is updated
      }, 500);
      
      // Also setup mobile login button with longer delay to ensure DOM is ready
      setTimeout(() => {
        setupMobileLoginButton();
      }, 1000);
    });

    function setupEventListeners() {
      const messageInput = document.getElementById('messageInput');
      
      if (messageInput) {
        messageInput.addEventListener('input', autoResizeTextarea);
        messageInput.addEventListener('keydown', handleKeyDown);
      }

      // Close topics when clicking outside
      document.addEventListener('click', function(e) {
        const topicsPanel = document.getElementById('topicsPanel');
        const organizeBtn = document.querySelector('.organize-btn');
        
        if (topicsPanel && !topicsPanel.contains(e.target) && !organizeBtn.contains(e.target)) {
          topicsPanel.classList.remove('open');
        }
      });

      // Close modals when clicking overlay
      document.addEventListener('click', function(e) {
        if (e.target.classList.contains('modal-overlay')) {
          e.target.classList.remove('open');
        }
      });
    }

    function autoResizeTextarea() {
      const textarea = document.getElementById('messageInput');
      textarea.style.height = 'auto';
      textarea.style.height = Math.min(textarea.scrollHeight, 120) + 'px';
    }

    function handleKeyDown(e) {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      }
    }

    // Character loading functions
    async function loadCharacterFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      const characterSlug = urlParams.get('char') || urlParams.get('character');
      
      if (characterSlug) {
        await loadCharacterDirectly(characterSlug);
      } else {
        // Load default character
        setDefaultCharacter();
      }
    }

    async function loadCharacterDirectly(slug) {
      try {
        console.log('üîÑ Loading character:', slug);
        
        const response = await fetch(`/.netlify/functions/characters?slug=${encodeURIComponent(slug)}`);
        const data = await response.json();
        
        if (data.success && data.characters && data.characters.length > 0) {
          const character = data.characters[0];
          currentCharacter = {
            name: character.Name,
            slug: character.Slug,
            title: character.Character_Title,
            description: character.Character_Description,
            avatar_url: character.Avatar_URL,
            voice_id: character.voice_id
          };
          
          // Load custom avatar if it exists
          await loadCustomCharacterData(currentCharacter);
          
          updateCharacterUI(currentCharacter);
          await loadConversationTopics(slug);
          
          // Show welcome message after chat history is loaded
          setTimeout(() => {
            showWelcomeMessage(currentCharacter);
          }, 100);
          
          // Check for memory hub notification after character is loaded
          setTimeout(() => {
            checkMemoryHubNotification();
            updateButtonTooltips(); // Update tooltips after character is fully loaded
          }, 1000);
        } else {
          console.error('Character not found:', slug);
          setDefaultCharacter();
        }
      } catch (error) {
        console.error('Error loading character:', error);
        setDefaultCharacter();
      }
    }

    function setDefaultCharacter() {
      currentCharacter = {
        slug: 'emily',
        name: 'Emily',
        title: 'Mindful Companion',
        description: 'Your thoughtful guide for mental clarity',
        avatar_url: getRandomAvatar()
      };
      updateCharacterUI(currentCharacter);
    }

    async function loadCustomCharacterData(character) {
      if (!character || !character.slug) return;
      
      const characterSlug = character.slug;
      
      // Try to load from server first for cross-device sync
      let customData = await loadCustomizationFromServer(characterSlug);
      
      // If no server data, fall back to localStorage
      if (!customData) {
        const customizedCharacters = JSON.parse(localStorage.getItem('customizedCharacters') || '{}');
        customData = customizedCharacters[characterSlug];
      }
      
      console.log('üîç Custom data lookup:', {
        characterSlug,
        hasCustomData: !!customData,
        customDataKeys: customData ? Object.keys(customData) : [],
        avatarUrl: customData?.avatar_url
      });
      
      if (customData) {
        console.log('üìÇ Loading custom data for character:', characterSlug, customData);
        
        // Apply custom name
        if (customData.name) {
          character.name = customData.name;
          console.log('üìù Applied custom name:', customData.name);
        }
        
        // Apply custom avatar
        if (customData.avatar_url) {
          character.avatar_url = customData.avatar_url;
          console.log('üñºÔ∏è Loading custom avatar:', customData.avatar_url);
        } else {
          console.log('‚ùå No custom avatar_url found in customData');
        }
        
        // Apply other customizations
        if (customData.extra_instructions) {
          character.customPrompt = customData.extra_instructions;
          character.isCustomized = true;
        }
        
        if (customData.voice_type) {
          character.voice_type = customData.voice_type;
        }
        
        // Apply personality state if it exists
        if (customData.personality_state) {
          character.personality_state = customData.personality_state;
        }
      }
    }

    function updateCharacterUI(character) {
      const nameHeader = document.getElementById('characterNameHeader');
      const statusHeader = document.getElementById('characterStatusHeader');
      const avatarImg = document.getElementById('headerAvatarImg');
      const welcomeText = document.getElementById('welcomeText');
      
      if (nameHeader) nameHeader.textContent = character.name || 'AI Companion';
      if (statusHeader) statusHeader.textContent = character.title || 'Your Thoughtful Guide';
      if (avatarImg) {
        const avatarToUse = character.avatar_url || getRandomAvatar();
        avatarImg.src = avatarToUse;
        avatarImg.alt = character.name;
        console.log('üñºÔ∏è Header avatar set to:', avatarToUse);
      }
      if (welcomeText) {
        welcomeText.textContent = `Transform your thoughts into clarity with ${character.name}!`;
      }
      
      // Load chat history for this character
      loadChatHistory(character.slug);
    }

    function showWelcomeMessage(character) {
      if (!character) return;
      
      // Only show welcome message if this is the first time chatting (no history)
      const historyKey = `chat_history_${character.slug || 'default'}`;
      const existingHistory = localStorage.getItem(historyKey);
      
      // Check if there are any messages already
      let hasMessages = false;
      if (existingHistory) {
        try {
          const history = JSON.parse(existingHistory);
          hasMessages = history.length > 0;
        } catch (e) {
          console.warn('Error parsing chat history for welcome check');
        }
      }
      
      // Only show conversation starter if no previous messages exist
      if (!hasMessages) {
        const welcomeMessage = generateConversationStarter();
        
        if (welcomeMessage) {
          addMessage(welcomeMessage, 'ai');
          
          // Save this welcome message to history so it's not shown again
          saveMessageToHistory(welcomeMessage, 'ai');
        }
      }
    }

    // Generate conversation starter based on character
    function generateConversationStarter() {
      if (!currentCharacter) return null;
      
      const characterName = currentCharacter.name || '';
      const characterSlug = currentCharacter.slug || '';
      
      console.log('üöÄ generateConversationStarter called for:', characterSlug);
      
      // FORCE new companions and Romance companions to get welcoming guide
      const mainCompanions = ['galina', 'blake-devoted-boyfriend', 'emerald', 'sol'];
      const isNewUserCreated = characterSlug.includes('-') && characterSlug.length > 8 && !mainCompanions.includes(characterSlug);
      const isRomanceCompanion = currentCharacter?.character_type === 'romance';
      
      if (isNewUserCreated || isRomanceCompanion) {
        console.log('üéØ FORCING welcoming guide for new companion:', characterSlug);
        const companionType = currentCharacter?.category || 'friendship';
        let baseMessage = "Hey! I'm here to help you find peace and clarity. ";
        
        if (companionType === 'mindfulness') {
          baseMessage = "Hey! I'm here to help you find peace and clarity. ";
        } else if (companionType === 'romance') {
          baseMessage = "Hey there! I'm here to help you navigate matters of the heart and find clarity in your romantic life. ";
        }
        
        return `${baseMessage}To get the most personalized experience:
‚Ä¢ <a href="#" onclick="lazyLoadMemoryHub(); return false;" style="color: var(--color-teal); text-decoration: none;">Take the personal quiz in Memory Hub üß†</a>
‚Ä¢ <a href="#" onclick="lazyLoadCustomize(event); return false;" style="color: var(--color-teal); text-decoration: none;">Customize my personality ‚öôÔ∏è</a>
‚Ä¢ <a href="/memory-import" style="color: var(--color-teal); text-decoration: none;">Import your ChatGPT memories üì•</a>
Ready to start chatting, or would you like to explore these personalization options first?`;
      }
      
      // Standard companions get character-specific messages
      const conversationStarters = {
        'emerald': [
          "Welcome to this peaceful moment. Take a deep breath with me... How are you feeling right now, in this very moment?",
          "Hey there! I'm Emerald, your mindful companion. What's been weighing on your heart lately?", 
          "Welcome, friend. Sometimes the most profound conversations begin with a simple question: How is your heart today?"
        ],
        'sal': [
          "Welcome! Every master was once a beginner. What skill or area of your life are you looking to develop?",
          "Hey! I'm Sal, and I believe in your potential. What challenge are you ready to tackle?",
          "Welcome to this journey of growth. What's one thing you'd like to get better at?"
        ],
        'galina': [
          "Welcome! You know, some of the best conversations happen when we can just be ourselves. What's been weighing on your heart?",
          "Hey there! I'm here to listen and support you. What would you like to talk about?",
          "Welcome to our conversation. How can I help you find clarity today?"
        ],
        'blake-devoted-boyfriend': [
          "Hey beautiful! I've been thinking about you. How was your day?",
          "Welcome back, love. I'm here for whatever you need. What's on your mind?",
          "Hey gorgeous! Tell me what's been happening in your world lately."
        ]
      };
      
      const starters = conversationStarters[characterSlug];
      if (starters && starters.length > 0) {
        const randomStarter = starters[Math.floor(Math.random() * starters.length)];
        console.log('‚úÖ Selected conversation starter for', characterSlug, ':', randomStarter.substring(0, 50) + '...');
        return randomStarter;
      }
      
      // Fallback for other characters
      return "Hello! I'm here to chat and help you organize your thoughts. What's on your mind today?";
    }

    // Conversation topics
    async function loadConversationTopics(characterSlug) {
      try {
        console.log('üìù Loading conversation topics for:', characterSlug);
        
        // Character-specific conversation starters based on category
        const category = currentCharacter?.category || 'general';
        let topics = [];
        
        switch(category.toLowerCase()) {
          case 'mindfulness':
            topics = [
              "I'm feeling overwhelmed, can you help me find some calm?",
              "Can you guide me through a mindful moment?", 
              "I need help processing some difficult emotions",
              "Help me find clarity in this situation I'm facing",
              "I'm struggling with anxiety, what advice do you have?"
            ];
            break;
          case 'career':
          case 'professional':
            topics = [
              "I'm facing a big career decision, what should I consider?",
              "Help me figure out my next professional step",
              "I'm feeling stuck in my job, what would you suggest?",
              "How can I improve my work-life balance?",
              "I need advice on dealing with workplace stress"
            ];
            break;
          case 'friendship':
          case 'life':
            topics = [
              "I need advice about a friendship situation",
              "Help me figure out what would make me happier",
              "I'm dealing with a difficult situation, can you help?",
              "How can I bring more joy into my daily life?",
              "What would make me feel more fulfilled?"
            ];
            break;
          case 'fantasy':
          case 'fictional':
            topics = [
              "I need guidance on a quest I'm facing",
              "Tell me about overcoming impossible challenges",
              "I could use some magical wisdom for my situation",
              "Help me find the courage I need",
              "What wisdom do you have for my journey?"
            ];
            break;
          default:
            topics = [
              "I need someone to talk to about what's on my mind",
              "Help me think through something I'm excited about",
              "I want to process how my day went",
              "I need help staying motivated toward my goals",
              "I'm not feeling great, can you help me feel better?",
              "I want to share something positive that happened"
            ];
        }
        
        updateTopicsUI(topics);
      } catch (error) {
        console.error('Error loading topics:', error);
      }
    }

    function updateTopicsUI(topics) {
      const topicsGrid = document.getElementById('topicsGrid');
      if (!topicsGrid) return;
      
      topicsGrid.innerHTML = topics.map(topic => 
        `<button class="topic-btn" onclick="selectTopic('${topic.replace(/'/g, "\\'")}')">${topic}</button>`
      ).join('');
    }

    function toggleTopics() {
      const topicsPanel = document.getElementById('topicsPanel');
      topicsPanel.classList.toggle('open');
    }

    function selectTopic(topic) {
      const messageInput = document.getElementById('messageInput');
      messageInput.value = topic;
      autoResizeTextarea();
      messageInput.focus();
      
      document.getElementById('topicsPanel').classList.remove('open');
    }

    function selectStarter(message) {
      const messageInput = document.getElementById('messageInput');
      messageInput.value = message;
      autoResizeTextarea();
      messageInput.focus();
    }

    // Usage limit checking
    async function checkUsageLimit() {
      const token = localStorage.getItem("user_token");
      const uid = localStorage.getItem("user_uid");
      const email = localStorage.getItem("user_email");
      const isAnonymousUser = localStorage.getItem('is_anonymous_user') === 'true';
      
      if (!token || !uid || !email) {
        return false;
      }
      
      // For authenticated users with real accounts, always allow messages (they have quota)
      if (!isAnonymousUser && email !== 'anonymous@narrin.ai') {
        console.log('‚úÖ Authenticated user - allowing message (has quota)');
        return true;
      }
      
      // For anonymous users on featured characters, skip server check and use browser-only limits
      const featuredCharacters = ['galina', 'blake-devoted-boyfriend', 'emerald', 'sol'];
      const currentCharSlug = new URLSearchParams(window.location.search).get('char') || new URLSearchParams(window.location.search).get('character');
      const isFeaturedCharacter = featuredCharacters.includes(currentCharSlug);
      
      if (isAnonymousUser && isFeaturedCharacter) {
        console.log('üìä Anonymous user on featured character - using browser-only limit check');
        const usageKey = `anonymous_usage_${currentCharSlug}`;
        const currentUsage = parseInt(localStorage.getItem(usageKey) || '0');
        
        console.log(`üìä Browser-only check: ${currentUsage}/5 for ${currentCharSlug}`);
        
        if (currentUsage >= 5) {
          console.log('üö´ Browser limit reached for anonymous user');
          showUpgradePrompt(5, 5, 'messages');
          return false;
        }
        
        console.log('‚úÖ Anonymous user within browser limit');
        return true;
      }
      
      // For authenticated users, check with server
      try {
        const payload = {
          user_email: email,
          user_uid: uid,
          action: 'check_usage'
        };
        
        const response = await fetch('https://hook.eu2.make.com/36bygx4a2y4bkl97wkdjdmtn3o9ygjms', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        
        if (!response.ok) {
          console.warn('Usage check failed, allowing message');
          return true;
        }
        
        const responseText = await response.text();
        
        // Handle non-JSON responses (like "Accepted")
        if (responseText === 'Accepted' || responseText.includes('Accepted')) {
          return true;
        }
        
        try {
          const data = JSON.parse(responseText);
          return data.canSend || true;
        } catch (parseError) {
          console.warn('Usage check returned non-JSON:', responseText);
          return true; // Allow on non-JSON response
        }
      } catch (error) {
        console.error('Usage limit check error:', error);
        return true; // Allow on error
      }
    }
    
    function showUpgradePrompt(usage, quota, type = 'messages') {
      console.log('üöÄ showUpgradePrompt called:', { usage, quota, type });
      
      // Check if this is a featured character
      const featuredCharacters = ['galina', 'blake-devoted-boyfriend', 'emerald', 'sol'];
      const currentCharSlug = new URLSearchParams(window.location.search).get('char') || new URLSearchParams(window.location.search).get('character');
      const isFeaturedCharacter = featuredCharacters.includes(currentCharSlug);
      let upgradeOverlay = document.getElementById('upgradeOverlay');
      
      if (!upgradeOverlay) {
        upgradeOverlay = document.createElement('div');
        upgradeOverlay.id = 'upgradeOverlay';
        upgradeOverlay.className = 'upgrade-overlay';
        upgradeOverlay.innerHTML = `
          <div class="upgrade-modal">
            <div class="upgrade-header">
              <h3 class="upgrade-title">${
                type === 'tts' ? 'Voice Feature Unavailable' :
                type === 'stt' ? 'Voice Input Unavailable' :
                type === 'companions' ? 'Companion Limit Reached' :
                'Message Limit Reached'
              }</h3>
              <p class="upgrade-subtitle">${
                type === 'tts' 
                  ? `<strong>Text-to-Speech is a premium feature.</strong><br><br>You tried to use voice messages, but this feature is only available on the Immerse plan. Upgrade now to hear your companions speak!`
                  : type === 'stt' 
                  ? `<strong>Speech-to-Text is a premium feature.</strong><br><br>You tried to use voice input, but this feature is only available on the Immerse plan. Upgrade now to talk naturally with your companions!`
                  : type === 'companions'
                  ? `<strong>You've reached your limit of ${quota} active companions.</strong><br><br>To activate more companions, you need to pause existing ones or upgrade to Immerse for unlimited active companions.`
                  : isFeaturedCharacter 
                    ? `<strong>You've used all ${quota} free messages with this character.</strong><br><br>Create an account for a 3-day unlimited trial, or upgrade to Engage for unlimited messaging!`
                    : `<strong>Your trial has ended.</strong><br><br>Upgrade to Engage for unlimited messaging with all your companions!`
              }</p>
            </div>
            
            <div class="upgrade-benefits">
              <div class="benefit-item">
                <span class="benefit-icon">üí¨</span>
                <span class="benefit-text">Unlimited Chat Messages</span>
              </div>
              <div class="benefit-item">
                <span class="benefit-icon">üéôÔ∏è</span>
                <span class="benefit-text">Unlimited Voice Messages (Text-to-Speech)</span>
              </div>
              <div class="benefit-item">
                <span class="benefit-icon">üéß</span>
                <span class="benefit-text">Voice Input (Speech-to-Text)</span>
              </div>
              <div class="benefit-item">
                <span class="benefit-icon">ü§ù</span>
                <span class="benefit-text">Unlimited Active Companions</span>
              </div>
              <div class="benefit-item">
                <span class="benefit-icon">üß†</span>
                <span class="benefit-text">Advanced Character Memory</span>
              </div>
              <div class="benefit-item">
                <span class="benefit-icon">‚ö°</span>
                <span class="benefit-text">Faster Response Times</span>
              </div>
              <div class="benefit-item">
                <span class="benefit-icon">üëë</span>
                <span class="benefit-text">Priority Support</span>
              </div>
            </div>

            <div class="upgrade-buttons">
              <button class="upgrade-btn primary" id="mainUpgradeBtn">
                View Plans
              </button>
              <button class="upgrade-btn secondary" id="mainUpgradeClose">
                Not Now
              </button>
            </div>
          </div>
        `;
        
        document.body.appendChild(upgradeOverlay);
        
        // Add event handlers
        document.getElementById('mainUpgradeBtn').onclick = function() {
          window.location.href = '/pricing';
        };
        
        document.getElementById('mainUpgradeClose').onclick = function() {
          closeUpgradePrompt();
        };
        
        // Close on backdrop click
        upgradeOverlay.onclick = function(e) {
          if (e.target === upgradeOverlay) {
            closeUpgradePrompt();
          }
        };
      }
      
      // Show the modal
      upgradeOverlay.style.display = 'flex';
      setTimeout(() => {
        upgradeOverlay.classList.add('active');
      }, 10);
    }
    
    function closeUpgradePrompt() {
      const upgradeOverlay = document.getElementById('upgradeOverlay');
      if (upgradeOverlay) {
        upgradeOverlay.classList.remove('active');
        setTimeout(() => {
          upgradeOverlay.style.display = 'none';
        }, 300);
      }
    }

    // Message sending
    async function sendMessage(event) {
      event?.preventDefault();
      
      const messageInput = document.getElementById('messageInput');
      const message = messageInput.value.trim();
      
      if (!message || isTyping) return;
      
      // Check usage limit before sending message
      console.log('üîç Checking usage limit before sending message...');
      const isAnonymousUser = localStorage.getItem('is_anonymous_user') === 'true';
      if (isAnonymousUser) {
        const featuredCharacters = ['galina', 'blake-devoted-boyfriend', 'emerald', 'sol'];
        const currentCharSlug = new URLSearchParams(window.location.search).get('char') || new URLSearchParams(window.location.search).get('character');
        const isFeaturedCharacter = featuredCharacters.includes(currentCharSlug);
        
        if (isFeaturedCharacter) {
          const usageKey = `anonymous_usage_${currentCharSlug}`;
          const currentUsage = parseInt(localStorage.getItem(usageKey) || '0');
          
          console.log(`üìä Anonymous usage check for ${currentCharSlug}: ${currentUsage}/5`);
          
          if (currentUsage >= 5) {
            console.log('üö´ Anonymous user trying to send 6th message - showing limit popup');
            showUpgradePrompt(5, 5, 'messages');
            return;
          }
        }
      }
      
      const canSend = await checkUsageLimit();
      console.log(`üìä Usage limit check result: canSend = ${canSend}`);
      if (!canSend) {
        console.log('üö´ Message blocked due to usage limit');
        
        // Show upgrade prompt (checkUsageLimit already handled authenticated users)
        console.log('üîç Showing upgrade prompt for usage limit');
        showUpgradePrompt(5, 5, 'messages');
        return;
      }
      console.log('‚úÖ Usage limit check passed, proceeding with message');
      
      // Add user message
      addMessage(message, 'user');
      messageInput.value = '';
      autoResizeTextarea();
      
      // Save message to localStorage
      saveMessageToHistory(message, 'user');
      
      // Show typing indicator
      const typingIndicator = addTypingIndicator();
      isTyping = true;
      
      try {
        // Send to Make.com webhook
        const response = await sendToMakeWebhook(message);
        
        if (response && response.reply) {
          typingIndicator.remove();
          isTyping = false;
          
          // Add AI response with typewriter effect
          await addMessageWithTypewriter(response.reply, 'ai');
          saveMessageToHistory(response.reply, 'ai');
          
          // Handle TTS if enabled
          if (response.tts_url) {
            handleTTSResponse(response.tts_url);
          }
        } else {
          throw new Error('Invalid response from AI');
        }
      } catch (error) {
        console.error('Error sending message:', error);
        typingIndicator.remove();
        isTyping = false;
        addMessage('I apologize, but I\'m having trouble connecting right now. Please try again.', 'ai');
      }
    }

    async function sendToMakeWebhook(message) {
      const currentCharSlug = currentCharacter?.slug || 'emily';
      const user_email = localStorage.getItem("user_email") || 'anonymous@narrin.ai';
      const user_token = localStorage.getItem("user_token");
      const user_uid = localStorage.getItem("user_uid");
      const isAnonymousUser = localStorage.getItem('is_anonymous_user') === 'true';
      
      // Get recent conversation context
      const recentMessages = conversationHistory.slice(-10);
      
      // Get memory context for non-anonymous users
      let memory_context = '';
      if (!isAnonymousUser && user_uid) {
        try {
          console.log('üß† Retrieving memory context for user:', user_uid);
          const memoryResponse = await fetch('/.netlify/functions/memory', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              action: 'get_memories',
              user_uid: user_uid,
              character_slug: currentCharSlug,
              user_email: user_email
            })
          });
          
          if (memoryResponse.ok) {
            const memoryData = await memoryResponse.json();
            if (memoryData.success && memoryData.memories && memoryData.memories.length > 0) {
              // Format memories for context
              const relevantMemories = memoryData.memories
                .filter(memory => memory.importance >= 3) // Only important memories
                .slice(0, 5) // Limit to top 5
                .map(memory => memory.summary || memory.message)
                .join('\n');
              
              memory_context = relevantMemories;
              console.log('‚úÖ Retrieved', memoryData.memories.length, 'memories for context');
            }
          }
        } catch (error) {
          console.error('‚ùå Error retrieving memory context:', error);
        }
      }
      
      // Update anonymous usage counter
      if (isAnonymousUser) {
        const featuredCharacters = ['galina', 'blake-devoted-boyfriend', 'emerald', 'sol'];
        const isFeaturedCharacter = featuredCharacters.includes(currentCharSlug);
        if (isFeaturedCharacter) {
          const usageKey = `anonymous_usage_${currentCharSlug}`;
          const currentUsage = parseInt(localStorage.getItem(usageKey) || '0');
          localStorage.setItem(usageKey, (currentUsage + 1).toString());
        }
      }
      
      const payload = {
        action: "send_message",
        text: message,
        user_message: message,
        memory_context: memory_context,
        conversation_history: isAnonymousUser ? [] : recentMessages,
        emotional_complexity: 0.5,
        relationship_phase: isAnonymousUser ? 'anonymous' : 'ongoing',
        total_messages: conversationHistory.length,
        slug: currentCharSlug,
        netlify_uid: user_uid || "",
        user_token: user_token || "",
        user_email: user_email,
        custom_prompt: currentCharacter?.customPrompt || null,
        is_customized: currentCharacter?.isCustomized || false,
        has_onboarding: false, // Could be enhanced later
        is_anonymous: isAnonymousUser,
        anonymous_session: isAnonymousUser ? localStorage.getItem('anonymous_character') : null,
        response_length: "IMPORTANT: Keep responses to 1-8 sentences maximum. Be concise and focused. Do not write long paragraphs."
      };
      
      console.log('üì§ Sending to Make webhook:', payload);
      
      // Add timeout handling
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout
      
      let response;
      try {
        response = await fetch('https://hook.eu2.make.com/36bygx4a2y4bkl97wkdjdmtn3o9ygjms', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(payload),
          signal: controller.signal
        });
      } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
          throw new Error('The AI is taking longer than expected. Please try again.');
        }
        throw error;
      }
      clearTimeout(timeoutId);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const rawText = await response.text();
      console.log('üìÑ Make webhook raw response:', rawText);
      
      try {
        const parsed = JSON.parse(rawText);
        
        // Clean AI response - remove asterisk actions and fix formatting
        if (parsed.reply) {
          parsed.reply = cleanAIResponse(parsed.reply);
        }
        
        return parsed;
      } catch (parseError) {
        console.error('JSON parsing error:', parseError);
        console.log('Raw response that failed to parse:', rawText);
        
        try {
          // More aggressive approach: Fix the JSON structure
          let fixedJson = rawText;
          
          // First, escape newlines within quoted strings
          fixedJson = fixedJson.replace(/"reply":\s*"([^"]*(?:\\.[^"]*)*?)"/gs, (match, replyContent) => {
            // Escape newlines and other special characters within the reply
            const escapedContent = replyContent
              .replace(/\n/g, '\\n')
              .replace(/\r/g, '\\r')
              .replace(/\t/g, '\\t')
              .replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');
            return `"reply": "${escapedContent}"`;
          });
          
          // Try parsing the fixed JSON
          const parsed = JSON.parse(fixedJson);
          if (parsed.reply) {
            // Convert escaped newlines back to actual newlines for display
            parsed.reply = parsed.reply
              .replace(/\\n/g, '\n')
              .replace(/\\r/g, '\r')
              .replace(/\\t/g, '\t');
            parsed.reply = cleanAIResponse(parsed.reply);
          }
          return parsed;
          
        } catch (secondParseError) {
          console.error('Second JSON parse also failed:', secondParseError);
          
          // Fallback: Extract JSON manually using more robust approach
          try {
            // Look for the JSON structure boundaries
            const jsonStart = rawText.indexOf('{');
            const jsonEnd = rawText.lastIndexOf('}');
            
            if (jsonStart !== -1 && jsonEnd !== -1 && jsonEnd > jsonStart) {
              let jsonSubstring = rawText.substring(jsonStart, jsonEnd + 1);
              
              // Clean up the substring
              jsonSubstring = jsonSubstring.replace(/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g, '');
              
              const parsed = JSON.parse(jsonSubstring);
              if (parsed.reply) {
                parsed.reply = cleanAIResponse(parsed.reply);
              }
              return parsed;
            }
            
            // Last resort: regex extraction
            const replyMatch = rawText.match(/"reply":\s*"([\s\S]*?)"(?=\s*[,}])/);
            if (replyMatch) {
              const reply = replyMatch[1]
                .replace(/\\n/g, '\n')  // Convert escaped newlines
                .replace(/\\"/g, '"')   // Convert escaped quotes
                .replace(/\\\\/g, '\\'); // Convert escaped backslashes
              const cleanReply = cleanAIResponse(reply);
              console.log('‚úÖ Extracted reply using regex fallback');
              return { reply: cleanReply };
            }
            
          } catch (fallbackError) {
            console.error('All parsing attempts failed:', fallbackError);
          }
        }
        
        throw new Error('Invalid response format from AI service');
      }
    }
    
    // Clean AI responses - remove asterisk actions and format properly
    function cleanAIResponse(text) {
      if (!text) return text;
      
      // Remove asterisk actions like *settles into a mindful pause*
      text = text.replace(/\*[^*]+\*/g, '');
      
      // Remove control characters
      text = text.replace(/[\x00-\x1F\x7F-\x9F]/g, ' ');
      
      // Clean up extra whitespace
      text = text.replace(/\s+/g, ' ').trim();
      
      // Remove multiple consecutive newlines
      text = text.replace(/\n\s*\n\s*\n/g, '\n\n');
      
      return text;
    }

    function addMessage(content, sender, autoScroll = true) {
      const messagesContainer = document.getElementById('chatMessages');
      const welcomeMessage = messagesContainer.querySelector('.welcome-message');
      
      if (welcomeMessage) {
        welcomeMessage.remove();
      }
      
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${sender}`;
      
      const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      if (sender === 'ai') {
        messageDiv.innerHTML = `
          <div class="message-avatar">
            <img src="${currentCharacter?.avatar_url || getRandomAvatar()}" alt="${currentCharacter?.name || 'AI'}" onerror="this.style.display='none'">
          </div>
          <div class="message-wrapper">
            <div class="message-content">${content.replace(/\n/g, '<br>')}</div>
            <div class="message-meta">
              <span>${timestamp}</span>
              <div class="message-actions">
                <button class="message-action" onclick="speakMessage(this)" title="Speak">üîä</button>
              </div>
            </div>
          </div>
        `;
      } else {
        messageDiv.innerHTML = `
          <div class="message-wrapper">
            <div class="message-content">${content.replace(/\n/g, '<br>')}</div>
            <div class="message-meta">
              <span>${timestamp}</span>
            </div>
          </div>
        `;
      }
      
      messagesContainer.appendChild(messageDiv);
      
      if (autoScroll) {
        messagesContainer.scrollTop = messagesContainer.scrollHeight;
      }
    }

    async function addMessageWithTypewriter(content, sender) {
      const messagesContainer = document.getElementById('chatMessages');
      const welcomeMessage = messagesContainer.querySelector('.welcome-message');
      
      if (welcomeMessage) {
        welcomeMessage.remove();
      }
      
      const messageDiv = document.createElement('div');
      messageDiv.className = `message ${sender}`;
      
      const timestamp = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      
      messageDiv.innerHTML = `
        <div class="message-avatar">
          <img src="${currentCharacter?.avatar_url || getRandomAvatar()}" alt="${currentCharacter?.name || 'AI'}" onerror="this.style.display='none'">
        </div>
        <div class="message-wrapper">
          <div class="message-content" id="typing-content"></div>
          <div class="message-meta">
            <span>${timestamp}</span>
            <div class="message-actions">
              <button class="message-action" onclick="speakMessage(this)" title="Speak">üîä</button>
            </div>
          </div>
        </div>
      `;
      
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      
      // Typewriter effect
      const contentDiv = messageDiv.querySelector('#typing-content');
      let i = 0;
      
      return new Promise((resolve) => {
        const typeInterval = setInterval(() => {
          if (i < content.length) {
            contentDiv.textContent += content.charAt(i);
            i++;
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          } else {
            clearInterval(typeInterval);
            resolve();
          }
        }, 30);
      });
    }

    function addTypingIndicator() {
      const messagesContainer = document.getElementById('chatMessages');
      const typingDiv = document.createElement('div');
      typingDiv.className = 'message ai typing-indicator';
      typingDiv.innerHTML = `
        <div class="message-avatar">
          <img src="${currentCharacter?.avatar_url || getRandomAvatar()}" alt="${currentCharacter?.name || 'AI'}" onerror="this.style.display='none'">
        </div>
        <div class="message-content">
          <div class="typing-dots">
            <span></span><span></span><span></span>
          </div>
        </div>
      `;
      
      messagesContainer.appendChild(typingDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;
      return typingDiv;
    }

    // Message actions
    function copyMessage(button) {
      const messageContent = button.closest('.message-wrapper').querySelector('.message-content').textContent;
      navigator.clipboard.writeText(messageContent).then(() => {
        button.textContent = '‚úì';
        setTimeout(() => button.textContent = 'üìã', 2000);
      });
    }

    function speakMessage(button) {
      const messageContent = button.closest('.message-wrapper').querySelector('.message-content').textContent;
      if ('speechSynthesis' in window) {
        window.speechSynthesis.cancel();
        const utterance = new SpeechSynthesisUtterance(messageContent);
        window.speechSynthesis.speak(utterance);
      }
    }

    // Chat history functions
    function saveMessageToHistory(message, sender) {
      const messageObj = {
        content: message,
        sender: sender,
        timestamp: new Date().toISOString()
      };
      
      conversationHistory.push(messageObj);
      
      // Save to localStorage
      const historyKey = `chat_history_${currentCharacter?.slug || 'default'}`;
      localStorage.setItem(historyKey, JSON.stringify(conversationHistory));
      
      // Also save to Airtable via Netlify function
      saveChatMessageToAirtable(messageObj);
    }

    async function saveChatMessageToAirtable(messageObj) {
      try {
        const user_email = localStorage.getItem("user_email") || 'anonymous@narrin.ai';
        const isAnonymousUser = localStorage.getItem('is_anonymous_user') === 'true';
        const user_uid = localStorage.getItem("user_uid");
        const user_token = localStorage.getItem("user_token");
        
        // For anonymous users with featured characters, use special handling
        let finalUserEmail = user_email;
        let finalUserUid = user_uid;
        let finalUserToken = user_token || 'anonymous_token';
        
        if (isAnonymousUser) {
          const featuredCharacters = ['galina', 'blake-devoted-boyfriend', 'emerald', 'sol'];
          const currentCharSlug = currentCharacter?.slug || 'default';
          const isFeaturedCharacter = featuredCharacters.includes(currentCharSlug);
          
          if (isFeaturedCharacter) {
            // Use shared anonymous user for featured characters
            finalUserEmail = 'anonymous@narrin.ai';
            finalUserUid = 'anonymous_user_shared';
            finalUserToken = 'anonymous_token';
          } else {
            // Use individual anonymous session for other characters
            finalUserEmail = user_email;
            finalUserUid = user_uid || `anonymous_${Date.now()}`;
            finalUserToken = 'anonymous_token';
          }
        }
        
        // Only save if we have all required parameters
        if (!finalUserEmail || !finalUserUid || !finalUserToken || !currentCharacter?.slug) {
          console.log('üö´ Skipping save - missing required parameters:', {
            email: !!finalUserEmail,
            uid: !!finalUserUid, 
            token: !!finalUserToken,
            char: !!currentCharacter?.slug
          });
          return;
        }
        
        const response = await fetch('/.netlify/functions/save-chat-message', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            user_email: finalUserEmail,
            user_uid: finalUserUid,
            user_token: finalUserToken,
            char: currentCharacter.slug,
            user_message: messageObj.sender === 'user' ? messageObj.content : '',
            ai_response: messageObj.sender === 'ai' ? messageObj.content : ''
          })
        });
        
        if (!response.ok) {
          const errorText = await response.text();
          console.error('‚ùå Save chat message failed:', response.status, errorText);
        } else {
          console.log('‚úÖ Message saved to Airtable successfully');
        }
      } catch (error) {
        console.error('‚ùå Error saving message to Airtable:', error);
      }
    }

    // Load chat history from localStorage
    function loadChatHistory(characterSlug) {
      const historyKey = `chat_history_${characterSlug || 'default'}`;
      const storedHistory = localStorage.getItem(historyKey);
      
      if (storedHistory) {
        try {
          const history = JSON.parse(storedHistory);
          conversationHistory = history;
          
          // Display the messages
          const messagesContainer = document.getElementById('chatMessages');
          const welcomeMessage = messagesContainer.querySelector('.welcome-message');
          
          if (history.length > 0 && welcomeMessage) {
            welcomeMessage.remove();
          }
          
          history.forEach((messageObj) => {
            addMessage(messageObj.content, messageObj.sender, false); // Don't auto-scroll during loading
          });
          
          // Scroll to bottom after all messages are loaded
          if (history.length > 0) {
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
          }
          
          console.log(`üìú Loaded ${history.length} messages from chat history for ${characterSlug}`);
        } catch (error) {
          console.error('Error loading chat history:', error);
          conversationHistory = [];
        }
      }
    }

    // Speech-to-text
    function toggleSpeechToText() {
      const micButton = document.getElementById('micButton');
      
      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {
        alert('Speech recognition is not supported in your browser');
        return;
      }
      
      if (!isRecording) {
        startSpeechRecognition();
      } else {
        stopSpeechRecognition();
      }
    }

    function startSpeechRecognition() {
      const micButton = document.getElementById('micButton');
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      
      speechRecognition = new SpeechRecognition();
      speechRecognition.continuous = false;
      speechRecognition.interimResults = false;
      speechRecognition.lang = 'en-US';
      
      speechRecognition.onstart = () => {
        isRecording = true;
        micButton.classList.add('recording');
        micButton.title = 'Stop recording';
      };
      
      speechRecognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        const messageInput = document.getElementById('messageInput');
        messageInput.value = transcript;
        autoResizeTextarea();
      };
      
      speechRecognition.onend = () => {
        isRecording = false;
        micButton.classList.remove('recording');
        micButton.title = 'Voice input';
      };
      
      speechRecognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        isRecording = false;
        micButton.classList.remove('recording');
        micButton.title = 'Voice input';
      };
      
      speechRecognition.start();
    }

    function stopSpeechRecognition() {
      if (speechRecognition) {
        speechRecognition.stop();
      }
    }

    // Text-to-speech
    function handleTTSResponse(ttsUrl) {
      if (ttsUrl) {
        const audio = new Audio(ttsUrl);
        audio.play().catch(error => {
          console.error('Error playing TTS audio:', error);
        });
      }
    }

    function checkUserAuthentication() {
      const userToken = localStorage.getItem('user_token');
      const userUid = localStorage.getItem('user_uid');
      const userEmail = localStorage.getItem('user_email');
      const isAnonymousUser = localStorage.getItem('is_anonymous_user') === 'true';
      const isAnonymousEmail = userEmail === 'anonymous@narrin.ai';
      
      console.log('üîç Auth check details:', {
        userToken: !!userToken,
        userUid: !!userUid,
        userEmail: userEmail,
        isAnonymousUser,
        isAnonymousEmail
      });
      
      // Ensure we return a boolean
      return !!(userToken && userUid && !isAnonymousUser && !isAnonymousEmail);
    }
    
    function getRandomAvatar() {
      // Pool of existing avatars from /avatars folder - will be assigned consistently per character
      const avatarPool = [
        '/avatars/emily-1754251534076.webp',
        '/avatars/aaliyah-1754250478518.webp',
        '/avatars/aaron-1754250394855.webp',
        '/avatars/abigail-1754251064609.webp', 
        '/avatars/abel-1754250161582.webp',
        '/avatars/aadhya-1754740209655.webp'
      ];
      
      // Use character slug to ensure consistent avatar selection
      const characterSlug = currentCharacter?.slug || 'default';
      let hash = 0;
      for (let i = 0; i < characterSlug.length; i++) {
        const char = characterSlug.charCodeAt(i);
        hash = ((hash << 5) - hash) + char;
        hash = hash & hash; // Convert to 32-bit integer
      }
      
      const index = Math.abs(hash) % avatarPool.length;
      const selectedAvatar = avatarPool[index];
      
      console.log('üé≤ Generated consistent avatar for', characterSlug, ':', selectedAvatar);
      return selectedAvatar;
    }
    
    function checkMemoryHubAccess() {
      // Check if user has paid plan or active trial
      const userPlan = localStorage.getItem('user_plan') || 'Free';
      const trialExpiry = localStorage.getItem('trial_expiry');
      
      console.log('üîç Memory Hub access check:', { userPlan, trialExpiry });
      
      // Allow access for paid plans
      if (userPlan && userPlan !== 'Free') {
        console.log('‚úÖ Access granted - paid plan:', userPlan);
        return true;
      }
      
      // Check trial status for Free users
      if (trialExpiry) {
        const now = new Date().getTime();
        const expiryTime = new Date(trialExpiry).getTime();
        const hasActiveTrial = now < expiryTime;
        
        console.log('üîç Trial check:', { now, expiryTime, hasActiveTrial });
        
        if (hasActiveTrial) {
          console.log('‚úÖ Access granted - active trial');
          return true;
        }
      }
      
      console.log('‚ùå Access denied - no paid plan or expired trial');
      return false;
    }
    
    function updateButtonTooltips() {
      const isAuthenticated = checkUserAuthentication();
      const memoryBtn = document.getElementById('memoryBtn');
      const customizeBtn = document.getElementById('customizeBtn');
      const mobileProfileLink = document.getElementById('mobileProfileLink');
      
      console.log('üè∑Ô∏è Updating button tooltips:', {
        isAuthenticated,
        memoryBtn: !!memoryBtn,
        customizeBtn: !!customizeBtn,
        mobileProfileLink: !!mobileProfileLink
      });
      
      // Handle Profile link visibility in mobile menu
      if (mobileProfileLink) {
        if (isAuthenticated) {
          mobileProfileLink.style.display = 'flex';
        } else {
          mobileProfileLink.style.display = 'none';
        }
      }
      
      if (memoryBtn) {
        console.log('üè∑Ô∏è Memory button auth branch - isAuthenticated:', isAuthenticated, typeof isAuthenticated);
        if (isAuthenticated) {
          memoryBtn.title = 'Memory Hub';
          memoryBtn.style.opacity = '1';
          memoryBtn.style.cursor = 'pointer';
          console.log('üè∑Ô∏è Set authenticated memory button tooltip');
        } else {
          memoryBtn.title = 'üîê Sign up to access Memory Hub - View and manage your personal memories';
          memoryBtn.setAttribute('title', 'üîê Sign up to access Memory Hub - View and manage your personal memories');
          memoryBtn.style.opacity = '0.7';
          memoryBtn.style.cursor = 'pointer';
          console.log('üè∑Ô∏è Set memory button tooltip for unauthenticated user');
          console.log('üè∑Ô∏è Memory button title is now:', memoryBtn.getAttribute('title'));
        }
      }
      
      if (customizeBtn) {
        if (isAuthenticated) {
          customizeBtn.title = 'Customize';
          customizeBtn.style.opacity = '1';
          customizeBtn.style.cursor = 'pointer';
        } else {
          customizeBtn.title = 'üîê Sign up to customize - Personalize your companion\'s name, avatar & personality';
          customizeBtn.setAttribute('title', 'üîê Sign up to customize - Personalize your companion\'s name, avatar & personality');
          customizeBtn.style.opacity = '0.7';
          customizeBtn.style.cursor = 'pointer';
          console.log('üè∑Ô∏è Set customize button tooltip for unauthenticated user');
          console.log('üè∑Ô∏è Customize button title is now:', customizeBtn.getAttribute('title'));
        }
      }
    }
    
    function setupMobileLoginButton() {
      const mobileLoginBtn = document.getElementById('mobileLoginBtn');
      const mobileProfileLink = document.getElementById('mobileProfileLink');
      
      console.log('üîß Setting up mobile login button...');
      
      if (mobileLoginBtn) {
        // Remove existing event listeners to avoid duplicates
        mobileLoginBtn.removeEventListener('click', handleMobileLogin);
        mobileLoginBtn.addEventListener('click', handleMobileLogin);
        console.log('‚úÖ Mobile login button click handler attached');
      }
      
      // Show/hide login vs profile based on auth status
      const isAuthenticated = checkUserAuthentication();
      console.log('üîê Mobile menu auth status:', isAuthenticated);
      
      if (mobileLoginBtn && mobileProfileLink) {
        if (isAuthenticated) {
          mobileLoginBtn.style.display = 'none';
          mobileProfileLink.style.display = 'flex';
          console.log('üë§ Showing profile link in mobile menu');
        } else {
          mobileLoginBtn.style.display = 'flex';
          mobileProfileLink.style.display = 'none';
          console.log('üîê Showing login button in mobile menu');
        }
      }
    }
    
    function handleMobileLogin(e) {
      e.preventDefault();
      console.log('üì± Mobile login button clicked');
      
      if (window.netlifyIdentity) {
        console.log('‚úÖ Opening Netlify Identity modal');
        closeMobileMenu(); // Close mobile menu first
        window.netlifyIdentity.open();
      } else {
        console.error('‚ùå Netlify Identity not available');
        alert('Login system is not available. Please refresh the page and try again.');
      }
    }

    // Memory Hub
    async function openMemoryHub() {
      console.log('üß† Opening Memory Hub');
      
      // Check if user is authenticated
      const isAuthenticated = checkUserAuthentication();
      if (!isAuthenticated) {
        console.log('üö´ User not authenticated, showing login modal');
        if (window.netlifyIdentity) {
          window.netlifyIdentity.open();
        }
        return;
      }
      
      // Check if user has access (paid plan or active trial)
      const hasAccess = checkMemoryHubAccess();
      if (!hasAccess) {
        console.log('üö´ User does not have access to Memory Hub, redirecting to pricing');
        window.location.href = '/pricing';
        return;
      }
      
      const modal = document.getElementById('memoryHubModal');
      const content = document.getElementById('memoryHubContent');
      
      if (!modal || !content) {
        console.error('Memory Hub modal elements not found');
        return;
      }
      
      modal.style.display = 'flex';
      
      // Hide notification badge when opened
      hideMemoryHubBadge();
      
      // Check if user is authenticated (including anonymous users)
      const userToken = localStorage.getItem('user_token');
      const uid = localStorage.getItem('user_uid');
      const isAnonymousUser = localStorage.getItem('is_anonymous_user') === 'true';
      const userEmail = localStorage.getItem('user_email');
      const isAnonymousEmail = userEmail === 'anonymous@narrin.ai';
      const authenticated = userToken && uid && !isAnonymousUser && !isAnonymousEmail;
      
      console.log('üîç Memory Hub auth check:', { 
        userToken: !!userToken, 
        uid: !!uid, 
        isAnonymousUser, 
        userEmail,
        isAnonymousEmail,
        authenticated 
      });
      
      // Update footer buttons based on auth status
      updateMemoryHubButtons(authenticated);
      
      if (!authenticated) {
        // Show upgrade prompt for unauthenticated users
        content.innerHTML = `
          <div class="no-memories">
            <div class="no-memories-title">üîê Unlock Your Memory Hub</div>
            <div class="no-memories-text">
              <p>Store memories, build deeper connections, and unlock personalized AI experiences.</p>
              <p><strong>Start your free trial</strong> to unlock Memory Hub!</p>
            </div>
            <div style="display: flex; gap: var(--spacing-sm); justify-content: center; flex-wrap: wrap;">
              <button class="start-onboarding-btn" onclick="closeMemoryHub(); window.location.href='/pricing';">
                <span>üíé</span> View Plans
              </button>
              <button class="start-onboarding-btn" onclick="closeMemoryHub(); window.location.href='/profile';" style="background: var(--color-white); color: var(--color-teal); border: 2px solid var(--color-teal);">
                <span>üöÄ</span> Start Free Trial
              </button>
            </div>
          </div>
        `;
        return;
      }
      
      content.innerHTML = '<div class="loading-spinner">Loading your memories...</div>';
      
      try {
        // Get user data
        const slug = currentCharacter?.slug || 'default';
        
        if (!uid || !slug) {
          content.innerHTML = `
            <div class="no-memories">
              <div class="no-memories-title">No Memories Yet</div>
              <div class="no-memories-text">Click the <strong>"Start Personal Quiz"</strong> button below to answer a few quick questions and create your personalized memories</div>
            </div>
          `;
          return;
        }
        
        // First try to get from localStorage
        const storageKey = `onboarding_${uid}_${slug}`;
        const storedOnboarding = localStorage.getItem(storageKey);
        let onboardingData = null;
        
        if (storedOnboarding) {
          try {
            onboardingData = JSON.parse(storedOnboarding);
            console.log('‚úÖ Loaded onboarding from localStorage:', onboardingData);
          } catch (e) {
            console.error('Error parsing stored onboarding:', e);
          }
        }
        
        // If not in localStorage or we want fresher data, try to get from Airtable
        if (!onboardingData || !onboardingData.answers) {
          console.log('üìä Fetching from Airtable using memory function...');
          const response = await fetch('/.netlify/functions/memory', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              action: 'get_memories',
              user_uid: uid,
              user_email: userEmail,
              character_slug: slug || 'general'
            })
          });
          
          if (response.ok) {
            const data = await response.json();
            console.log('üìä Airtable response:', data);
            
            if (data.success && data.memories && data.memories.length > 0) {
              onboardingData = {
                answers: data.memories.map(memory => ({
                  question: memory.question || 'Personal Detail',
                  answer: memory.answer || memory.content || memory.description
                }))
              };
            }
          }
        }
        
        // Try to get imported memories
        let importedMemories = [];
        try {
          const userUid = localStorage.getItem('user_uid');
          if (userUid) {
            console.log('üîç Fetching imported memories for memory hub:', { userEmail, userUid });
            const importResponse = await fetch('/.netlify/functions/get-imported-memories', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                user_email: userEmail,
                user_uid: userUid
              })
            });
            
            if (importResponse.ok) {
              const importData = await importResponse.json();
              console.log('üì• Import response:', importData);
              if (importData.success && importData.imported_memories) {
                importedMemories = importData.imported_memories;
                console.log(`‚úÖ Loaded ${importedMemories.length} imported memories for memory hub`);
              }
            } else {
              console.warn('‚ö†Ô∏è Import response not ok:', importResponse.status);
            }
          }
        } catch (error) {
          console.error('‚ùå Error fetching imported memories:', error);
        }
        
        // Display memories
        displayMemoryHub(onboardingData, importedMemories);
        
      } catch (error) {
        console.error('Error loading Memory Hub:', error);
        content.innerHTML = `
          <div class="no-memories">
            <div class="no-memories-title">Error Loading Memories</div>
            <div class="no-memories-text">Please try again later.</div>
          </div>
        `;
      }
    }

    function displayMemoryHub(onboardingData, importedMemories = []) {
      const content = document.getElementById('memoryHubContent');
      
      const hasOnboarding = onboardingData && onboardingData.answers && onboardingData.answers.length > 0;
      const hasImported = importedMemories && importedMemories.length > 0;
      
      if (!hasOnboarding && !hasImported) {
        content.innerHTML = `
          <div class="no-memories">
            <div class="no-memories-title">No Memories Yet</div>
            <div class="no-memories-text">Click the <strong>"Take Personal Quiz"</strong> button below to answer a few quick questions and create your personalized memories</div>
          </div>
        `;
        return;
      }
      
      let memoryHTML = '';
      
      // Add imported memories first
      if (hasImported) {
        memoryHTML += '<div style="margin-bottom: 20px;"><h3 style="color: var(--color-navy); margin-bottom: 15px; font-size: 16px;">üì• Imported Memories</h3>';
        importedMemories.forEach((memory, index) => {
          const displayText = memory.Memory || memory.memory_text || memory.content || memory.description || 'No content';
          const importance = memory.importance_score || memory.importance || 'N/A';
          const date = memory.Date || memory.created_at ? new Date(memory.Date || memory.created_at).toLocaleDateString() : 'Unknown date';
          const memoryId = `imported_${index}`;
          
          memoryHTML += `
            <div class="memory-item">
              <div class="memory-answer">${displayText}</div>
              <small style="color: var(--color-gray); margin-top: 8px; display: block;">
                Importance: ${importance} | ${date}
              </small>
              <button onclick="discussMemory('${memoryId}', '${displayText.replace(/'/g, "\\'")}', 'imported')" 
                      style="margin-top: 10px; padding: 6px 12px; background: var(--color-teal); color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;">
                üí¨ Discuss This
              </button>
            </div>
          `;
        });
        memoryHTML += '</div>';
      }
      
      // Add onboarding memories
      if (hasOnboarding) {
        memoryHTML += '<div><h3 style="color: var(--color-navy); margin-bottom: 15px; font-size: 16px;">üéØ Personal Details</h3>';
        onboardingData.answers.forEach((item, index) => {
          if (item.question && item.answer) {
            const memoryId = `onboarding_${index}`;
            memoryHTML += `
              <div class="memory-item">
                <div class="memory-question">${item.question}</div>
                <div class="memory-answer">${item.answer}</div>
                <button onclick="discussMemory('${memoryId}', 'Tell me more about: ${item.question}', 'onboarding')" 
                        style="margin-top: 10px; padding: 6px 12px; background: var(--color-teal); color: white; border: none; border-radius: 6px; font-size: 12px; cursor: pointer; transition: all 0.2s ease;">
                  üí¨ Discuss This
                </button>
              </div>
            `;
          }
        });
        memoryHTML += '</div>';
      }
      
      content.innerHTML = memoryHTML;
    }

    function discussMemory(memoryId, memoryText, memoryType) {
      console.log('üí¨ Discussing memory:', { memoryId, memoryType, text: memoryText.substring(0, 50) });
      
      // Close the memory hub modal
      closeMemoryHub();
      
      // Wait a moment for the modal to close, then start the conversation
      setTimeout(() => {
        const messageInput = document.getElementById('messageInput');
        if (messageInput) {
          // Pre-fill the message input with a discussion starter
          let discussionStarter;
          if (memoryType === 'imported') {
            discussionStarter = `I'd like to talk about this memory: "${memoryText}"`;
          } else if (memoryType === 'onboarding') {
            discussionStarter = memoryText; // Already formatted as "Tell me more about: [question]"
          }
          
          messageInput.value = discussionStarter;
          messageInput.focus();
          
          // Auto-resize the textarea
          autoResizeTextarea();
          
          // Optionally auto-send the message
          // Uncomment the next line if you want to automatically send the message
          // sendMessage();
        }
      }, 300);
    }

    function updateMemoryHubButtons(isAuthenticated) {
      const importButton = document.querySelector('.memory-hub-footer a[href="/memory-import"]');
      const quizButton = document.querySelector('.memory-hub-footer button[onclick="restartOnboarding()"]');
      const timestampElement = document.getElementById('import-timestamp');
      
      // Check for ChatGPT import history
      const importTimestamp = localStorage.getItem('chatgpt_import_timestamp');
      const importCount = localStorage.getItem('chatgpt_import_count');
      
      if (importTimestamp && importCount && timestampElement) {
        const importDate = new Date(importTimestamp);
        const timeAgo = getTimeAgo(importDate);
        timestampElement.textContent = `Last imported ${importCount} memories ${timeAgo}`;
        timestampElement.style.display = 'block';
      }
      
      if (importButton) {
        if (!isAuthenticated) {
          importButton.style.opacity = '0.5';
          importButton.style.cursor = 'not-allowed';
          importButton.title = 'Sign up required to import memories';
          importButton.onclick = (e) => {
            e.preventDefault();
            if (window.netlifyIdentity) {
              window.netlifyIdentity.open('signup');
            }
          };
        } else {
          importButton.style.opacity = '1';
          importButton.style.cursor = 'pointer';
          importButton.title = '';
          importButton.onclick = null;
        }
      }
      
      if (quizButton) {
        if (!isAuthenticated) {
          quizButton.style.opacity = '0.5';
          quizButton.style.cursor = 'not-allowed';
          quizButton.title = 'Sign up required to take quiz';
          quizButton.onclick = (e) => {
            e.preventDefault();
            if (window.netlifyIdentity) {
              window.netlifyIdentity.open('signup');
            }
          };
        }
      }
    }

    function getTimeAgo(date) {
      const now = new Date();
      const diffInSeconds = Math.floor((now - date) / 1000);
      
      if (diffInSeconds < 60) return 'just now';
      if (diffInSeconds < 3600) return `${Math.floor(diffInSeconds / 60)} minutes ago`;
      if (diffInSeconds < 86400) return `${Math.floor(diffInSeconds / 3600)} hours ago`;
      if (diffInSeconds < 2592000) return `${Math.floor(diffInSeconds / 86400)} days ago`;
      if (diffInSeconds < 31536000) return `${Math.floor(diffInSeconds / 2592000)} months ago`;
      return `${Math.floor(diffInSeconds / 31536000)} years ago`;
    }

    function closeMemoryHub() {
      const modal = document.getElementById('memoryHubModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    function restartOnboarding() {
      console.log('üîÑ Restarting onboarding');
      
      // Get current user and character info
      const uid = localStorage.getItem('user_uid');
      const slug = currentCharacter?.slug || 'default';
      
      if (!uid || !slug) {
        console.error('‚ùå Missing user ID or character slug for onboarding restart');
        return;
      }
      
      // Close Memory Hub first
      closeMemoryHub();
      
      // Clear existing onboarding data
      const completionKey = `onboarding_${uid}_${slug}`;
      localStorage.removeItem(completionKey);
      
      console.log('‚úÖ Cleared onboarding data for restart');
      
      // For now, show an alert - this would be replaced with actual onboarding flow
      alert('Personal Quiz feature coming soon! This will allow you to build personalized memories.');
    }

    // Memory notification badge system
    function showMemoryHubBadge() {
      const memoryBtn = document.getElementById('memoryBtn');
      if (memoryBtn) {
        memoryBtn.classList.add('has-notification');
        console.log('üî¥ Memory Hub notification badge shown');
      }
    }
    
    function hideMemoryHubBadge() {
      const memoryBtn = document.getElementById('memoryBtn');
      if (memoryBtn) {
        memoryBtn.classList.remove('has-notification');
        // Mark as viewed in localStorage
        localStorage.setItem('memory_hub_viewed', 'true');
        console.log('‚úÖ Memory Hub notification badge hidden');
      }
    }
    
    function checkMemoryHubNotification() {
      const hasViewed = localStorage.getItem('memory_hub_viewed');
      const hasImported = localStorage.getItem('chatgpt_import_timestamp');
      const characterSlug = currentCharacter?.slug || 'default';
      const isNewCompanion = !localStorage.getItem(`visited_${characterSlug}`);
      
      // Show badge if:
      // 1. User hasn't viewed Memory Hub before AND (new companion OR has imported memories)
      // 2. User has imported memories but hasn't viewed Memory Hub since
      if (!hasViewed && (isNewCompanion || hasImported)) {
        showMemoryHubBadge();
      }
      
      // Mark this companion as visited
      if (isNewCompanion && characterSlug) {
        localStorage.setItem(`visited_${characterSlug}`, 'true');
      }
    }

    // Lazy loading functions for welcome message links
    function lazyLoadCustomize(event) {
      if (event) event.preventDefault();
      openCustomize();
      return false;
    }
    
    function lazyLoadMemoryHub() {
      openMemoryHub();
      return false;
    }

    // Customize
    async function openCustomize() {
      // Check if user is authenticated
      const isAuthenticated = checkUserAuthentication();
      if (!isAuthenticated) {
        console.log('üö´ User not authenticated, showing login modal');
        if (window.netlifyIdentity) {
          window.netlifyIdentity.open();
        }
        return;
      }
      
      // Check if user has access (paid plan or active trial)
      const hasAccess = checkMemoryHubAccess();
      if (!hasAccess) {
        console.log('üö´ User does not have access to Customize, redirecting to pricing');
        window.location.href = '/pricing';
        return;
      }
      
      // Call the full customization modal function
      openCustomizationModal();
    }

    function openCustomizationModal() {
      if (!currentCharacter) {
        console.warn('‚ö†Ô∏è Cannot open customization modal - no current character');
        return;
      }
      
      console.log('üé® Opening customization modal for:', currentCharacter.name);
      
      const modal = document.getElementById('customizationModal');
      const form = document.getElementById('customizationForm');
      
      // Pre-fill form with current character data
      const characterSlug = currentCharacter.slug || 'default';
      const customizedCharacters = JSON.parse(localStorage.getItem('customizedCharacters') || '{}');
      const existingCustom = customizedCharacters[characterSlug];
      
      // Reset form
      if (form) {
        form.reset();
      }
      
      // Load existing customization if available
      if (existingCustom) {
        document.getElementById('customName').value = existingCustom.name || currentCharacter.name || '';
        document.getElementById('customPrompt').value = existingCustom.extra_instructions || '';
        document.getElementById('voiceType').value = existingCustom.voice_type || 'none';
        
        // Handle avatar
        const avatarImg = document.getElementById('customAvatarImg');
        const placeholder = document.getElementById('avatarPlaceholder');
        
        console.log('üñºÔ∏è Avatar debug (existing custom):', {
          existingCustomAvatarUrl: existingCustom.avatar_url,
          currentCharacterAvatarUrl: currentCharacter.avatar_url,
          avatarImg: !!avatarImg,
          placeholder: !!placeholder
        });
        
        const avatarToUse = existingCustom.avatar_url || currentCharacter.avatar_url;
        
        if (avatarToUse && avatarImg && placeholder) {
          console.log('‚úÖ Setting avatar in customize modal (existing):', avatarToUse);
          avatarImg.src = avatarToUse;
          avatarImg.style.display = 'block';
          placeholder.style.display = 'none';
          document.getElementById('customAvatarUrl').value = avatarToUse;
        } else {
          console.log('‚ùå Avatar not set (existing) - missing data or elements');
          if (placeholder) {
            placeholder.style.display = 'block';
            placeholder.innerHTML = 'üë§';
          }
          if (avatarImg) {
            avatarImg.style.display = 'none';
          }
        }
      } else {
        // Load current character data
        document.getElementById('customName').value = currentCharacter.name || '';
        document.getElementById('voiceType').value = currentCharacter.voice_type || 'none';
        
        // Handle current character avatar
        const avatarImg = document.getElementById('customAvatarImg');
        const placeholder = document.getElementById('avatarPlaceholder');
        console.log('üñºÔ∏è Avatar debug:', {
          currentCharacterAvatarUrl: currentCharacter.avatar_url,
          avatarImg: !!avatarImg,
          placeholder: !!placeholder
        });
        
        // Use fallback avatar if currentCharacter has no avatar_url  
        const avatarToUse = currentCharacter.avatar_url || getRandomAvatar();
        
        if (avatarToUse && avatarImg && placeholder) {
          console.log('‚úÖ Setting avatar in customize modal (with fallback):', avatarToUse);
          avatarImg.src = avatarToUse;
          avatarImg.style.display = 'block';
          placeholder.style.display = 'none';
          document.getElementById('customAvatarUrl').value = avatarToUse;
          
          // Update currentCharacter with fallback avatar if it had none
          if (!currentCharacter.avatar_url) {
            currentCharacter.avatar_url = avatarToUse;
            updateCharacterUI(currentCharacter); // Update header immediately
            console.log('üîß Applied fallback avatar to character without avatar_url');
          }
        } else {
          console.log('‚ùå Avatar not set - missing elements');
          if (placeholder) {
            placeholder.style.display = 'block';
            placeholder.innerHTML = 'üë§';
          }
          if (avatarImg) {
            avatarImg.style.display = 'none';
          }
        }
      }
      
      // Setup character counters
      setupCharacterCounters();
      
      // Setup avatar file input
      setupAvatarUpload();
      
      // Setup form submission
      if (form && !form.hasEventListener) {
        form.addEventListener('submit', handleCustomizationSubmit);
        form.hasEventListener = true;
      }
      
      modal.style.display = 'flex';
      
      // Setup autosave
      setupAutoSave();
    }
    
    function setupAutoSave() {
      let saveTimeout;
      
      const autoSave = () => {
        clearTimeout(saveTimeout);
        saveTimeout = setTimeout(async () => {
          await saveCustomizationChanges();
        }, 2000); // Save after 2 seconds of inactivity
      };
      
      // Auto-save on input changes
      const inputs = ['customName', 'customPrompt', 'voiceType'];
      inputs.forEach(inputId => {
        const input = document.getElementById(inputId);
        if (input) {
          input.addEventListener('input', autoSave);
          input.addEventListener('change', autoSave);
        }
      });
      
      // Auto-save on slider changes
      const sliders = document.querySelectorAll('.personality-slider');
      sliders.forEach(slider => {
        slider.addEventListener('input', autoSave);
      });
      
      // Auto-save on button clicks
      const buttons = document.querySelectorAll('.personality-button');
      buttons.forEach(button => {
        button.addEventListener('click', autoSave);
      });
    }
    
    async function saveCustomizationChanges() {
      if (!currentCharacter) return;
      
      const customName = document.getElementById('customName')?.value?.trim() || currentCharacter.name;
      const customPrompt = document.getElementById('customPrompt')?.value?.trim() || '';
      const voiceType = document.getElementById('voiceType')?.value || 'none';
      const avatarUrl = document.getElementById('customAvatarUrl')?.value || currentCharacter.avatar_url;
      
      const characterSlug = currentCharacter.slug || 'default';
      const customizedCharacters = JSON.parse(localStorage.getItem('customizedCharacters') || '{}');
      
      const customization = {
        name: customName,
        extra_instructions: customPrompt,
        voice_type: voiceType,
        avatar_url: avatarUrl,
        character_slug: characterSlug,
        personality_state: {
          sliders: { ...personalityState.sliders },
          traits: [...personalityState.traits],
          speaking: [...personalityState.speaking],
          quirks: [...personalityState.quirks],
          bonding: [...personalityState.bonding]
        },
        lastUpdated: new Date().toISOString()
      };
      
      // Save with server sync for cross-device access
      await saveCustomizationWithSync(characterSlug, customization);
      
      // Apply changes to current character
      currentCharacter.name = customName;
      currentCharacter.customPrompt = customPrompt;
      currentCharacter.voice_type = voiceType;
      if (avatarUrl) {
        currentCharacter.avatar_url = avatarUrl;
      }
      currentCharacter.isCustomized = true;
      
      // Update UI
      updateCharacterUI(currentCharacter);
      
      // Show autosave indicator
      showAutoSaveIndicator();
      
      console.log('üíæ Auto-saved customization:', customization);
    }
    
    function showAutoSaveIndicator() {
      const indicator = document.querySelector('.auto-save-indicator');
      if (indicator) {
        indicator.innerHTML = '‚úÖ Saved';
        indicator.style.display = 'flex';
        
        setTimeout(() => {
          indicator.style.display = 'none';
        }, 2000);
      }
    }

    function closeCustomizationModal() {
      document.getElementById('customizationModal').style.display = 'none';
    }

    function setupCharacterCounters() {
      const nameInput = document.getElementById('customName');
      const nameCounter = document.getElementById('nameCounter');
      const promptInput = document.getElementById('customPrompt');
      const promptCounter = document.getElementById('promptCounter');
      
      if (nameInput && nameCounter) {
        nameCounter.textContent = nameInput.value.length;
        nameInput.addEventListener('input', () => {
          nameCounter.textContent = nameInput.value.length;
        });
      }
      
      if (promptInput && promptCounter) {
        promptCounter.textContent = promptInput.value.length;
        promptInput.addEventListener('input', () => {
          promptCounter.textContent = promptInput.value.length;
        });
      }
    }

    function setupAvatarUpload() {
      const fileInput = document.getElementById('customAvatarFile');
      const avatarImg = document.getElementById('customAvatarImg');
      const placeholder = document.getElementById('avatarPlaceholder');
      
      if (fileInput) {
        fileInput.addEventListener('change', async (e) => {
          const file = e.target.files[0];
          if (file) {
            try {
              // Show loading state
              placeholder.innerHTML = '‚è≥';
              
              // Upload to Cloudinary
              const uploadUrl = await uploadToCloudinary(file);
              
              if (uploadUrl) {
                avatarImg.src = uploadUrl;
                avatarImg.style.display = 'block';
                placeholder.style.display = 'none';
                document.getElementById('customAvatarUrl').value = uploadUrl;
              }
            } catch (error) {
              console.error('Error uploading avatar:', error);
              placeholder.innerHTML = 'üë§';
              alert('Error uploading image. Please try again.');
            }
          }
        });
      }
    }

    async function uploadToCloudinary(file) {
      const formData = new FormData();
      formData.append('file', file);
      formData.append('upload_preset', 'ml_default');
      
      const response = await fetch('https://api.cloudinary.com/v1_1/narrin/image/upload', {
        method: 'POST',
        body: formData
      });
      
      if (!response.ok) {
        throw new Error('Upload failed');
      }
      
      const data = await response.json();
      return data.secure_url;
    }

    async function generateCompanionImage() {
      console.log('üé≤ generateCompanionImage called');
      const avatarImg = document.getElementById('customAvatarImg');
      const placeholder = document.getElementById('avatarPlaceholder');
      
      console.log('üñºÔ∏è Generate avatar elements:', {
        avatarImg: !!avatarImg,
        placeholder: !!placeholder
      });
      
      if (!avatarImg || !placeholder) {
        console.error('‚ùå Avatar elements not found');
        return;
      }
      
      // Show loading state
      placeholder.innerHTML = '‚è≥';
      placeholder.style.display = 'block';
      avatarImg.style.display = 'none';
      
      try {
        // Get a random avatar (truly random for regeneration, not hash-based)
        const avatarPool = [
          '/avatars/emily-1754251534076.webp',
          '/avatars/aaliyah-1754250478518.webp',
          '/avatars/aaron-1754250394855.webp',
          '/avatars/abigail-1754251064609.webp',
          '/avatars/abel-1754250161582.webp',
          '/avatars/aadhya-1754740209655.webp'
        ];
        
        const randomAvatar = avatarPool[Math.floor(Math.random() * avatarPool.length)];
        
        // Simulate API delay
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        avatarImg.src = randomAvatar;
        avatarImg.style.display = 'block';
        placeholder.style.display = 'none';
        document.getElementById('customAvatarUrl').value = randomAvatar;
        
        // Update current character and save immediately
        currentCharacter.avatar_url = randomAvatar;
        
        // Trigger autosave to persist the change
        await saveCustomizationChanges();
        
        // Update header avatar immediately
        updateCharacterUI(currentCharacter);
        
        console.log('‚úÖ Avatar regenerated and saved:', randomAvatar);
        
      } catch (error) {
        console.error('Error generating avatar:', error);
        placeholder.innerHTML = 'üë§';
        alert('Error generating avatar. Please try again.');
      }
    }

    async function handleCustomizationSubmit(e) {
      e.preventDefault();
      
      const formData = new FormData(e.target);
      const customName = document.getElementById('customName').value.trim();
      const customPrompt = document.getElementById('customPrompt').value.trim();
      const voiceType = document.getElementById('voiceType').value;
      const avatarUrl = document.getElementById('customAvatarUrl').value;
      
      if (!customName) {
        alert('Please enter a name for your companion.');
        return;
      }
      
      // Save customization
      const characterSlug = currentCharacter.slug || 'default';
      const customizedCharacters = JSON.parse(localStorage.getItem('customizedCharacters') || '{}');
      
      const customization = {
        name: customName,
        extra_instructions: customPrompt,
        voice_type: voiceType,
        avatar_url: avatarUrl || currentCharacter.avatar_url,
        character_slug: characterSlug,
        personality_state: {
          sliders: { ...personalityState.sliders },
          traits: [...personalityState.traits],
          speaking: [...personalityState.speaking],
          quirks: [...personalityState.quirks],
          bonding: [...personalityState.bonding]
        },
        lastUpdated: new Date().toISOString()
      };
      
      // Save with server sync for cross-device access
      await saveCustomizationWithSync(characterSlug, customization);
      
      // Apply changes immediately
      currentCharacter.name = customName;
      currentCharacter.extra_instructions = customPrompt;
      currentCharacter.voice_type = voiceType;
      if (avatarUrl) {
        currentCharacter.avatar_url = avatarUrl;
      }
      
      // Update UI
      updateCharacterUI(currentCharacter);
      
      console.log('‚úÖ Companion customization saved:', customization);
      
      // Close modal
      closeCustomizationModal();
      
      // Show success message
      alert('Companion customized successfully!');
    }

    function closeCustomize() {
      closeCustomizationModal();
    }

    function clearChatHistory() {
      if (confirm('Are you sure you want to clear your chat history? This cannot be undone.')) {
        conversationHistory = [];
        const historyKey = `chat_history_${currentCharacter?.slug || 'default'}`;
        localStorage.removeItem(historyKey);
        
        const messagesContainer = document.getElementById('chatMessages');
        messagesContainer.innerHTML = `
          <div class="welcome-message">
            <div class="welcome-icon">üí≠</div>
            <h3>Chat Cleared</h3>
            <p>Start a new conversation with ${currentCharacter?.name || 'your AI companion'}!</p>
          </div>
        `;
        
        closeCustomize();
      }
    }

    // Authentication placeholder
    function initializeAuth() {
      // This would integrate with Netlify Identity
      // For now, using localStorage for demo
      const user_email = localStorage.getItem("user_email");
      if (user_email && user_email !== 'anonymous@narrin.ai') {
        isAuthenticated = true;
        currentUser = { email: user_email };
      }
      
      // Listen for Netlify Identity events to update tooltips and mobile menu
      if (window.netlifyIdentity) {
        netlifyIdentity.on('init', () => {
          updateButtonTooltips();
          setupMobileLoginButton();
        });
        
        netlifyIdentity.on('login', () => {
          console.log('‚úÖ Login successful - closing modal');
          netlifyIdentity.close(); // Close the modal immediately
          setTimeout(() => {
            updateButtonTooltips();
            setupMobileLoginButton();
          }, 500);
        });
        
        netlifyIdentity.on('logout', () => {
          setTimeout(() => {
            updateButtonTooltips();
            setupMobileLoginButton();
          }, 500);
        });
      }
    }

    // Utility functions
    // Mobile Menu Functions
    const mobileMenuOverlay = document.getElementById('mobileMenuOverlay');

    function toggleMobileMenu() {
      if (!mobileMenuOverlay) return;
      
      const isActive = mobileMenuOverlay.classList.contains('active');
      
      if (isActive) {
        closeMobileMenu();
      } else {
        openMobileMenu();
      }
    }

    function openMobileMenu() {
      if (mobileMenuOverlay) {
        mobileMenuOverlay.classList.add('active');
      }
      document.body.style.overflow = 'hidden';
    }

    function closeMobileMenu() {
      if (mobileMenuOverlay) {
        mobileMenuOverlay.classList.remove('active');
      }
      document.body.style.overflow = '';
    }

    // Close menu when clicking outside
    if (mobileMenuOverlay) {
      mobileMenuOverlay.addEventListener('click', (e) => {
        if (e.target === mobileMenuOverlay) {
          closeMobileMenu();
        }
      });
    }

    // Close menu when clicking links
    document.querySelectorAll('.mobile-menu-link').forEach(link => {
      link.addEventListener('click', closeMobileMenu);
    });

    // Close menu with Escape key
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && mobileMenuOverlay?.classList.contains('active')) {
        closeMobileMenu();
      }
    });

    // Personality customization system
    let personalityState = {
      speaking: [],
      traits: [],
      bonding: [],
      quirks: [],
      sliders: {
        // Response style sliders
        length: 50,
        style: 50,
        content: 50,
        // Personality spectrum sliders
        social: 50,
        thinking: 50,
        mood: 50,
        formality: 50,
        tempo: 50
      }
    };

    function toggleArraySelection(array, value, maxCount, button, counterId, type) {
      const index = array.indexOf(value);
      
      if (index > -1) {
        // Remove from array
        array.splice(index, 1);
        button.classList.remove('selected');
      } else if (array.length < maxCount) {
        // Add to array
        array.push(value);
        button.classList.add('selected');
      }
      
      // Update counter if provided
      if (counterId) {
        updateSelectionCounter(counterId, array.length, maxCount, type);
      }
    }

    function updateSelectionCounter(counterId, currentCount, maxCount, type) {
      const counter = document.getElementById(counterId);
      if (counter) {
        counter.textContent = `Select 0-${maxCount} ${type} (${currentCount} selected)`;
        if (currentCount >= maxCount) {
          counter.classList.add('at-limit');
        } else {
          counter.classList.remove('at-limit');
        }
      }
    }

    function updateCharacterCounter(inputId, counterId) {
      const input = document.getElementById(inputId);
      const counter = document.getElementById(counterId);
      if (input && counter) {
        counter.textContent = input.value.length;
      }
    }

    // Voice preview functionality
    function previewCustomVoice() {
      const voiceSelect = document.getElementById('voiceType');
      const previewBtn = document.getElementById('previewVoiceBtn');
      
      if (!voiceSelect || !previewBtn) return;
      
      const selectedVoice = voiceSelect.value;
      
      if (selectedVoice === 'none') {
        alert('Please select a voice type to preview.');
        return;
      }
      
      // Disable button during preview
      previewBtn.disabled = true;
      previewBtn.textContent = 'Playing Preview...';
      
      // Show notification about voice preview
      const voiceText = voiceSelect.options[voiceSelect.selectedIndex].text;
      console.log(`üîä Previewing voice: ${voiceText}`);
      
      // Simulate voice preview (in a real implementation, this would play TTS)
      setTimeout(() => {
        previewBtn.disabled = false;
        previewBtn.innerHTML = 'üîä Preview Voice';
        console.log(`‚úÖ Voice preview completed for: ${voiceText}`);
      }, 2000);
      
      // In production, this would integrate with your TTS service
      // For example: await synthesizeVoice("Hello! This is how I'll sound during our conversations.", selectedVoice);
    }

    // Initialize personality customization system
    function initializePersonalitySystem() {
      // Speaking pattern buttons
      const speakingButtons = document.querySelectorAll('#speakingPattern .personality-button');
      speakingButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          e.preventDefault();
          const pattern = button.getAttribute('data-pattern');
          toggleArraySelection(personalityState.speaking, pattern, 3, button, 'speakingCounter', 'speaking patterns');
        });
      });
      
      // Personality trait buttons
      const traitButtons = document.querySelectorAll('#personalityTraits .personality-button');
      traitButtons.forEach(button => {
        button.addEventListener('click', (e) => {
          e.preventDefault();
          const trait = button.getAttribute('data-trait');
          toggleArraySelection(personalityState.traits, trait, 5, button, 'traitsCounter', 'traits');
        });
      });
      
      // All sliders
      const sliders = document.querySelectorAll('.personality-slider');
      sliders.forEach(slider => {
        slider.addEventListener('input', (e) => {
          const trait = e.target.getAttribute('data-trait') || e.target.getAttribute('data-response');
          personalityState.sliders[trait] = parseInt(e.target.value);
        });
      });
      
      // Character counters
      const customNameEl = document.getElementById('customName');
      if (customNameEl) {
        customNameEl.addEventListener('input', () => {
          updateCharacterCounter('customName', 'nameCounter');
        });
      }

      // Setup form submission
      const form = document.getElementById('customizationForm');
      if (form) {
        form.addEventListener('submit', handleCustomizationSubmit);
      }
    }

    // Update the existing openCustomizationModal function to load personality data
    const originalOpenModal = openCustomizationModal;
    openCustomizationModal = function() {
      originalOpenModal.call(this);
      
      // Load existing personality data if available
      const characterSlug = currentCharacter?.slug || 'default';
      const customizedCharacters = JSON.parse(localStorage.getItem('customizedCharacters') || '{}');
      const existingCustom = customizedCharacters[characterSlug];
      
      if (existingCustom && existingCustom.personality_state) {
        // Restore personality state from saved data
        personalityState = {
          sliders: { ...personalityState.sliders, ...existingCustom.personality_state.sliders },
          traits: [...(existingCustom.personality_state.traits || [])],
          speaking: [...(existingCustom.personality_state.speaking || [])],
          quirks: [...(existingCustom.personality_state.quirks || [])],
          bonding: [...(existingCustom.personality_state.bonding || [])]
        };
      } else {
        // Reset to default state
        personalityState = {
          speaking: [],
          traits: [],
          bonding: [],
          quirks: [],
          sliders: {
            length: 50,
            style: 50,
            content: 50,
            social: 50,
            thinking: 50,
            mood: 50,
            formality: 50,
            tempo: 50
          }
        };
      }
      
      // Initialize UI after modal opens
      setTimeout(() => {
        updateCharacterCounter('customName', 'nameCounter');
        updatePersonalityUI();
      }, 100);
    };

    function updatePersonalityUI() {
      // Update sliders
      Object.keys(personalityState.sliders).forEach(trait => {
        const slider = document.getElementById(trait === 'social' ? 'introvertExtravert' :
                                            trait === 'thinking' ? 'logicalEmotional' :
                                            trait === 'mood' ? 'seriousPlayful' :
                                            trait === 'formality' ? 'formalCasual' :
                                            trait === 'tempo' ? 'patientImpulsive' : '');
        if (slider && personalityState.sliders[trait] !== undefined) {
          slider.value = personalityState.sliders[trait];
        }
      });

      // Update trait buttons
      const traitButtons = document.querySelectorAll('#personalityTraits .personality-button');
      traitButtons.forEach(button => {
        const trait = button.getAttribute('data-trait');
        if (personalityState.traits.includes(trait)) {
          button.classList.add('selected');
        } else {
          button.classList.remove('selected');
        }
      });

      // Update speaking pattern buttons
      const speakingButtons = document.querySelectorAll('#speakingPattern .personality-button');
      speakingButtons.forEach(button => {
        const pattern = button.getAttribute('data-pattern');
        if (personalityState.speaking.includes(pattern)) {
          button.classList.add('selected');
        } else {
          button.classList.remove('selected');
        }
      });

      // Update counters
      updateSelectionCounter('traitsCounter', personalityState.traits.length, 5, 'traits');
      updateSelectionCounter('speakingCounter', personalityState.speaking.length, 3, 'speaking patterns');
    }

    // Helper function to load customization from server for cross-device sync
    async function loadCustomizationFromServer(characterSlug) {
      try {
        const userToken = localStorage.getItem('user_token');
        const userUid = localStorage.getItem('user_uid');
        
        if (!userToken || !userUid) {
          console.log('üì± Using local customization only - no auth data');
          return null;
        }
        
        console.log('üîÑ Loading customization from server for cross-device sync...');
        
        const response = await fetch('/.netlify/functions/get-customization', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            user_uid: userUid,
            character_slug: characterSlug
          })
        });
        
        if (response.ok) {
          const result = await response.json();
          if (result.success && result.customization) {
            console.log('‚úÖ Loaded customization from server');
            
            // Also update localStorage with server data
            const customizedCharacters = JSON.parse(localStorage.getItem('customizedCharacters') || '{}');
            customizedCharacters[characterSlug] = result.customization;
            localStorage.setItem('customizedCharacters', JSON.stringify(customizedCharacters));
            
            return result.customization;
          }
        }
        
        console.log('üì± No server customization found, using local data');
        return null;
      } catch (error) {
        console.log('üì± Server sync failed, using local customization:', error.message);
        return null;
      }
    }

    // Helper function to save customization with server sync for cross-device access
    async function saveCustomizationWithSync(characterSlug, customization) {
      // Save to localStorage first (immediate access)
      const customizedCharacters = JSON.parse(localStorage.getItem('customizedCharacters') || '{}');
      customizedCharacters[characterSlug] = customization;
      localStorage.setItem('customizedCharacters', JSON.stringify(customizedCharacters));
      
      // Sync to server for cross-device access (async, non-blocking)
      try {
        const userToken = localStorage.getItem('user_token');
        const userUid = localStorage.getItem('user_uid');
        
        if (userToken && userUid) {
          console.log('üíæ Syncing customization to server for cross-device access...');
          
          const response = await fetch('/.netlify/functions/save-customization', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify({
              user_uid: userUid,
              character_slug: characterSlug,
              customization: customization
            })
          });
          
          if (response.ok) {
            console.log('‚úÖ Customization synced to server successfully');
          } else {
            console.warn('‚ö†Ô∏è Server sync failed, but saved locally');
          }
        } else {
          console.log('üì± Skipping server sync - no auth data');
        }
      } catch (error) {
        console.warn('‚ö†Ô∏è Error syncing customization to server:', error);
      }
    }

    // Initialize personality customization system
    initializePersonalitySystem();
    
    console.log('‚úÖ Narrin AI Chat with Selira-inspired design ready');
  </script>

  <!-- Upgrade Popups -->
  <script src="/js/upgrade-popups.js"></script>
</body>
</html>